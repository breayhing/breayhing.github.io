[{"title":"计算机网络实验学习复盘","url":"/2023/04/20/cs-net-lab-review/","content":"敲python代码时候的好习惯：使用try,finally(看epoll示例才发现你个哈批)try:    ...finally:    ...\n\n\n\n\nOpen socket connections don’t need to be closed since Python will close them when the program terminates. They’re included as a matter of good form.()\n\n","tags":["学习笔记"]},{"title":"建站踩坑录","url":"/2023/03/02/blog%E5%BB%BA%E7%AB%8B%E7%AB%99%E7%82%B9%E8%AE%B0%E5%BD%95/","content":"在经历长达一天的艰苦修改（改一些奇奇怪怪的神奇bug）之后，这个网站总算是建立起来了，之后的时间应该就是使用这里来记录一些学习中的记录以及一些日常的琐碎话吧\n\n建站鸣谢：傻白的blog以及帮了很大忙的131blog\n传送门：\n启用主题 | 131’s Blog (cxy131.site)\nはくのblog (sirohune.site)\n\n踩坑实录：\nhexo d #部署网站\n\n坑点在于之前使用jekyll部署过网站，因此再使用hexo部署时会导致出现很神奇的bug：github相应网页的代码更新，但是action中显示没有部署。来回摸索好久\n最终解决方案：将原本的GitHub库删除重新搭建（删库跑路法），成功\n","tags":["那些神奇的坑与神奇的问题"]},{"title":"软件工程中级实训复盘（流水账）","url":"/2023/04/20/cs-intermediate-project/","content":"目标：\n\n建立bbs\n\n开发语言：\n\nGO：Gin\n\njs：Vue\n\n前端搭建：vite\n\n\n数据库：MySQL\n\n\n暂时任务：\n\n学习go语言\njs，vue学习\n搭建GO，js（Vue）相关开发工具以及环境配置\n数据库开发工具，环境配置\n分析：文档编写（）\n\n流程（gpt部分）\n创建一个空的 Go 模块和一个 main.go 文件。\n在 main.go 文件中添加必要的包和路由，例如 gin、gorm 和 vue.js。\n创建一个数据库模型，例如 Post 和 Comment，然后使用 gorm 创建对应的数据库表。\n创建一个 GET 路由，用于返回主页面的 HTML 和 JavaScript 代码。\n创建一个 POST 路由，用于接收帖子的标题和内容，并将其存储到数据库中。\n创建一个 GET 路由，用于返回特定帖子的 HTML 和 JavaScript 代码，并在该页面上显示相关评论。\n创建一个 POST 路由，用于接收评论的内容，并将其存储到数据库中。\n在前端中，使用 vue.js 创建一个主页面，其中包含一个表单用于发布新帖子，并显示所有帖子的列表。\n在每个帖子页面上，使用 vue.js 创建一个表单用于回复评论，并显示所有评论的列表。\n将前端代码和后端代码合并在一起，并使用 gin 提供静态文件服务。\n\n具体流程解释：\n工作日志部分（包括发癫部分）4.20尝试进行前后端分离暂时理解：前后端分离&#x3D;前端+后端分为两个部分，两个部分都要运行起来整个程序才能跑？\nGPT的解释：\n前端部署：前端部分通常被打包成静态文件，并通过 Web 服务器（如 Nginx、Apache 等）提供给用户。前端部分可以使用 CDN（内容分发网络）来加速页面加载速度，并减轻 Web 服务器的负载压力。同时，前端可以使用缓存技术（如浏览器缓存、CDN 缓存等）来提高应用程序的性能和用户体验。后端部署：后端部分通常运行在独立的服务器或云平台上，用于处理前端发送的请求并提供相应的数据和服务。后端部分可以使用负载均衡技术（如 Nginx、HAProxy 等）来分发请求，并使用容器技术（如 Docker、Kubernetes 等）进行部署和扩展。同时，后端可以使用缓存技术（如 Redis、Memcached 等）来提高应用程序的性能和可扩展性。数据库部署：数据库通常被用来存储应用程序的数据，可以使用云数据库（如 AWS RDS、Azure SQL 等）或自建数据库（如 MySQL、PostgreSQL 等）来存储数据。数据库可以使用主从复制、读写分离等技术来提高数据的可用性和性能。持续集成和持续部署：可以使用 CI/CD 工具（如 Jenkins、GitLab CI、Travis CI 等）来实现自动化构建、测试、部署和发布。通过持续集成和持续部署，可以实现快速迭代和部署，提高开发效率和应用程序的质量。\n\n所以前后端的定义，不应该是以语言来定义，而是应该以它的运行环境，如果是在服务器端，就应该被称之为后端，代表着你看不见，摸不着。而如果运行在用户端，就应该被称之为前端，代表你是可以看得到的。\n\n看一些博客的理解：\n前端后端的两种协作方式：B&#x2F;S,C&#x2F;S\n\nref：\n(26 封私信 &#x2F; 82 条消息) 如何正确理解前后端分离? - 知乎 (zhihu.com)\n前者的html文件由服务器端生成\n后者是html由浏览器生成，后端负责传递数据\n在前后端分离的方式，浏览器和服务端传递的是数据，而在服务器端渲染的过程中，传递的是Html网页。\n盒马生鲜提供两种方式，一种是前后端分离，一种是服务器端渲染。\n前后端分离是哪种方式呢？就是外卖或者是直接买生鲜，自己回家去做。\n服务器端渲染是哪种方式呢？就是直接在盒马鲜生自己加工，直接吃，或者是带回家吃。\n想法：使用前后端进行分离，可以将后端代码日后用java进行重构，前端保留之前的接口和文件？\n4.22重新使用go进行后端构建和前端，尝试做到前后端分离（感觉想法可以实现）\n后端使用gin网络框架，通过axios进行通信\n使用的技术栈：\n前端搭建：vite\n使用语言：typescript\n\n开始记录：\n目前可以打开网页，考虑如何进行网页交互\n网页资源交互成功过一次，之后都不行了（好奇为什么，进一步研究一下）\n\n4.23\n使用postman作为API测试工具（学习捏）\n\n4.24\n尝试去学习postman（准备痛苦面具）\n\n需要學習的東西\nJSON文件格式\n使用postman\napi document\n编写弄好的json测试文件进行测试\n\n\n用vue的vite搭建好前端项目进行项目对接部分\n\n记录（包括各种想法）\n可以使用mui组件库去设置（会方便很多）\n\n执行命令方法：前端：\n//接下来的命令顺序执行yarn create vitecd bbs-frontend yarn //安装对应依赖 yarn dev //开始项目\n\n后端：\n数据库部分：\n//默认root密码修改为123456//修改文件的位置在zhongzhu-bbs\\config\\config.ini//另一个默认填充的位置在zhongzhu-bbs\\utils\\setting.go//先打开mysql命令行进行如下操作CREATE DATABASE testbbs;//此处testbbs是所使用的数据库show databases;//使用该句检测是否建立数据库成功\n\n开始整个项目：\n\n\n","tags":["项目开发进度日志"]},{"title":"Web项目开发日志","url":"/2023/04/16/web%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/","content":"Web项目开发日志3.31\n前端：使用React和Axios，mui等等渲染库\n后端：使用python写，通过一个MongoEngine，使用mongodb数据库\n\n问题：\n\n前端调用的哪一个后端的接口获取数据库数据\n前端如何将获得的数据进行显示（尤其是不同的url是怎样显示到前端的）\n\n4.1\n暂时别想关于权限，就任意用户都能将所有人信息都展示出来\n\n总结：\n\n显示resource not found，进一步想想办法，怎么把数据导出来\n\n4.2\nAPI Contract 用户查询 - Meteoroid.fit - Confluence (atlassian.net) （该页面了解少，不太明白）\n确定就是axios的，接下来去看一看axios的api吧。。。。\n接下来想办法找到resources的存放位置，能找到就能导入\napi接口部分去看了，未找到，下一步看一看后端有没有相关连接\n\n\n\n4.3\n根据郑哥可以导入数据（使用axios框架的get api），目前用户列表可以展示\n准备弄用户个人界面\n\n4.16：filter部分(前端)根据mui的filter进行操作，尝试学着去弄\n才发现.env好像放在api-sdk里面了，没有放到backend里面\n4.17好像弄懂了是哪一个contains，下一步暂时目标明确了\n\n改写filter，让只包含contains\n现在需要去寻找一个包含filter的位置的东西（再去进一步研究一下）尤其是有没有data相关的东西\n\n下半：\n\n修改filter（通过在Grid中进行修改，现在做到了只有contains字段）\n下一步去研究如何将数据一并进行修改，并且显示（考虑使用原本的API？）\n现在的问题：对于sort完全没有修改，value可以自主识别\n想法：也许修改好参数，可以传入value，之后就可以进行排序了？\n可以在之前基础上调整一下参数传入？（这样可以吗？）\n怀疑：参数的问题，现在getfiltermodel第三个参数正常（使用后就是排序）\n怀疑第二个参数不对劲（传入后没有反应）\n\n\n成功！不过还有优化空间\n filter与sort之间的逻辑前后执行问题（现在先sort再filter可以，反之则不太行）\n 对于没有过滤器的选项，直接取消filter选项（已经解决）\n\n\n\n终于！凹了大概八九个小时？（其实总共用的时间加起来大概是十几个小时的时间），终于把需要的功能做出来了\nnice！！！今晚去健身房锻炼一下，现在超级爽\n稍微复盘一下学到的东西\n\n对于mui的理解大大加强了（至少这个周六日静下心来仔细啃了一遍）\n对于axios的理解也了解了更多一些（rect可以用，之后也可以用于vue语言的前端代码编写）\ngpt真的好用（不光是用于写代码，更好的在于理解你需要做的事情，帮助你去快速学习一个新的概念并且非常有逻辑）\n着重看了js的回调函数callback部分，关于异步同步的理解方面\n\n下一步准备：\n\n没事的话（虽然拿脚趾头想都会感觉不会没事）去看一下项目的代码\ngo语言项目等待进度然后去稍微赶一下（vue和react的共通之处稍微了解一下）\n现在主要身份即是开发者（web项目）也是挂你人员（中级实训部分），考虑一下全栈（虽然大概率现在就在这样子做）\nreacct的hook继续去看一下\n计网和操作系统的书去看一下（这一周，至少周二之后终于可以闲下来俩天了）\n\n4.24\n去修改一下commit\n\nVSCODE快捷键ctrl+shift+f  #全局搜索代码\n\nVS Code 的常用快捷键 - 知乎 (zhihu.com)\n","tags":["项目开发进度日志"]},{"title":"Web技术学习笔记","url":"/2023/03/08/web%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/","content":"web项目会议记录3.6（第一次会议）参会人员：xxx（大气学院学长），Qingyu（澳洲学长，提问）\n工作内容：\n流星多站视频检测网（观测流星）\n介绍部分：观测流星手段：\n\n光学观测\n雷达观测\n\n发光高度：约80-100km，使用三角定位（即初中数学题的三角问题）\n特征：\n\n时标短，短曝光，连续拍摄\n\n重重重点：并不是在某个地方建立很贵的设备，而是在很多地方分布式地建立多个流星观测站点执行部分硬件设计：使用快速读出的CMOS相机配合GPS模块提高时间精度（天文级别摄像头）\n前两步（检测流星，测量流星天球坐标）\n开发内容：对流星数据使用相应的定轨软件进行定轨，并且存入数据库，在网站实时进行可视化图形显示（中间包括传输图片，分析轨道，服务器计算，部署，图形改变）\n要求：\n\n在流星从可以观测到到坠落发光的一分钟内可以计算出来流星的落点（想办法精确到准确的地点）\n使用C++和python包\n\n数据平台\n开发上百个及更多的站点（这里考虑使用go语言）\n开发简单易用的流星检测润建与流星数据平台\n不是给专业人员如老师或相关学生，而目标用户更多是对天文感兴趣的非专业人员使用的平台\nSAS模式，软件与平台绑定，用户做的操作都是可以在网页端口进行操作，同时用户使用的本地数据也会传递到软件平台上面作为收集数据\n想办法激励用户去使用这种软件去拍摄流星，并且可以相对强制收集数据\n目前原型只有简易文档，可视化展示的demo，与可以简单的操作相机（部署的观测相机）进行拍摄\n相机控制，拍摄图片已经可以上传到数据库\n\n需求分析：主要任务：\n\n针对原有后端API，优化前端界面（着重提升用户体验与易用性）\n对于图形界面开发，要求美化\n\n本次会议目标\n给出基本任务，需求，分活干\n\n提出问题\n郑：经常使用的软件询问：使用UFO CAPTURE\n\n\n界面很丑（06年的）\n功能完善（图像监测部分）\n个人感觉：过于专业而且门槛高（参数过于复杂过于麻烦）\n畅想：网页端，因此不用专门要求某一个具体软件或者平台，可以快捷访问\n\n\n老师提问：有没有关于之后的长期规划\n\n\n第一在于自身发展与规划\n自己答案：数据流相关（ctm你这是什么回答啊）\n\n\n郑答案：云的系统维护和云的架构开发\n\n\n很想了解底层的硬件开发（如相机的硬件配置）\n全栈的一个开发\n\n\n面试选上我们的原因\n\n\n郑：前端了解，项目经验丰富，发展方向明确，大三知识全面\n我：知识差距，也没有完整的体系，对于项目经验不够了解，主要让他们感兴趣的部分在于我表现出来的积极性与自身的学习能力，也就是感觉自己比较有潜力，还是精力与积极性的问题。\nQingyu学长本身就是澳洲关于云方向的工作，在架构开发方面（自己可以去了解）\n\n\n项目本身希望可以严肃开发，不希望得到过多专注。\n\n\n项目技术层面：已经有的东西：\n主要语言：C++与python写的\n\n图形的提取，计算都是client端完成，主要C++开发，但是接口部分使用python写的（后端也是python写的），因为天文相关python使用更加普遍，可以在之后更容易引入相关的库与添加模块，对于底层部分感兴趣可以去看一下\n\n自己可以修改任何感觉不好的地方（多提出想法）\n\n控制部分完善，不要碰\n\n数据展示部分还\n\n数据库里面已经存储好了流星\n\n重点：流星的可视化，用户的管理设计，尤其在于权限的设计，也就是说开发部分\n\n\n可视化\n用户管理\n安全问题（权限部分可以问一问计网老师？）\n\n\n汉化部分在开发，目前都是英语界面\n\n后期会发技术文档，\n\n\nclient：（服务端与客户端）\n\n与后端通信有两条通道\n第一条是RESTFUL API（这里需要查询）\n第二条是websocket（需要了解）\n第一条主要需要流星的进入数据库\n第二条是双向通道，\n\n能够维护一个节点死和活的状态，即感知client端的健康状况，包括cpu占用等等\n使用一个队列进行处理\n\n\n\n\n一定要了解MongoDB,是一种模型，可以分布式部署，可以以较低成本承担相当大的数据量，对于python定义的数据结构（比如json）可以方便映射到数据库中，所有信息包括用户信息都是放在这个数据库中，迭代很快，使用了MongoEngine\nspringboot中，映射到DAO\n\n流星文件：（主要文件）\n\n存储位置：阿里云的OSS（类似云原生的一种网盘），SPA\n可以理解为一种托管静态文件的位置\n属于对象存储（google最早做出来的），整个系统基于服务器很容易坏构建，优点在于相当容易恢复\n可靠性高，可访问性高，延迟，带宽（北京的服务器在澳大利亚也要求可以访问）\n利用阿里云的高带宽（支持很多人同时访问），并且价格便宜\n\n系统日志：\n\n存储在阿里云的日志产品\n可以有更好的储存和访问，方便与之后使用\n别的节点进来，方便进行读取\n\n前端部分：\n\n使用React+typescript（js的超集，在语法上增加了类型系统），对于后置位定义很类似golang\n了解React oter(好像单词不对)\n用vscode支持最好\n也存在阿里云里面（React编译完相当于一个javascript文件），OSS占比很高\n\n后端与前端交互\n\n使用web socket，轮询，long polling\n部署在腾讯云上面\n\nMQ：\n\n触发MongoDB,触发原本数据库中的文件对卫星进行定轨道\n\nLambda Function\n\n当前完全没有\n对标的是函数计算的一个东西\n语法上属于对于请求（消息队列，时间调度），会很快起来一个进程并且销毁，是根据进程的运行时间计算花费，因此可以做到短时间内高速地跑很多请求\n用于降低成本\n\n自己任务：（自己总结的）\n了解MongoDB，如何将object映射到ORM，后端会相关了解\n了解阿里云OSS，后期会有相关账号使用\n去看对象存储相关的技术书\nOSS如何托管SPAl\n学习typescript（js可以埋了），看书\npython去学习一下\n\n老师认为我们应该快速去学习的\nTypescript马上去了解（语法基础情况）\nReact 17-18（文档），18主要引入的concurrent mode暂时不用管，但是17的文档要快点看，完整看一遍\n使用了一个组件（material UI）\n通信走的是accil(不一定准确，再去了解)\n了解Mongo DB&#x2F;Mongoengine(数据结构去了解一下)\n后端部分：python+flask框架\nvscode相关配置\n工具方面使用GitHub，发群里\n文档方面使用confluence（看一看啊看一看），注册一下\n\n流程总图例会时间：每周三七点半自己学习：\nTailwind:一种CSS上的UI组件库\nAxios:一个网络请求库，可以用于浏览器和node.js\n\n3.15 初次干活（API设计）\n主要内容：\n\n怎么搭建框架\n怎么写代码（使用什么工具）\n怎么提交代码\n怎么测试代码等等等等\n\n认识到 \n\n需要每周也准备一个周报（草！！！草！！！！周报！！！！啊啊啊啊啊啊啊啊！！！！！！！！）\n自己要认真干活的！（啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\nreact老文档讲的不太行，还得看新的\n可以看情况使用（用得爽就行）\n节点程序跑在windows上面，这里不用强求\n一定一定一定要好好地去看一看技术书\n我还是有点东西的（叉腰伸手扭头！），嗨嗨嗨嗨嗨嗨嗨嗨，面试就爷过了，嗨嗨嗨\n\n开始弄流程部分了本地配置：\n\nReact配置部分\nnode可以使用NVM管理版本\n测试主要使用docker去测试\n\n要学习：\n\n继续了解技术栈的部分\nGitHub workflow这一部分相关的文档都去看一看\n阿里OSS（静态文件存储位置，包括流星）和log\n记住没事就写文档，写产出，写干的活\n取名字记得要按照卡号，有相关命名规范，与jira关联\n\n开发工具：\n\nGitHub 可以开新的分支开发新功能，但是别作死直接push（代码在push之后会触发工作流）\n\n顺便学到的东西\n\ngit pr：在merge之前点new pr，选择 base，从哪里merge到哪里（这一部分也要去稍微看一看），短期内两个人提一个pr，两个人分别去看一看对方的代码（看不懂地方去review一下再去问一问）\n使用Confluence（只需要看software）文档\nconfluence:文档工具\n会有一个如何跑系统的文档\n\n\njira：项目管理工具\n核心：sprint\n快速开发快速试错（试一试大家用的怎么样）\n有一个ddl（三周大ddl）\n可以与GitHub进行相关绑定\n有事情一定要在jira上面写一下，让大家都了解到\n\n\n\n\n画图很推荐的\n\n\n接下来的工作：（大概需要的）\n\n用户注册和管理（现在可以正常登录），（手动放置到数据库里面的）\n\n因此需要手动实现自动注册到数据库的东西（想想之前写入sqlite部分，学学Mongodb）\n注册流程需要整体改动，\n可以尝试设计一下API（这个可以等一下等老师做）\n短信注册（这个包括强行绑定手机号，看振业学长整理弄）\n\n\n邀请码前后端完全没有实现（试着设计一下邀请链接）\n邀请码生成：最后是一个UI号发送（主动发送给别人就行）\n可以后面升级成为waiting list\n邀请码有没有被使用\n邀请码是谁发送过来的\n如何测试邀请码的有效性\n\n\n\n邀请码发送\n邀请码的一个邀请邮箱，需要前端可以发送给后端并且返回结果，在真正注册的时候也是需要使用的\n\n\n用户管理界面\n展示并且管理所有用户的界面（权限部分暂时不需要太考虑），比如可以修改个人资料，姓名头像等等等等，可以看别的网站去了解\n\n\n\n\n\n\n总结需要干的活：\n邀请链接（应该沟通几次，如何提供这个链接）\n看一看代码，\n想办法连接本地数据库跑起来\n\n\n注册界面（前端展示，后端有数据传输）\n写管理所有用户的界面和展示\n\n设计（怎么设计，怎么评估标准）\n邀请码的存储结构\nAPI\nverify\nregister（已有部分可以改一改）\n\n\nFrontend流程（可以画图去弄一下）\n游客看是怎么弄的（无权限请求）\n\n\n有问题回头再讨论，但是一定要有相关文档和东西\n\n3.22log中关于event（上传新的东西就会有event，可以报告给后端相机在什么时候拍摄到什么东西）\n\n相机每一次动作都会上报一个event（视频串流，最细力度是探测到流星）\n\n属于一种警报的部分\n\n严格来说是结构化的不是日志（日志格式更加动态，而该结构化会固定一些）\n\n项目中这种方法应该算是metric（与主线程不是一个逻辑，因此要尽量保证简化）\n\n\n原本项目回溯\nAPI设计基本落实完成\n\n新一周的任务\n学习python（超）（完成）\n\n学习jwt\n\n可以尝试去做用户个人（用户分页，这里可以先不做分页）\n\nUSER PROFILE(仿照原本的)\nnodes添加子section\n\n\n实现获取数据，渲染列表，点击到用户信息放大\n\n页表要是可以渲染的\n\n\n用户列表：\n\n所有用户，展示方式：展示信息\n\n\n期间就在metordev进行调试（要弄）\n\n看GitHub纯纯前端的部分，先去跑一下，别动node，其它可以试试可以改改，图标可以先去弄出来，在node下面弄出来原来类似的按钮（看源代码部分修改）\n不要删不要停，加点东西（尤其尤其refresh token不能动）\n使用kynn用户去可劲造\n使用第三个可以随便造\n\n\n\n注意：\n\n可以参考GitHub的设计风格去弄\n\n设计风格尽量遵循原本风格（灰色不可以更改，黑色可以更改）\n\n设计网站：pinterest（网站风格看）\n\nhttps://www.pinterest.com.au/\nhttps://berrydashboard.io/dashboard/default\n\n\n实在实在实在不行https://www.figma.com/\n\n\n有问题可以去约一下微信\n之前写的东西的回溯：\nUI使用python写的\n李镇业的部分：C++写的编译成byd文件，可以导入python\n剩下的部分都是围绕这两部分写的\n暂时实现对于相机的观测部分\n\n如何提交：\nlog.py文件中包含，log.critical上传至网络，增加event只需要使用critical去log它们就可以在不同的地方发送event\n同一个线程使用不同函数进行处理\n一个加入队列，一个agencyhandler处理队列（最顶部）\n其它子孙都是扔到queue里面\n只有一个agencyhandler\n写入同一个文件（两个线程写入同一个文件）\nworker处理多个manager\nextract库：分析流星的库\n\n\n一个client只有一个worker，属于一个进程之间传送队列的queue\n流星太多会在缓存中等待，大概一个流星几百M\n如果装不下就存入一个pkl文件，拿出来就变回流星数据结构\n\n\n\n\n\n\n\n权限部分：\nResourcePermission:将站点分为不同的资源\n总结权限最大\n\n\nNodePermission：仅仅属于个人\n个人权限较大\nnodeowner：创建该个node的人\n用户一定会有\n\n\n每个资源分配不同的决策\n前端要理解一下\n\n\n\n用户登录状态如何判断：\njwt：证明自己是谁(一种表明身份的哈希码)\n可能会开放因此没有限制（后期可以换成cookie login）\n正确会附带一个token（一段时间的期限）并且无法伪造，只有服务器有密钥可以签名（非对称加密）只有私钥可以加密，公钥可以解密\n不限制，有可能被token解密（属于一种cookie解密）\nhttps only cookie也可能被占用\n跨域攻击：在别的网站使用\n\n\n\n\n\n开发环境：周日详解（后端的dev环境）3.26（环境搭配部分）\n前端部分首先去弄一下\n\nyarn不能混用\n可能问题：node版本\n环境部分：start：dev（依赖于env-command）\n分享的文件：gist文件去修改local，（前端部分）\n后端部分：python最好（3.10.5），可以使用venv创建路径包含环境\n跑后端python3:run\n但是后端也包括Mongoliandb \ndocker compose up -ddocker compose build\n\n使用的时候会创建一个本地数据库，本地连接(mongodb compass)\nuser :api\nomega\n要首先把dev连接到数据库，然后恢复数据再弄\n-dev属于备份，方法\n\n放在mongodb copmass\n数据库备份技能去自己了解一下\nhost:127.0.0.1\nport:27017\n\n测试一个node行为时候可以去弄一个fake node，在api-sdk里面（后端用的一个sdk，本质是将客户端进行一个封装），进行连接之后就可以在自己本地进行一个play了\nnpm镜像找，还原\n坑pip install python-dotenv\nhttps://linuxcommand.org/tlcl.php\nhttps://code.visualstudio.com/docs\n重点部分：每一次js&#x2F;ts文件相关部分都要进行格式化处理（）\n4.5开会\n每周merge一下前后端的master代码，保证进度更新一下\n\n下一周的活：\n继续完善用户列表的功能（删除用户，增加用户，查找单个用户等等）\n\n删除（换成deactive）\n跳转：\n点击Name中的字段就直接跳转到用户profile\n\n\n图标换一个（换成文本按钮，可以点击）\n不需要新建\nnode部分可以放一下有哪些node节点\nresource不显示\n与account type冲突（原因）\n\n\n分页部分还没有更新（总页数没有）\n\n\n个人信息界面留一个空的，就留右上角的人（先别管）\n\n如果完善可以取看一下怎么弄邀请代码功能（暂时api可能没有更新）\n\n往上去增加（看一看）\n只有admin可以左边有一个按钮点击就是发送链接\n点击弹出一个小框\n输入邮箱\n在点击确认之后就会向后端发送post请求\n\n\n\n\n自己去看一下mui里面有没有自己能使的东西（相关知识也得看一看）\n\n组件可能要自己整点新的\n\nfilter(加过滤器搜索)在list框加上\n\n排序（改一下调用的api的排序，现在有的是mui的，只能对于当前页排序）\n\n老师已有api（排序的，再去看一看）\n\n\n\n4.12日：新硬件团队加入问题：\n\ninvite-link点击之后暂时可以在列表中显示，但是实际邮箱无法获得发出的邮件，是否因为没有部署到服务端而只是在本地运行\n\n可以有修改方向：\n\n关于搜索方式的框可以去优化一下体验（适应一下宽度，修改格式并适当美化）（搞定）\n如何进行排序，看一下相关的api接口（）\n搜索中的last_active没有展示，导致会bug（）（修改一下展示的部分）（暂时就是改了这个，直接弄没有了）\n搜索栏右侧三个点没有相应功能\n\n任务：\n研究mui部分，在外面能不能加入一下，去掉\n排序去继续研究，怎么弄完\n邀请链接部分，研究如何连接阿里云上网（api也连上再去调用）（调用邮件发送的api，去看一看）\n邀请链接的detail中不要使用文本框，修改成只用几行字去改（一两天尽量快速弄）\n一些神奇的bug（下次开会去问孟老师）\n邀请列表弄完去pr（至少要提pr）\n\n新任务（要死了）\n做用户注册（使用register.js和login.js）\n假设使用这个url进入界面\n前端不用做太多，只需要改rote\n能不能加一下检测密码强度组件（非强制，有最好，没有也能用）\n先提个方案出来\n\n4.19review\n\npr继续完善一下\n对于之后pr提出的问题稍微回一下\n好习惯：不同模块之间最好还是加上空行\n记得依赖相关的去解决一下（稍微留意留意）\n\ntask：\n\n准备实现短信验证相关的功能\n路由器注册也需要注意一下\n\n考虑，讨论关于注册表单：\n可以在单个页面中完成全部的注册部分（短信验证码）还有其它注册\n任务：\napi准备好后开始做整个注册的流程（别急，可以白兰），至少可以通过验证到达registeredlist界面\n邀请链接的超时时间修改成3天（api到时候看）\n\n执行步骤\n前端开启\nyarn #每一次更新重新安装所需依赖#正常pwsh就行yarn run start\n\n\n后端（WSL上面跑，有python10的解释器）\n\npip install -r requirements.txt #重新安装依赖，每一次更新后端之后跟着改一下，好习惯docker compose up mongo -d # 开启docker的数据库，也可以自己手动在docker里面打开source /home/breathlinux/meteoroid-backend/venv/bin/activate #进入venv环境# （venv）中make run\n\n\n联网（API部分弄上去）\n\n# 都在wsl里面操作python3 -m venv venvpython3 example/websocket_example.py\n\n\n数据库恢复\n\nmongorestore --host=127.0.0.1 --port=27017 --username api --authenticationDatabase=meteoroid-ingestion-data-dev dump\n\n\n\nhttps://www.mongodb.com/docs/manual/tutorial/backup-and-restore-tools/Qingyu 18:58REACT_APP_API_BASE_URL=&quot;http://localhost:8080/api/v1&quot;REACT_APP_WS_BASE_URL=&quot;ws://localhost:3000/user&quot;PORT=8080Qingyu 19:02python3 -m venv venv Qingyu 19:03sudo apt install python3-pipQingyu 19:03https://bootstrap.pypa.io/get-pip.pyQingyu 19:04wget https://bootstrap.pypa.io/get-pip.pyQingyu 19:05python3 get-pip.pyQingyu 19:09docker compose up mongo -d Qingyu 19:13python3 -m pip install --user virtualenvQingyu 19:13python3 -m venv venvQingyu 19:16source ./venv/activateQingyu 19:16source ./venv/bin/activateQingyu 19:19https://www.mongodb.com/docs/database-tools/installation/installation-linux/胡锡睿21311094 19:24wget https://fastdl.mongodb.org/tools/db/mongodb-database-tools-ubuntu2204-x86_64-100.7.0.debQingyu 19:25mongorestoreQingyu 19:27 mongorestore --host=127.0.0.1 --port=27017 --username api --authenticationDatabase=meteoroid-ingestion-data-dev meteoroid-ingestion-data-dev Qingyu 19:27omegaQingyu 19:28mongorestore --host=127.0.0.1 --port=27017 --username api --authenticationDatabase=meteoroid-ingestion-data-dev dumpQingyu 19:29mongodb://api:omega@localhost:27017/?authSource=meteoroid-ingestion-data-dev&amp;readPreference=primary&amp;directConnection=true&amp;ssl=falseQingyu 19:38python3 example/websocket_example.pyQingyu 19:39pip install python-dotenv=Qingyu 19:42pip install -e .Qingyu 19:43PYTHONPATH=src# For testNODE_TOKEN=aynCYbYHwygUb_C1KsUHW-5mJ84cGxYpr4DFgc_lT3cNODE_ID=62ceebf19647f288525ab619API_SERVER=http://localhost:3000/api/v1Qingyu 19:48https://linuxcommand.org/tlcl.phpQingyu 19:48https://code.visualstudio.com/docs\n\n","tags":["项目实习笔记"]},{"title":"数电","url":"/2023/03/04/%E6%95%B0%E7%94%B5/","content":"考完试的感觉就是：题量哈人。\n两个小时的考试时间实际上是很紧张的，主要在于画卡诺图和真值表部分。\n\n考题中出现的一些重点（想起啥算啥吧）\n选择&#x2F;填空：第十章和第十一章的比例相当高，而且其实占分比还是挺高的(关于存储器，尤其是第十一章的信号转换)\n大题设计：重点在于了解三个基础芯片（151，138，73都考到了，和老师说的一致），以及快速，准确地画好卡诺图和真值表，否则时间会很紧张\n","tags":["考试复盘"]},{"title":"站点更新记录","url":"/2023/03/10/%E7%AB%99%E7%82%B9%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/","content":"目前问题：\n\n 代码高亮问题（啊哈）\n 图片未跟上插入（可以考虑新开文件夹用于存放图片）\n 备案？（这个暂时不需要考虑吧。。。大概？）\n 能不能将pdf上传（这样子直接上学过的东西就方便了）\n 对于背景继续进行进一步修改\n 看看这个主题的源码去了解一下设计思路\n\n想法：\n\n 能不能再加一些桌面动态变化效果（比如页面滑动变色等等）\n 评论系统可以考虑增加（研究一下数据库配置问题）\n 关于能不能将思维导图上传（可以去找codesheep取经取经）\n\n","tags":["历史"]},{"title":"数据结构与算法 PART 2","url":"/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95PART2/","content":"数据结构与算法：PART 2搜索与图论查找中静态与动态差异仅在于是否可以动态增删元素\n动态查找在几何计算上应用广泛\n搜索种类：无信息搜索：\n1.DFS：递归结束条件的选择+状态标记+递归后的恢复(也可以用栈来搭建出来)2.BFS：模拟队列 q[N], d[N] 使用d数组标记状态3.搜索：解空间的搜索往往需要dfs+剪枝，bfs用来找最短路4.树和图的存储：邻接表 h[N], e[N], ne[N], idx5.树和图的遍历：遍历不用像搜索解空间一样递归后恢复，只用遍历一次即可\n有信息搜索：\nA搜索算法\n建立搜索模型：\n\n\n\nDFS优势：可以获取子树的大小核心：顺序842. 排列数字 - AcWing题库\nDFS人称暴力搜索，对应的是一个多叉树的形式，DFS的搜索顺序和前序遍历其实一样，但是实际上存储结构只会存一条路径，回溯的时候就会消失，不需要真正建立树，但是一定要注意恢复现场\n![深度优先遍历.png](D:\\typora note\\55289_0cd4222d73-深度优先遍历.png)\n举例：全排列做法，使用回溯（还可以使用剪枝）\n全排列做法：时间复杂度为 O(n*n!)。\n空间复杂度为 O(n)。\n算法：\n\n用 path 数组保存排列，当排列的长度为 n 时，是一种方案，输出。\\\n用 state 数组表示数字是否用过。当 state[i] 为 1 时：i 已经被用过，state[i] 为 0 时，i 没有被用过。\ndfs(i) 表示的含义是：在 path[i] 处填写数字，然后递归的在下一个位置填写数字。\n回溯：第 i 个位置填写某个数字的所有情况都遍历后， 第 i 个位置填写下一个数字。\n\n#include&lt;iostream&gt;using namespace std;const int N = 10;int path[N];//保存序列int state[N];//数字是否被用过int n;void dfs(int u)&#123;    if(u &gt; n)//数字填完了，输出    &#123;        for(int i = 1; i &lt;= n; i++)//输出方案            cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;    for(int i = 1; i &lt;= n; i++)//这里就是选择如何遍历，想反方向就是逆序遍历了        //空位上可以选择的数字为:1 ~ n    &#123;//关键在这里        /*        比如123        回溯到1，state[2]=0,2又可以用，但循环走到了2，到3了，因此是132        */        if(!state[i])//如果数字 i 没有被用过        &#123;            path[u] = i;//放入空位            state[i] = 1;//数字被用，修改状态            dfs(u + 1);//填下一个位            state[i] = 0;//回溯，取出 i        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n;    dfs(1);//从1开始    &#125;\n\n\n\nDFS另一种应用：皇后位置c++直接完整版本代码：（LeetCode 版本）\nclass Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;// n 为输入的棋盘大小// row 是当前递归到棋牌的第几行了void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;    if (row == n) &#123;//回溯到最后一行，说明满足情况了        result.push_back(chessboard);        return;    &#125;    for (int col = 0; col &lt; n; col++) &#123;        if (isValid(row, col, chessboard, n)) &#123; // 验证合法就可以放            chessboard[row][col] = &#x27;Q&#x27;; // 放置皇后            backtracking(n, row + 1, chessboard);//再进一行进行检验            chessboard[row][col] = &#x27;.&#x27;; // 回溯，撤销皇后        &#125;    &#125;&#125;bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    int count = 0;    // 检查列    for (int i = 0; i &lt; row; i++) &#123; // 这是一个剪枝        if (chessboard[i][col] == &#x27;Q&#x27;) &#123;            return false;        &#125;    &#125;    // 检查 45度角是否有皇后    for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) &#123;//另一个剪支        if (chessboard[i][j] == &#x27;Q&#x27;) &#123;            return false;        &#125;    &#125;    // 检查 135度角是否有皇后    for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] == &#x27;Q&#x27;) &#123;            return false;        &#125;    &#125;    return true;&#125;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        result.clear();        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#x27;.&#x27;));        backtracking(n, 0, chessboard);//注意这里是从0开始的，所以最后到n，实际上以及对n层进行了判断        return result;    &#125;&#125;;/*总结操作流程：类似二叉树，对每个节点进行遍历，实际复杂度是n^2，从开头一直向下延申，可满足情况进行返回\n\nc++数组版本皇后问题:老子自己写的！（双手叉腰）\n#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int maxn=9;int solu[maxn]=&#123;0&#125;;int qn[maxn]=&#123;0&#125;;bool isValid(int posj,int posi)//最后那个pos也就是棋子的坐标&#123;    //posi=i,posj=qn[i]    if(posi==0)return true;    for(int i=0;i&lt;posi;i++)    &#123;        if(qn[i]==posj)return false;//相同的列判断    &#125;    for(int i=posi-1;i&gt;=0;i--)//45判断    &#123;        if(posi-i==posj-qn[i])return false;    &#125;    for(int i=posi-1;i&gt;=0;i--)//135    &#123;        if(posi-i==qn[i]-posj)return false;    &#125;    return true;&#125;void backtracing(int n,int row)&#123;    if(row==n)&#123;//终止了，找到了其中一种解决方案        cout&lt;&lt;&quot;bottom reached\\n&quot;;        cout&lt;&lt;&quot;solution:\\n&quot;;        for(int  i=0;i&lt;n;i++)        &#123;            cout&lt;&lt;&quot;row &quot;&lt;&lt;i+1&lt;&lt;&quot; equals to &quot;&lt;&lt;qn[i]+1&lt;&lt;&quot; \\n&quot;;        &#125;        cout&lt;&lt;&quot;go find other solution\\n\\n&quot;;        return;    &#125;    else&#123;        for(int i=0;i&lt;n;i++)//注意这里的传参        &#123;            qn[row]=i;//row，行固定，列用变量i对每一行进行遍历，如果满足之前条件进入下一行            if(isValid(qn[row],row))//该行该位置能否放            &#123;                backtracing(n,row+1);//可以就继续往下走            &#125;        &#125;    &#125;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    backtracing(n,0);&#125;\n\n\n\nBFS（使用二维数组）原因：宽搜的性质：辐射性向外搜索（想想一层一层向外扩张的信号）\n844. 走迷宫 - AcWing题库\n注意：\ndp问题和最短路问题其实是互通的\n边的权重都是1的时候才可以使用BFS求最短路，一般都用最短路\ndp问题不能用最短路算法（最短路时间一般都高)\n第一次搜到的点才是最短的点，之后的都不是\n\n不同于深搜，宽搜一般有一个框架\n\n\n广搜的框架\n初始状态放到队列中\n写一个while循环，只要队列不空，在循环内每一次拿出队头，扩展队头\n\n往上下左右扩展的技巧：使用向量来表示\n代码（如该道题）\nvoid bfs(int a, int b): 广度优遍历函数。输入的是起点坐标。\nqueue q;:用来存储每一步走到的点。\nwhile(!q.empty())循环：循环依次取出同一步数能走到的点，再往前走一步。\nint dx[4] &#x3D; {0, 1, 0, -1}, dy[4] &#x3D; {-1, 0, 1, 0};:一个点往下一步走得时候，可以往上下左右四方向走。\n\n#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 110;int g[N][N];//存储地图int f[N][N];//存储距离int n, m;void bfs(int a, int b)//广度优先遍历&#123;    queue&lt;PII&gt; q;    q.push(&#123;a, b&#125;);//压入队列    while(!q.empty())    &#123;        PII start = q.front();        q.pop();        g[start.first][start.second] = 1;        int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;-1, 0, 1, 0&#125;;        for(int i = 0; i &lt; 4; i++)//往四个方向走        &#123;            int x = start.first + dx[i], y = start.second + dy[i];//走出一步之后            if(g[x][y] == 0)//如果还没有走过            &#123;                g[x][y] = 1;//该点进行更新,因为广搜中第一次遇到的就是最短路径                f[x][y] = f[start.first][start.second] + 1;//从当前点走过去，则距离等于当前点的距离+1.                q.push(&#123;x, y&#125;);//再入栈一个            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m];&#125;int main()&#123;    memset(g, 1, sizeof(g));    cin &gt;&gt; n &gt;&gt;m;    for(int i = 1; i &lt;= n; i++)//对地图进行一个更新    &#123;        for(int j = 1; j &lt;= m; j++)        &#123;            cin &gt;&gt; g[i][j];        &#125;    &#125;    bfs(1,1);//对起点进行bfs&#125;\n\n\n\n树和图的DFS，BFS树和图的DFS，BFS就是特殊的搜索（因为有那个环）\n树和图的遍历时间复杂度都是o（n+m）\n树与图的存储选择稠密图：邻接矩阵\n稀疏图：邻接表\n无向图实际上就是有向图进行一个对称\n有向图的存储方式\n邻接矩阵：同BFS，开二维数组存就完事了\n优化：使用vector向量\nint V,num;   cin&gt;&gt;V&gt;&gt;num;//V边数量   vector&lt;vector&lt;int&gt;&gt; graph(V);   vector&lt;vector&lt;int&gt;&gt; price(V);//记录权值   for(int i=0;i&lt;V;i++)   &#123;       graph[i].resize(V);       price[i].resize(V);   &#125;\n\n\n\n邻接表：使用数组模拟链表（还是注意idx的作用类似于分配器）,有多少个点开多少个单链表\n//这个的不好的地方是不好统计哪些地方已经走过和#include&lt;cstring&gt;//memset位置// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;//h存链表头，e存每一个节点的值，ne存每一个节点的下一个节点的地址，与单链表的不同就是把head换成h数组// 添加一条边a-&gt;bvoid add(int a, int b)&#123;    e[idx] = b;    ne[idx] = h[a];    h[a] = idx  ;    idx++;//是你熟悉的头插&#125;void add_to_tail(int x)//尾插&#123;    e[idx]=x;    if(head==-1//当是第一次插入时特殊处理    &#123;        ne[idx]=head;        head=idx;        idx++;        return;    &#125;    int i=head;    if(head!=-1)while(ne[i]!=-1)i=ne[i];//最后ne[i]=-1    ne[idx]=-1;    ne[i]=idx;    idx++;&#125;void dele(int a,int b)&#123;    \tif(e[h[a]]==b)h[a]=ne[h[a]];//如果在第一个元素的时候的操作方法       else\tfor(int i=h[a];ne[i]!=-1;i=ne[i])       &#123;       \tif(e[ne[i]]==b)//这里关系是       \t&#123;      \t\tne[i]=ne[ne[i]];      \t&#125;      &#125;    &#125;bool find(int a,int b)&#123;    for(int i=h[a],i!=-1;i=ne[i])    &#123;        if(e[i]==b)return true;    &#125;    return false;&#125;// 初始化idx = 0;memset(h, -1, sizeof h);//单链表的n个头节点全部变成-1\n\n另一种选择：使用vector+list来构建（很方便）\n树图DFS模板：这个模板同样是使用邻接表来存储的bool st[N];//同其它，st数组在一开始开好，用来表示该节点是否被遍历过int dfs(int u)&#123;    st[u] = true; // st[u] 表示点u已经被遍历过    这里是要对DFS进行的操作部分        for (int i = h[u]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (!st[j]) dfs(j);//递归进行向下遍历    &#125;&#125;\n\n846. 树的重心 - AcWing题库\n树的重心可能不唯一，但是树是唯一的\n该题解法：遍历删掉所有点之后连通块的最大值，之后在一堆最大值里面对比寻找出来最小的就行\n发现：获取了子树的大小也就获得了剩余树的大小（即全部节点数量减去子树的size就好）\n\n\n本题的本质是树的dfs， 每次dfs可以确定以u为重心的最大连通块的节点数，并且更新一下ans。\n也就是说，dfs并不直接返回答案，而是在每次更新中迭代一次答案。\n这样的套路会经常用到，在 树的dfs 题目中\n答案：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10; //数据范围是10的5次方const int M = 2 * N; //以有向图的格式存储无向图，所以每个节点至多对应2n-2条边int h[N]; //邻接表存储树，有n个节点，所以需要n个队列头节点int e[M]; //存储元素int ne[M]; //存储列表的next值int idx; //单链表指针int n; //题目所给的输入，n个节点int ans = N; //在最大连通块中寻找最小的那一个bool st[N]; //记录节点是否被访问过，访问过则标记为true//a所对应的单链表中插入b  a作为根 void add(int a, int b) &#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;//返回以u为根的子树中节点的个数，包括u节点int dfs(int u) &#123;    int res = 0; //存储 删掉某个节点之后，最大的连通子图节点数    st[u] = true; //标记访问过u节点    int sum = 1; //存储 以u为根的树 的节点数, 包括u，如图中的4号节点    //访问u的每个子节点    for (int i = h[u]; i != -1; i = ne[i]) &#123;//链表的遍历        int j = e[i];        //因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过        if (!st[j]) &#123;// u节点的单棵子树节点数 如图中的size值            int s = dfs(j);  //获取j为根的子树中节点个数            res = max(res, s); // 记录最大联通子图的节点数            sum += s; //以j为根的树 的节点数，也就是1+s        &#125;//每一次这样执行一遍就进行了一个节点的更新    &#125;    //n-sum 如图中的n-size值；    res = max(res, n - sum); // 选择u节点为重心，最大的 连通子图节点数    ans = min(res, ans); //遍历过的假设重心中，最小的最大联通子图的 节点数    return sum;//返回子树的节点个数&#125;int main() &#123;    memset(h, -1, sizeof h); //初始化h数组 -1表示尾节点    cin &gt;&gt; n; //表示树的结点数    // 题目接下来会输入，n-1行数据，    // 树中是不存在环的，对于有n个节点的树，必定是n-1条边    for (int i = 0; i &lt; n - 1; i++) &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        add(a, b), add(b, a); //无向图    &#125;    dfs(1); //可以任意选定一个节点开始 u&lt;=n    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\n\n\n\n树图BFS思想：从1开始不断扩展一层节点，然后不断向下辐射\n自闭环在dp问题中及逆行讨论\n模板：\n初始状态放到队列中\n写一个while循环，只要队列不空，在循环内每一次拿出队头，扩展队头的所有邻点\n只考虑第一次遍历，只要没有被遍历过，将x入队\n更新路径距离\n\n//使用邻接表进行存储稀疏图int ne[N],e[N],h[N];queue&lt;int&gt; q;bool st[N];//同其它，st数组在一开始开好，用来表示该节点是否被遍历过st[1] = true; // 表示1号点已经被遍历过q.push(1);//对1进行入队while (q.size())&#123;    int t = q.front();//t是队头    q.pop();//出队    for (int i = h[t]; i != -1; i = ne[i])//这里对该头能到达的所有点进行一次访问    &#123;        int j = e[i];//j也就是对应的节点的值        if (!st[j])//只要没有访问过        &#123;            该干嘛干嘛，进行需要的操作            st[j] = true; // 表示点j已经被遍历过            q.push(j);//入队        &#125;    &#125;&#125;\n\n847. 图中点的层次 - AcWing题库\n该题答案：\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int h[N], e[N], idx, ne[N];int d[N]; //存储每个节点离起点的距离  d[1]=0int n, m; //n个节点m条边int q[N]; //存储层次遍历序列 0号节点是编号为1的节点void add(int a, int b)&#123;    e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;int bfs()&#123;    int hh=0,tt=0;    q[0]=1; //0号节点是编号为1的节点    memset(d,-1,sizeof d);    d[1]=0; //存储每个节点离起点的距离    //当我们的队列不为空时    while(hh&lt;=tt)//不同的是这里用了数组模拟队列，一个道理    &#123;        //取出队列头部节点        int t=q[hh++];        //遍历t节点的每一个邻边        for(int i=h[t];i!=-1;i=ne[i])        &#123;            int j=e[i];            //如果j没有被扩展过            if(d[j]==-1)            &#123;                d[j]=d[t]+1; //d[j]存储j节点离起点的距离，并标记为访问过                q[++tt] = j; //把j结点 压入队列            &#125;        &#125;    &#125;    return d[n];//因为题目要求第一个点到第n个点就ok&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    memset(h,-1,sizeof h);    for(int i=0;i&lt;m;i++)    &#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        add(a,b);    &#125;    cout&lt;&lt;bfs()&lt;&lt;endl;&#125;\n\n一致代价BFS：改进版本BFS\n\n\n拓扑排序：BFS的一种应用（AOV网，流程能否正确执行）拓扑、dfs、并查集都可以图中判断有没有环， floyd可以找最小环\n仅针对有向图，无向图没得拓扑定义：每条边都是起点在终点的前面，即所有的边都是从前指向后面的\n\n\n这种算一个拓扑\n\n\n这种就不算了（有一个环，只要有环就一定木大）\n可以证明：有向无环一定可以整成一个拓扑图\n如何进行一个求一个有向图有入度和出度，由所有都是从前指向后，则所有入度为0的点都可以排在当前最前面的位置\n\n一个无环图一定至少存在一个入度为0的点\n有向无环的top序不唯一\n\n思路：\n所有入度为0的点进行入队\n进行一个BFS，每一次出队一个队头，然后找出所有出队列这个点发出的边，删除边，同时边的另一侧的点的入度 -1。\n如果d[j]&#x3D;&#x3D;0,说明j之前的都排序好了，入队j就完事了\n如果所有点都进过队列，则可以拓扑排序，输出所有顶点。否则输出-1，代表不可以进行拓扑排序。\n\n模板：bool topsort()&#123;    int hh = 0, tt = -1;    // d[i] 存储点i的入度    for (int i = 1; i &lt;= n; i ++ )        if (!d[i])            q[ ++ tt] = i;    while (hh &lt;= tt)    &#123;        int t = q[hh ++ ];        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (-- d[j] == 0)                q[ ++ tt] = j;        &#125;    &#125;    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。    return tt == n - 1;&#125;\n\n848. 有向图的拓扑序列 - AcWing题库\nAcWing 848. $\\color{green}{拓扑排序–思路介绍+图解模拟+详细代码注释 }$ - AcWing\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int e[N], ne[N], idx;//邻接表存储图int h[N];//邻接表表头int q[N], hh = 0, tt = -1;//队列保存入度为0的点，也就是能够输出的点，int n, m;//保存图的点数和边数int d[N];////保存各个点的入度void add(int a, int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;//邻接表的创建&#125;void topsort()&#123;    for(int i = 1; i &lt;= n; i++)&#123;//遍历一遍顶点的入度。        if(d[i] == 0)//如果入度为 0, 则可以入队列            q[++tt] = i;    &#125;//tt头，hh尾    while(tt &gt;= hh)&#123;//循环处理队列中点的        int a = q[hh++];//取出队头元素        for(int i = h[a]; i != -1; i = ne[i])&#123;//循环删除 a 发出的边            int b = e[i];//a 有一条边指向b            d[b]--;//删除边后，b的入度减1            if(d[b] == 0)//如果b的入度减为 0,则 b 可以输出，入队列                q[++tt] = b;        &#125;    &#125;    if(tt == n - 1)&#123;//进去了n个点        //如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序        for(int i = 0; i &lt; n; i++)&#123;//队列中保存了所有入度为0的点，依次输出            cout &lt;&lt; q[i] &lt;&lt; &quot; &quot;;        &#125;    &#125;    else//如果队列中的点的个数与图中点的个数不相同，则不可以进行拓扑排序        cout &lt;&lt; -1;//输出-1，代表错误&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;//保存点的个数和边的个数    memset(h, -1, sizeof h);//初始化邻接矩阵    while (m -- )&#123;//依次读入边        int a, b;        cin &gt;&gt; a &gt;&gt; b;        d[b]++;//顶点b的入度+1        add(a, b);//添加到邻接矩阵    &#125;    topsort();//进行拓扑排序    return 0;&#125;\n\n\n\n动态查找：二叉搜索树构建树：每个左孩子都比双亲小，每个右孩子都比双亲大\n插入节点：删除节点叶子节点直接删除\n节点p仅有一棵子树：• 直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树\n即类似链表的删除操作（懂得都懂）\n节点p既有左子树又有右子树：#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;const int M=1024;int tree[M]=&#123;0&#125;;int char_to_int(char a)&#123;    return (int)(a-&#x27;0&#x27;);&#125;void add_tree(int tree[],string a,int str_pos,int tree_pos,int judge)&#123;    int length=a.size();    if(str_pos&gt;length)return;    int num=char_to_int(a[str_pos]);    if(tree[tree_pos]==-1)//新节点插入    &#123;        tree[tree_pos]=num;        judge=0;        return;    &#125;    else if(num&gt;=tree[tree_pos])tree_pos=2*tree_pos+1;//大，向右边搜索    else tree_pos=2*tree_pos;//小,向左边搜索    add_tree(tree,a,str_pos,tree_pos,judge);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    string ans;    cin&gt;&gt;ans;//初始化的输入    int total=ans.size();    for(int i=1;i&lt;=M;i++)    &#123;        tree[i]=-1;//-1表示是空指针    &#125;    tree[1]=char_to_int(ans[0]);    for(int i=1;i&lt;total;i++)//开始对树进行节点插入    &#123;        add_tree(tree,ans,i,1,1);    &#125;//    cout&lt;&lt;&quot;origin tree:  &quot;;//    for(int i=1;i&lt;=M;i++) &#123;//        if (tree[i] != -1)cout &lt;&lt; tree[i] &lt;&lt; &#x27; &#x27;;//    &#125;    cout&lt;&lt;endl;    int str_com[M];    string str_a;    for(int time=0;time&lt;n;time++)//循环多少次    &#123;        if(time==6)break;        for(int i=1;i&lt;=M;i++)        &#123;            str_com[i]=-1;//进行初始化        &#125;        cin&gt;&gt;str_a;//新的输入        str_com[1]=char_to_int(str_a[0]);        for(int i=1;i&lt;total;i++)//开始对树进行节点插入        &#123;            add_tree(str_com,str_a,i,1,1);        &#125;        int judge=1;//        cout&lt;&lt;&quot;new tree:  &quot;;        for(int i=1;i&lt;=M;i++) &#123;            if(str_com[i]!=tree[i])            &#123;                cout&lt;&lt;&quot;NO\\n&quot;;                judge=0;                break;            &#125;//            if (str_com[i] != -1)cout &lt;&lt; str_com[i] &lt;&lt; &#x27; &#x27;;        &#125;        if(judge==1)cout&lt;&lt;&quot;YES\\n&quot;;    &#125;    int time;    cin&gt;&gt;time;    return 0;&#125;\n\n\n\n动态查找：kd树（图形相关的东西会涉及，很重要的一种数据结构）🙏空间划分树：\n\n网格\n四叉树\n二维树\n二叉空间分割树\n\n二维树：最近邻查找\n实际就使用了剪枝（即切除不可能的子树）\n最短路问题朴素Dijkstra算法(和堆有关)（面试也有）书的作者写的算法通常都很长\n与bf算法最大区别：所有边只松弛一次（bf每条边多次）（这里很有可能数据结构考）\n\n\n堆优化：Dijkstra\n应用场景：（什么时候使用该算法）\n计算机网络中网络传输问题（参考ele实验室路由器）与协议\n迷宫问题（往下看图形化篇章）\n\n核心思想：贪心\n迪杰斯特拉算法适用于求正权有向图中，源点到其余各个节点的最短路径。注意：图中可以有环，但不能有负权边。\n思路：s:当前已经确定最短距离的点\n\n初始化距离（只有起点的距离是确定的）\n开始循环迭代n次，找到不在s中的距离最近的点\n用 t来更新其它所有点的距离（就能更新起点到每个点最短距离）\n\n模板：（朴素版本的Dijkstra）复杂度：n^2849. Dijkstra求最短路 I - AcWing题库\nAcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing\n注意这里读入都是从1开始\ndist注意初始化为+∞\nint g[N][N];  // 存储每条边int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定const int INF=0x3f;//用于标注是无穷点// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra()&#123;        memset(dist, 0x3f, sizeof dist);//所有距离初始化成正无穷    dist[1] = 0;//起点到起点当然是0力    for (int i = 0; i &lt; n - 1; i ++ )//这里i不重要，只知道需要循环n-1次就行（）    &#123;        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            &#123;            \tif (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))//如果没有确定最短路或者当前路不是最短的                &#123;t = j;&#125;//把t给更新，头个节点在第一步这里变成0            &#125;想想dijkstra的步骤，每一次都是先找到所有里面最近的点        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            &#123;使用一开始寻找到的点逐个遍历所有其它可以到达的点进行比较并更新            \tdist[j] = min(dist[j], dist[t] + g[t][j]);//再次遍历一次所有        \t&#125;        st[t] = true;//将那一个点标记为已经访问并且    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;//说明1和n不联通    return dist[n];//起点到终点的距离&#125;//这里是读入的时候，注意注意要从1开始for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            int tem;            cin&gt;&gt;tem;            if(tem==0)g[i][j]=INF;            else g[i][j]=tem;        &#125;    &#125;\n\n对于该题有重边和自环，因此需要考虑一下处理\n\n多重边仅保留路径最短的那一条\n自环肯定不会被纳入最短路，可以不考虑\n\n修改（任意一个点到其它所有点）#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int INF=0x3f3f3f3f;const int N=60;int n;      // n表示点数int g[N][N];        // 邻接矩阵，存储所有边int dist[N];        // 存储其他点到当前最小生成树的距离bool st[N];     // 存储每个点是否已经在生成树中，存储已纳入的集合void dijkstra(int s)//s是源点，其它都不重要&#123;    s=s+1;    memset(dist, 0x3f3f3f3f, sizeof dist);//所有距离初始化成正无穷    dist[s] = 0;//起点到起点当然是0力    for (int i = 0; i &lt; n - 1; i ++ )//这里i不重要，只知道需要循环n-1次就行（）    &#123;        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))//如果没有确定最短路或者当前路不是最短的                t = j;//把t给更新，头个节点在第一步这里变成0        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + g[t][j]);//再次遍历一次所有        st[t] = true;    &#125;    for(int i=1;i&lt;=n;i++)//这里就是最后的输出部分    &#123;        if(i!=s&amp;&amp;dist[i]!=0x3f3f3f3f)cout&lt;&lt;dist[i]&lt;&lt;&#x27; &#x27;;        else if(i!=s&amp;&amp;dist[i]==0x3f3f3f3f)cout&lt;&lt;-1&lt;&lt;&#x27; &#x27;;    &#125;&#125;int main()&#123;    int s;//s标记源点    cin&gt;&gt;n&gt;&gt;s;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            int tem;            cin&gt;&gt;tem;            if(tem==0)g[i][j]=INF;            else g[i][j]=tem;        &#125;    &#125;    dijkstra(s);&#125;\n\n题目模板#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510, M = 100010;const int inf = 0x3f3f3f3f;int n, m;int g[N][N], dist[N];bool vis[N];int dijkstra()&#123;    memset(vis, 0, sizeof vis);    memset(dist, 0x3f, sizeof dist);        dist[1] = 0;    for(int i = 1; i &lt;= n; i ++ )    &#123;        int t = -1;        for(int j = 1; j &lt;= n; j ++ )        &#123;            if(!vis[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))            &#123;                t = j;            &#125;        &#125;                vis[t] = 1;        for(int j = 1; j &lt;= n; j ++ )        &#123;            if(dist[j] &gt; g[t][j] + dist[t])            &#123;                dist[j] = g[t][j] + dist[t];            &#125;        &#125;    &#125;    if(dist[n] * 2&gt; inf)    &#123;        return -1;    &#125;    return dist[n];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(g, 0x3f, sizeof g);    while (m -- )    &#123;        int in, out, weight;        cin &gt;&gt; in &gt;&gt; out &gt;&gt; weight;        g[in][out] = min(g[in][out], weight);    &#125;        cout &lt;&lt; dijkstra() &lt;&lt; &quot;\\n&quot;;    return 0;&#125;\n\n\n\n模板：（优化版本的Dijkstra）实际有点像广搜的\n如果是一个稀疏图，但是还要用遍历矩阵（n2复杂度）容易时间爆掉\n使用小根堆优化\n\n\n也就是可以优化第一步，可以将第一步时间变成o1，第三步就要修改成mlogn，第二步不变\n即通过堆来存储，就可以减少计算量\n堆的实现方式：\n\n手写堆（好处在于方便维护）\n优先队列（c++的stl库已经预置好了），但是不支持修改任意一个元素，解决思路：每一次改变就插入一个新的数（好处方便操作，坏处会多了操作数，时间复杂度变成mlogm，但是方便，）\n\n因此直接使用c++内置的优先队列就ok\ntypedef pair&lt;int, int&gt; PII;//存储方式从邻接矩阵转换成邻接表int n;      // 点的数量int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储所有点到1号点的距离bool st[N];     // 存储每个点的最短距离是否已确定// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;//这里的初始化和朴素版本是一样的        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;//这里使用优先队列维护所有距离，    heap.push(&#123;0, 1&#125;);      //第一次先把起点放进去，    // first存储距离，second存储节点编号    while (heap.size())//队列里面最多只有m个元素（最多只有m条边）    &#123;        auto t = heap.top();//堆的性质决定每一次都是距离最小的点        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;//说明这个点已经出来过了，不需要操作直接跳过到下一个点        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])//用这个点去更新其它所有点        &#123;            int j = e[i];//使用j来存储编号            if (dist[j] &gt; distance + w[i])            &#123;                dist[j] = distance + w[i];                heap.push(&#123;dist[j], j&#125;);//如果更新成功就把这个点放到队列里面去            &#125;        &#125;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;\n\n全部：\n有关优先队列库的函数：\n(110条消息) 【C++】优先队列详细讲解（原理+STL库调用）_半路杀出来的小黑同学的博客-CSDN博客_c++ 优先队列遍历\n#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;//堆的头文件using namespace std;typedef pair&lt;int, int&gt; PII;//堆里存储距离和节点编号const int N = 1e6 + 10;int n, m;//节点数量和边数int h[N], w[N], e[N], ne[N], idx;//邻接表存储图int dist[N];//存储距离bool st[N];//存储状态void add(int a, int b, int c)//修改了一下add函数&#123;//w存储距离    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大    dist[1] = 0;    //pair的比较，先比较第一个元素，第一个相等比较第二个。    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;//小根堆    heap.push(&#123;0, 1&#125;);//插入距离和节点编号    while (heap.size())//遍历了这个堆    &#123;        auto t = heap.top();//取距离源点最近的点，最小的        heap.pop();        int ver = t.second, distance = t.first;//ver:节点编号，distance:源点距离ver 的距离        if (st[ver]) continue;//如果距离已经确定，则跳过该点        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])//这里是链表的遍历方法            //更新ver所指向的节点距离        &#123;            int j = e[i];            if (dist[j] &gt; dist[ver] + w[i])            &#123;                dist[j] = dist[ver] + w[i];                heap.push(&#123;dist[j], j&#125;);//距离变小，则入堆            &#125;        &#125;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    memset(h, -1, sizeof h);    while (m -- )    &#123;        int a, b, c;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        add(a, b, c);    &#125;    cout &lt;&lt; dijkstra() &lt;&lt; endl;    return 0;&#125;\n\nBellman-Ford算法（bf算法）复杂度通常为o（VE）\n会多次访问同一条边\n解决问题：\n可能有负边回路，Dijkstra如果判断的图中有负会导致距离成正无穷\n部分只能使用bf解决（如果有边数限制，就只能用bf）\n\n很牛逼：可以用任意存储方式，也可以用结构体\n应用：比如坐火车不能无限坐火车\n思路：\n\n两重循环，第二次循环所有边\n\nn次迭代，更新思路有点类似dijistra\n\n\n可以判断是否存在负回路,即是可以用来找负环（如果限制了走的边的个数就可以用来找最短路）的，但时间较高，一般使用spfa寻找负环\n模板：int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重&#123;    int a, b, w;&#125;edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    &#123;        for (int j = 0; j &lt; m; j ++ )        &#123;            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;            //正常的模板是自身进行迭代对比的        &#125;    &#125;//这里注意要/2是因为如果有负边到达终点会造成距离不满足，如10^9−2，小于无穷，但仍然并不存在最短路     if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];&#125;\n\nAcWing 853. 有边数限制的最短路 - AcWing\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, M = 10010;struct Edge &#123;//使用结构体来存储所有的边    int a;    int b;    int w;&#125; e[M];//把每个边保存下来即可int dist[N];int back[N];//备份数组防止串联int n, m, k;//k代表最短路径最多包涵k条边int bellman_ford() &#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; k; i++) &#123;//k次循环        memcpy(back, dist, sizeof dist);//每一次迭代之前都要对当前数组进行备份，防止出现串联使得打破有限边数的限制        for (int j = 0; j &lt; m; j++) &#123;//遍历所有边            int a = e[j].a, b = e[j].b, w = e[j].w;            dist[b] = min(dist[b], back[a] + w);            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来        &#125;    &#125;    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    else return dist[n];&#125;int main() &#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);    for (int i = 0; i &lt; m; i++) &#123;        int a, b, w;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);        e[i] = &#123;a, b, w&#125;;    &#125;    int res = bellman_ford();    if (res == -1) puts(&quot;impossible&quot;);//说明最短路长度不存在    else cout &lt;&lt; res;    return 0;&#125;\n\nspfa(队列优化版本的Bellman-Ford)处理稀疏图，使用邻接表进行存储\n可以视为各方面都更加优秀的bf，就是对于bf进行一个优化\nAcWing 851. spfa求最短路—图解–$\\color{red}{海绵宝宝来喽}$ - AcWing\n其实正权图也可以用spfa去整\nbf缺点：每一次都要迭代所有边进行更新（每一次都要全部扫描）\n优化：使用广搜进行优化\n思路：\n\n起点放到队列里面去\n只要队列不空，就是广搜的迭代操作\n即我更新过谁，我再用谁去更新别人，我后面的人才会更小\n\n图中一定不能有负环(但是可以有负权边)，不然不能用\n时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n;      // 总点数int h[N], w[N], e[N], ne[N], idx;  // 邻接表存储所有边int dist[N];        // 存储每个点到1号点的最短距离bool st[N];     // 存储每个点是否在队列中，防止队列中存储重复点// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa()&#123;    memset(dist, 0x3f, sizeof dist);//初始化所有点的距离    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;//使用队列就是为了如起点更新过bc，则下一步仅针对bc进行更新    while (q.size())    &#123;        auto t = q.front();        q.pop();        st[t] = false;//该点不在队列里面        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])//如果可以更新            &#123;                dist[j] = dist[t] + w[i];                if (!st[j])                         // 如果队列中已存在j，则不需要将j重复插入                &#123;                    q.push(j);                    st[j] = true;                &#125;            &#125;        &#125;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;\n\n851. spfa求最短路 - AcWing题库\nspfa判断是否存在负环时间复杂度是 O(nm), n 表示点数，m 表示边数\n原理：使用dist数组表示1号数组到其它数组的距离，使用cnt表示当前最短路的边数\n模板：int n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N], cnt[N];       // dist[x]存储1号点到x的最短距离，//cnt[x]存储1到x的最短路中经过的点数//每一次更新表示bool st[N];     // 存储每个点是否在队列中// 如果存在负环，则返回true，否则返回false。bool spfa()&#123;    // 不需要初始化dist数组    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i ++ )    &#123;        q.push(i);//这里不同在于要全部入对保证每个点都能进行判断        st[i] = true;    &#125;    while (q.size())    &#123;        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i];                cnt[j] = cnt[t] + 1;//更新的时候同步更新边数                if (cnt[j] &gt;= n) return true;  // 如果从1号点到x的最短路中包含至少n个边（抽屉原理），则说明存在环 //这个环一定是个负环（因为spfa选择短的路，为了走短还多走一个点一定是存在负环）                if (!st[j])                &#123;                    q.push(j);                    st[j] = true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;\n\nFLOYID算法（Dijkstra进一步输出全部）很简单，针对所有路\n原理：动态规划\nd[k,i,j]，从i点出发，经过k个点，最终到达j点\n那么有d[k,i,j]&#x3D;d[k-1,i,k]+d[k-1,k,j]&#x2F;&#x2F;右边各经过了k-1个点\n可以优化，去掉一维，即d[i,j]&#x3D;d[i,k]&#x3D;d[k,j]\n应用：可以对有负边进行操作（但是不能有负回路）\nFLOYID可以求出所有点之间的最短路径（很暴力很牛逼很简洁很费时）\n使用邻接矩阵存储所有边\n模板时间：n^3\n//邻接矩阵初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;//自身到自身为0            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123;    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125;\n\n对于求floyid，类似spfa判断无穷情况：\n#include &lt;iostream&gt;using namespace std;const int N = 210, M = 2e+10, INF = 1e9;int n, m, k, x, y, z;int d[N][N];void floyd() &#123;    for(int k = 1; k &lt;= n; k++)        for(int i = 1; i &lt;= n; i++)            for(int j = 1; j &lt;= n; j++)                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for(int i = 1; i &lt;= n; i++)        for(int j = 1; j &lt;= n; j++)            if(i == j) d[i][j] = 0;            else d[i][j] = INF;    while(m--) &#123;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        d[x][y] = min(d[x][y], z);        //注意保存最小的边    &#125;    floyd();    while(k--) &#123;        cin &gt;&gt; x &gt;&gt; y;        if(d[x][y] &gt; INF/2) puts(&quot;impossible&quot;);        //由于有负权边存在所以约大过INF/2也很合理        else cout &lt;&lt; d[x][y] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n\nprim最小生成树非常非常像dijkstra\n处理步骤：\n\n首先全部初始化为+无穷\n开始循环迭代，用t更新到集合的距离（dijkstra这里是t更新到起点的距离）\nst[t]&#x3D;true（真的真的很像dijkstra）\n\n点到集合的距离指点到集合的所有路径中选择最短的那一条\n注意一点 ，这个二维数组要下标是1到n\n一次循环只会更新一个最近点\n每次更新最近点之后就会在该点可触及范围内更新与其它点的距离\n朴素prim模板int n;      // n表示点数int g[N][N];        // 邻接矩阵，存储所有边int dist[N];        // 存储其他点到当前最小生成树的距离bool st[N];     // 存储每个点是否已经在生成树中，存储已纳入的集合const int INF=0x3f// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim()&#123;    memset(dist, 0x3f, sizeof dist);//所有距离初始化+∞    int res = 0;//res存储所有边里面最小生成树的所有边长度之和    //每一次为了寻找到当前集合外所有点当中距离最小的点     for (int i = 0; i &lt; n; i ++ )//n次迭代    &#123;        int t = -1;        //必须要在集合外，所以从1开始，st        for (int j = 1; j &lt;= n; j ++ )            //必须在集合外并且t的距离大于当前点的距离            &#123;            \tif (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))//t==-1是最初始时候的情况                &#123;                    t = j;                &#125;        \t&#125;        //现在t存的就是当前距离最小的点        \t\t//不是第一个点并且距离是+∞        //说明当前这个图不联通，不存在最小生成树        if (i &amp;&amp; dist[t] == INF) return INF;        if (i) res += dist[t];        //否则不是第一条边就把dist加到答案中        st[t] = true;//说明这一个点已经是树集合的一份子咧        //对了注意顺序问题哦，一定要先累加再进行更新        //这一步更新一下其它点到集合的距离，同dijkstra        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);            &#125;    return res;&#125;\n\n\n\n858. Prim算法求最小生成树 - AcWing题库\nAcWing 858. Prim算法求最小生成树：图解+详细代码注释（带上了保存路径） - AcWing\nAcWing 858. $\\Huge\\color{MediumTurquoise}{prim 与dijkstra的区别}$ - AcWing\n//2022.6.1 更新#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510;int g[N][N];//存储图int dt[N];//存储各个节点到生成树的距离int st[N];//节点是否被加入到生成树中int pre[N];//节点的前去节点int n, m;//n 个节点，m 条边void prim()&#123;    memset(dt,0x3f, sizeof(dt));//初始化距离数组为一个很大的数（10亿左右）    int res= 0;    dt[1] = 0;//从 1 号节点开始生成     for(int i = 0; i &lt; n; i++)//每次循环选出一个点加入到生成树    &#123;        int t = -1;        for(int j = 1; j &lt;= n; j++)//每个节点一次判断        &#123;            if(!st[j] &amp;&amp; (t == -1 || dt[j] &lt; dt[t]))//如果没有在树中，且到树的距离最短，则选择该点                t = j;        &#125;        //2022.6.1 发现测试用例加强后，需要判断孤立点了        //如果孤立点，直返输出不能，然后退出        if(dt[t] == 0x3f3f3f3f) &#123;            cout &lt;&lt; &quot;impossible&quot;;            return;        &#125;        st[t] = 1;// 选择该点        res += dt[t];        for(int i = 1; i &lt;= n; i++)//更新生成树外的点到生成树的距离        &#123;            if(dt[i] &gt; g[t][i] &amp;&amp; !st[i])//从 t 到节点 i 的距离小于原来距离，则更新。            &#123;                dt[i] = g[t][i];//更新距离                pre[i] = t;//从 t 到 i 的距离更短，i 的前驱变为 t.            &#125;        &#125;    &#125;    cout &lt;&lt; res;&#125;void getPath()//输出各个边&#123;    for(int i = n; i &gt; 1; i--)//n 个节点，所以有 n-1 条边。    &#123;        cout &lt;&lt; i &lt;&lt;&quot; &quot; &lt;&lt; pre[i] &lt;&lt; &quot; &quot;&lt;&lt; endl;// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。    &#125;&#125;int main()&#123;    memset(g, 0x3f, sizeof(g));//各个点之间的距离初始化成很大的数    cin &gt;&gt; n &gt;&gt; m;//输入节点数和边数    while(m --)    &#123;        int a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;//输出边的两个顶点和权重        g[a][b] = g[b][a] = min(g[a][b],w);//存储权重    &#125;    prim();//求最下生成树    //getPath();//输出路径    return 0;&#125;\n\n与Dijkstra类似，Prim算法也可以用堆优化，优先队列代替堆，优化的Prim算法时间复杂度O(mlogn)。适用于稀疏图，但是稀疏图的时候求最小生成树，Kruskal 算法更加实用。\n克鲁斯卡尔最小生成树时间是mlogm，思路也简单（不用考虑prim的）\n核心：删除，判断\n优点：\n\n稀疏图尽管使用kruskal就ok\nkruskal也可以处理负权边的哦\nkruskal同bf算法，对于存储方式不挑剔，能存就行，可以用结构体\n\n\n将所有边按照权重从小到大进行排序（这里用原有的排序就行）\n枚举每条边ab（权重是c），如果ab不连通（即在），就将这条边加入到集合里面\n只要边数是节点数-1就ok辽\n\n这里建议参考并查集例题，837题\n837. 连通块中点的数量 - AcWing题库\nkruskal是使用一个并查集去维护的，堆用于去做dijkstra\nAcWing 859. Kruskal算法求最小生成树—$\\color{red}{海绵宝宝来喽}$ - AcWing\n模板#include&lt;algorithm&gt;//需要引入这个头文件实现对结构体的大小排序操作int n, m;       // n是点数，m是边数int p[N];       // 并查集的父节点数组struct Edge     // 存储边&#123;    int a, b, w;    //下面这里是结构体的另一个函数，重载一下＜    bool operator&lt; (const Edge &amp;W)const    &#123;        return w &lt; W.w;    &#125;&#125;edges[M];//这里是开了一个结构体数组叫edges,有M个int find(int x)     // 并查集核心操作&#123;    if (p[x] != x) p[x] = find(p[x]);    return p[x];&#125;int kruskal()&#123;    sort(edges, edges + m);//nlogn    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集    //res存最小生成树里边所有边的权重之和    //cnt存的是当前增加了多少条边    int res = 0, cnt = 0;    //这里是从小到大枚举所有边    for (int i = 0; i &lt; m; i ++ )    &#123;        int a = edges[i].a, b = edges[i].b, w = edges[i].w;        a = find(a), b = find(b);        //使用一个并查集来判断两个点是否联通           // 如果两个连通块不连通，则将这两个连通块合并         if (a != b)         &#123;            p[a] = b;//这里是两个点的合并操作            res += w;            cnt ++ ;        &#125;    &#125;    if (cnt &lt; n - 1) return INF;    return res;&#125;\n\n题：\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int p[N];//保存并查集struct E&#123;    int a;    int b;    int w;    bool operator &lt; (const E&amp; rhs)&#123;//通过边长进行排序        return this-&gt;w &lt; rhs.w;    &#125;&#125;edg[N * 2];int res = 0;int n, m;int cnt = 0;int find(int a)&#123;//并查集找祖宗    if(p[a] != a) p[a] = find(p[a]);    return p[a];&#125;void klskr()&#123;    for(int i = 1; i &lt;= m; i++)//依次尝试加入每条边   &#123;        int pa = find(edg[i].a)；// a 点所在的集合        int pb = find(edg[i].b);// b 点所在的集合        if(pa != pb)&#123;//如果 a b 不在一个集合中            res += edg[i].w;//a b 之间这条边要            p[pa] = pb;// 合并a b            cnt ++; // 保留的边数量+1        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;//同样注意这里是1开始，因此下面sort函数起始也是+1    for(int i = 1; i &lt;= n; i++) p[i] = i;//初始化并查集    for(int i = 1; i &lt;= m; i++)&#123;//读入每条边        int a, b , c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;        edg[i] = &#123;a, b, c&#125;;    &#125;    sort(edg + 1, edg + m + 1);//按边长排序    klskr();//并查集初始化包含在函数中    if(cnt &lt; n - 1) &#123;//如果保留的边小于点数-1，则不能连通        cout&lt;&lt; &quot;impossible&quot;;        return 0;    &#125;    cout &lt;&lt; res;    return 0;&#125;\n\n二分图染色法判定：使用性质：一个图是二分图当且仅当图中不含奇数环&#x2F;奇圈\n奇数环：环，而且当中边的数量是奇数\n时间复杂度是 O(n+m), n 表示点数，m 表示边数\n思路：一条边的两个端点一定属于不同的集合，一个联通块中只要一个点的颜色确定，其它点的颜色都确定（白色只能与黑色相邻，黑色只能与白色相邻），由于不存在奇数环，染色过程中一定没有矛盾\n因此需要将整个图遍历一遍，由于图没有权，负边，因此可以用dfs，bfs来弄，模板这里使用dfs\n因此，如果有矛盾，那肯定就不是了呗\n则判定两个关键函数：\n\ndfs\n判定是否出现矛盾\n\nint n;      // n表示点数int h[N], e[M], ne[M], idx;     // 邻接表存储图int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色//三色染色法，考虑go语言runtime部分三色标定部分// 参数：u表示当前节点，c表示当前点的颜色//这里使用深搜因为相对而言深搜的代码量更少，只用回溯，不需要手写队列bool dfs(int u, int c)&#123;    color[u] = c;    for (int i = h[u]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (color[j] == -1)        &#123;            if (!dfs(j, !c)) return false;        &#125;        else if (color[j] == c) return false;    &#125;    return true;&#125;bool check()&#123;    memset(color, -1, sizeof color);    bool flag = true;    for (int i = 1; i &lt;= n; i ++ )        if (color[i] == -1)            if (!dfs(i, 0))            &#123;                flag = false;                break;            &#125;    return flag;&#125;\n\n随便整一道例题康康：\nAcWing 860. 染色法判定二分图—$\\color{green}{详细代码注释+图解}$ - AcWing\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010 * 2;int e[N], ne[N], idx;//邻接表存储图int h[N];int color[N];//保存各个点的颜色，0 未染色，1 是红色，2 是黑色int n, m;//点和边void add(int a, int b)//邻接表插入点和边&#123;    e[idx] = b, ne[idx]= h[a], h[a] = idx++;&#125;bool dfs(int u, int c)//深度优先遍历&#123;    color[u] = c;//u的点成 c 染色    //遍历和 u 相邻的点    for(int i = h[u]; i!= -1; i = ne[i])    &#123;        int b = e[i];                           if(!color[b])//相邻的点没有颜色,则递归处理这个相邻点        &#123;            if(!dfs(b, 3 - c)) return false;//（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）                                            //（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）        &#125;        else if(color[b] &amp;&amp; color[b] != 3 - c)//如果已经染色，判断颜色是否为 3 - c        &#123;                                                 return false;//如果不是，说明冲突，返回                           &#125;    &#125;    return true;&#125;int main()&#123;    memset(h, -1, sizeof h);//初始化邻接表    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= m; i++)//读入边    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        add(a, b), add(b, a);    &#125;    for(int i = 1; i &lt;= n; i++)//遍历点    &#123;        if(!color[i])//如果没染色        &#123;            if(!dfs(i, 1))//染色该点，并递归处理和它相邻的点            &#123;                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;//出现矛盾，输出NO                 return 0;            &#125;        &#125;    &#125;    cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;//全部染色完成，没有矛盾，输出YES    return 0;&#125;\n\n匈牙利算法作用：给定一个二分图，求它的最大匹配（可以在一个较短的时间内匹配）\n把它想象成月老匹配对象算法\n\n\n一些概念：\n\n二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E}中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。\n二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数\n\n基本思路：\n\n对于每个男生从前往后看（果然开始当月老看了），如果女生处于单身状态则可以匹配\n再看下一个，某个男生匹配某个女生，如果该女生已经被匹配，这个男生也不会善罢甘休（什么黄毛剧情），如果之前匹配的男生a可以更换女生（越来越奇怪了），男生b会与这个女生匹配（他甚至专门用了绿色绝了）\n\n所以很多时候做错是没事的，错过是真的会后悔\n\n\n时间复杂度（n*m）（最坏情况），实际上时间是会很少的\n注意：如果对左边进行遍历，那么边就要存储左边指向右边的\n模板：int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过bool find(int x)//判断能否找到妹子&#123;//使用枚举    for (int i = h[x]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (!st[j])//如果妹子之前没有考虑过        &#123;            st[j] = true;                        //如果妹子之前没有匹配任何男生或者女生匹配的男生可以找到下家            if (match[j] == 0 || find(match[j]))            &#123;                match[j] = x;//当前妹子匹配就改变了                return true;            &#125;        &#125;    &#125;    return false;//就是在匹配不上，那咱就算了&#125;// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点//这里是main函数里面的部分int res = 0;for (int i = 1; i &lt;= n1; i ++ )&#123;    memset(st, false, sizeof st);//先把所有的妹子清空    if (find(i)) res ++ ;//如果可以找到的话，成功数量增加&#125;\n\nAcWing 861. 二分图的最大匹配 - AcWing\nAcWing 861. 二分图最大匹配 - 如果你看了别的题解，仍然对递归写法的st数组心存疑虑，看看这里【21.12.7更新】 - AcWing\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510 , M = 100010;int n1,n2,m;int h[N],ne[M],e[M],idx;bool st[N];int match[N];void add(int a , int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void init()&#123;    memset(h,-1,sizeof h);&#125;int find(int x)&#123;    //遍历自己喜欢的女孩    for(int i = h[x] ; i != -1 ;i = ne[i])    &#123;        int j = e[i];        if(!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定        &#123;            st[j] = true;//那x就预定这个女孩了            //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功            if(!match[j]||find(match[j]))            &#123;                match[j] = x;                return true;            &#125;        &#125;    &#125;    //自己中意的全部都被预定了。配对失败。    return false;&#125;int main()&#123;    init();    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;    while(m--)    &#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        add(a,b);    &#125;    int res = 0;    for(int i = 1; i &lt;= n1 ;i ++)    &#123;           //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化          memset(st,false,sizeof st);        if(find(i))           res++;    &#125;      cout&lt;&lt;res&lt;&lt;endl;&#125;\n\n\n\n关键路径（AOE网，拓扑plus版本）基础背景知识：AOE网：AOV网基础上加上每个节点（工序）所消耗的时间\nAOE网要建立再活动之间制约关系没有矛盾的基础之上，再来分析完成整个工程需要多少时间，或者为了缩短完成工程所需时间，应当加快哪些活动\n关键路径：从源点到汇点具有最大长度的路径：\n关键活动：关键路径上的活动（实际上就可以理解成多种活动并行执行，有些耗时最长的活动来衡量整体工程的执行时间）-&gt;修改关键活动才会对整个工期长度进行实际减少\n核心：寻找关键活动方法：找到所有活动的最早开始时间和最晚开始时间，并且进行比较，如果相等意味着此活动是关键活动，活动间的路径是关键路径\n贪心与最短路关系：dp问题可以视为特殊的最短路问题，即最短路包含dp，是一个没有环存在的最短路，dp实际是深搜，保证可以到达终点，但不保证是最短路\n暴力搜索回溯法回溯法效率：低，但比for强\n解决问题：for嵌套无法解决时候理论基础：来源于递归的回溯(隐藏在递归的下面)，与二叉树遍历，深度优先搜索混在一起进行，二叉树在返回的过程中也用到了回溯\n可解决问题：传统for暴力搜索方式无法解决\n\n组合问题：（如一串数字询问可以组合的方式数）组合强调没有顺序\n排列问题：排列强调元素顺序\n切割问题：（字符串，加上某种限定条件，询问切割方式）\n子集问题：找出所有子集\n棋盘问题：（典中典皇后，数独)\n\n小总结，用于解决组合和排列\nADT:可以抽象为一个树形结构，可以抽象为一棵n叉树，树的宽度是集合的大小，即每个节点处理的集合的大小-&gt;这里通常使用for循环来处理。树的深度（纵方向）也就是递归的深度，\n回溯模板void backtracking(参数) &#123;    if (终止条件) &#123;//终止条件        存放结果;//一般问题都是在叶子节点收集结果（最后一个节点）        \t\t//而子集问题每一个节点都要收集结果        return;//收集完结果之后返回    &#125;    for (选择：本层集合中元素（树中节点的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归，这里是深度，向下探索        回溯，        撤销处理结果//结束循环    &#125;&#125;\n\n棋盘典中点：皇后位置c++直接完整版本代码：（LeetCode 版本）\nclass Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;// n 为输入的棋盘大小// row 是当前递归到棋牌的第几行了void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;    if (row == n) &#123;//回溯到最后一行，说明满足情况了        result.push_back(chessboard);        return;    &#125;    for (int col = 0; col &lt; n; col++) &#123;        if (isValid(row, col, chessboard, n)) &#123; // 验证合法就可以放            chessboard[row][col] = &#x27;Q&#x27;; // 放置皇后            backtracking(n, row + 1, chessboard);//再进一行进行检验            chessboard[row][col] = &#x27;.&#x27;; // 回溯，撤销皇后        &#125;    &#125;&#125;bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    int count = 0;    // 检查列    for (int i = 0; i &lt; row; i++) &#123; // 这是一个剪枝        if (chessboard[i][col] == &#x27;Q&#x27;) &#123;            return false;        &#125;    &#125;    // 检查 45度角是否有皇后    for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) &#123;//另一个剪支        if (chessboard[i][j] == &#x27;Q&#x27;) &#123;            return false;        &#125;    &#125;    // 检查 135度角是否有皇后    for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] == &#x27;Q&#x27;) &#123;            return false;        &#125;    &#125;    return true;&#125;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        result.clear();        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#x27;.&#x27;));        backtracking(n, 0, chessboard);//注意这里是从0开始的，所以最后到n，实际上以及对n层进行了判断        return result;    &#125;&#125;;/*总结操作流程：类似二叉树，对每个节点进行遍历，实际复杂度是n^2，从开头一直向下延申，可满足情况进行返回\n\nc++数组版本皇后问题:老子自己写的！（双手叉腰）\n#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int maxn=9;int solu[maxn]=&#123;0&#125;;int qn[maxn]=&#123;0&#125;;bool isValid(int posj,int posi)//最后那个pos也就是棋子的坐标&#123;    //posi=i,posj=qn[i]    if(posi==0)return true;    for(int i=0;i&lt;posi;i++)    &#123;        if(qn[i]==posj)return false;//相同的列判断    &#125;    for(int i=posi-1;i&gt;=0;i--)//45判断    &#123;        if(posi-i==posj-qn[i])return false;    &#125;    for(int i=posi-1;i&gt;=0;i--)//135    &#123;        if(posi-i==qn[i]-posj)return false;    &#125;    return true;&#125;void backtracing(int n,int row)&#123;    if(row==n)&#123;//终止了，找到了其中一种解决方案        cout&lt;&lt;&quot;bottom reached\\n&quot;;        cout&lt;&lt;&quot;solution:\\n&quot;;        for(int  i=0;i&lt;n;i++)        &#123;            cout&lt;&lt;&quot;row &quot;&lt;&lt;i+1&lt;&lt;&quot; equals to &quot;&lt;&lt;qn[i]+1&lt;&lt;&quot; \\n&quot;;        &#125;        cout&lt;&lt;&quot;go find other solution\\n\\n&quot;;        return;    &#125;    else&#123;        for(int i=0;i&lt;n;i++)//注意这里的传参        &#123;            qn[row]=i;//row，行固定，列用变量i对每一行进行遍历，如果满足之前条件进入下一行            if(isValid(qn[row],row))//该行该位置能否放            &#123;                backtracing(n,row+1);//可以就继续往下走            &#125;        &#125;    &#125;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    backtracing(n,0);&#125;\n\n图形化数据结构学习：栈：非递归汉诺塔难点：不能使用递归（如果使用递归在画图之前会全部更新完，最后只会给出结果），改成非递归方式\n本质：将递归结构在循环中实现\n老师解法：\n参考博客：(99条消息) 汉诺塔的非递归实现（堆栈）_.别拖至春天.的博客-CSDN博客_汉诺塔的非递归实现\n![屏幕截图 2022-10-12 155526](D:\\typora note\\屏幕截图 2022-10-12 155526.png)\n代码以及注释：\nops是空栈，用于保存指令，并且在n&#x3D;&#x3D;1的时候才进行弹出操作\nif(!ops.empty()) &#123;                //                op current = ops.top();//非空赋值                ops.pop();//                if(current.n == 1) &#123;//每一个待处理的物品数量变成1的时候进行弹栈，一直弹到不是1                    //                    // 这里的current.start等等已经改变成对应的代号了                    //                    int d = stacks[current.start]-&gt;top();                    stacks[current.start]-&gt;pop();                    stacks[current.end]-&gt;push(d);                &#125; else &#123;                    //这里应该就是正常非递归                    //如果不是1，进行分解,                    //如要做到(n,a,b,c),n个从a到c                    //分解，并且按照顺序进栈（当然弹出的时候就是相反的顺序）                    //1:(n-1,a,c,b)                    //2:(1,a,b,c)                    //3:(n-1,b,a,c)                    //因为程序执行语言是从上到下，但是指令压栈应该是321，因此最后是321                    //ops是一个存储指令的栈                    ops.push(op(current.n - 1, current.via, current.start, current.end));//3                    ops.push(op(1, current.start, current.via, current.end));//2                    ops.push(op(current.n - 1, current.start, current.end, current.via));//1                &#125;            &#125;\n\n南大关于非递归的应用（对于C语言作为状态机的分析讲解）\n\n\n队列：迷宫生成及解决重点解决问题：回溯法\n顺便要学习的算法：迪杰斯特拉解法（可以等一等再看看）\n","tags":["学习笔记"]},{"title":"爬山，云浮，天露，水源","url":"/2023/04/18/%E7%88%AC%E5%B1%B1%EF%BC%8C%E4%BA%91%E6%B5%AE%EF%BC%8C%E5%A4%A9%E9%9C%B2%EF%BC%8C%E6%B0%B4%E6%BA%90/","content":"爬山，云浮，天露，水源\n1200m海拔，20km路程\n两天重装，15+kg的登山包往背上一抗就开始走\n周五晚上到达村子里的一个位置扎营，第二天早起获得成就：小孩的羡慕眼神（指对身上的装备，有一说一，确实那个包很吸引眼球）\n周六早上，醒来，开爬。初始只是沿着公路上山，加上早餐吃得比较好（热燕麦片粥），一开始体力还挺富裕的。对于气温把握不太行，一早上醒来的时候感觉非常冷，于是衣服基本都穿上了，真正开始爬坡之后很快就一头汗，再把外套换下来（就是折腾）。\n进入山路，中间遇到一些大叔大妈，可能也是来爬山的（或者是干活，有些人好像挑着担子），体力也很好。中间野猪🐗也在跟他们寒暄聊天（虽然一句都听不懂就是了）。爬山过半时候开始下雨，从一开始觉得不会下的多大继续向上到之后逐渐转换为暴雨，本来山路就有点难爬，变得更加滑了（尤其是中间可能会有的半腐烂的树叶堆积在一起🍃，看起来好像可以落脚实际上一踩就是打滑），爬到天露山顶的时候，暴雨和风，吹的手和脸生疼，特别冷，感觉身上的热量在不断被带走，在南方居然有一种手快被冻僵的感觉，好神奇\n但是结果值得。\n站在山顶，向四周瞭望，看云起云舒，流转翻腾\n山体连绵蜿蜒，不同与上山时候的崎岖，山顶的路相对舒缓，覆盖一层绿草，\n山顶就像是一个荷包蛋中间的黄，周围是环绕飘渺的蛋白（云层）（啊奇奇怪怪的联想又增加了）\n突然好像就了解了为什么去的地方要叫“云浮”了，很有意思的名字\n另一部分是山上的杜鹃花海（不过可能杜鹃花没有到达最佳的观望时间，没有像对马岛中那种一望无际的红色花海的感觉，这一点其实还蛮可惜的）\n中午，在山顶继续向前，前往风车山。可能是到达山顶了，走路就相对舒服很多，爬坡和下坡的坡度相对没有那么大，一路上下坡也算是带一点点休息，比较可惜的是一根登山杖下坡的时候摔了一下拿它来支撑，结果三节中的第一节折了（先祝登山杖在登山杖heaven可以舒服一些），不过剩余的部分还可以继续服役，这一点还好\n下午的爬坡算是非常麻的地方了，最后到达露营点的一段路全是公路，结果反而是最艰难的。看着好像很平（虽然平但没有完全平，怎么也得有几度？？），\n主要是早上爬坡并且下雨的时候，大概是带走的热量太多了，中午虽然还是有路餐，不过还是感觉不太够，到了下午四点多的时候（而且没有睡午觉，也许是这一点，本午觉成瘾人还是有点顶不住）全员（或者说后半部分的队员）都有一些体力不支，后半途虽然已经到公路上了但是感觉还是挺累的，（也可能是走公路的时候没有一些可以吸引人注意力的部分，容易放松下来，然后就没体力了）\n到达风车，全体人员瘫痪，葛优瘫痪，\n这里感激葱花作为收尾的部分没有push得太狠，可以在后面舒舒服服没事摸鱼没事摸鱼\n这时候手动进行@香菜！！！！！！！！！🤺🤺🤺🤺、🌿\n什么叫脱缰的野香菜啊，啊？&#x2F;？？？？？？？？？？？？？？？？？？？？？？？？\n什么玩意啊？跑那么快，撵都撵不上\n我的好家伙，根本顶不住，根本不休息就是向上冲，楞冲，摁冲，可劲冲\n怀疑有人内嵌一个核能电池啊啊啊啊啊啊啊啊啊，怎么就根本不休息的。\n然后最后到达的时候红娘都说到的太早了（乐）\n晚上吃火锅，不出意外的，进行一番抢饭的大战\n挺庆幸自己属于能吃辣但是不是特别能吃辣（乐），可以两种锅都吃，因此在抢食活动中占据有利因素\n周日\n没有预想中的日出，相反是阴天和雾\n六点多的时候其实还好，随着时间越来越浓\n等到七点多的时候雾已经接近把整个露营点围住，能见度大概在十米多？上个坡然后就看不见啥了。本来在一个风车底部扎营，最后连风车都整个被遮住，只有呜呜的转动声音表明它还在转动\n这个大雾有一种寂静岭的美，总感觉会有防空警报响起来（乐）\n又有点像楚门的世界里面楚门最后到达虚假的世界的边境，是大雾，也是外面的世界，又想起楚门的那段经典台词\n\nGood morning, and in case I don’t see you, good afternoon, good evening, and good night!\n\n下坡很有意思，有一种彼得帕克的美🕷️\n手脚并用+各种小操作使用登山杖，对于使杖愈发熟练（将腿的强度上到胳膊上）\n非常让人震惊的是红娘把萧拿来当登山杖使（一边感叹萧的强度一边为我们在爬他还能没事吹俩段感觉非常震惊，非常非常非常震惊）\n一路上彼得帕克下来（或者感觉自己是在彼得帕克），最后还见到了一座位于山中的庙\n挺有意思的布局，依附着巍峨的山川岩壁，在两块大石头的夹角中\n拜一拜🙏，希望万能的god&amp;卡密撒嘛&amp;神保佑一下，让我不要看代码看不懂，看书概念理解快那么亿丢丢，最好最好最好实现以下财务自由，拜托了（恭敬）（鞠躬）（上上香）\n之后还见到了竹林\n总在想会不会有俩位武林高手在里面决斗（问就是武侠电影看多了）\n中途有见过一些小竹笋，（不同于之前在视频中见到的竹笋白白胖胖，看到的这个竹笋偏向尖锐，长度确实细长，但是不粗，就像是一根倒过来的特大号钉子），尝试过去拔竹笋结果扎了一手的刺（有点小疼说实话），（但是旺财跟大嫂就那么很轻松地拔起来了，很惊讶）\n之后还看到傻白跟毛怪泡脚（好家伙，思路打开了），发现确实走得慢了，感觉自己体力还是提升空间很大（高情商），也就是体力太拉了（低情商）\n\n\n关于大嫂和黑虎（阿福）（（没有揍扁成龙））\n\n寻宝大师的感觉，一路上遇见很多的树莓和野果，都被精准拿捏（树莓的味道类似桑葚，但是感觉偏酸，颜色深的树莓尝起来还是很甜的，很像桑葚）\n以及最后碰到蚂蝗，小麻。本身感觉自个已经裹得够严实了，没想到脚腕还是中招了。还好问题不算太大。之后学乖了一定要穿高脚袜同时把绑腿打好，小心爬上\n还好还好蚂蝗没有吸附到其它部位，当时没事坐下来撩起裤腿摸到一个不对劲的东西真的是当时浑身就是一震然后就是一拔一甩，手法熟练娴熟不一定，心跳骤停是有的\n\n三十（XXX）\n\n总感觉这个名字像是来自某个金庸的小说（可能是十三？印象中类似的这种带数字的名字都是在武侠小说中，比如琅琊榜中的白七娘？（名字不确定正确））\n感激三十的零食🙏\n\n毒菇🍄\n\n感谢帮忙消毒，处理以下创口\n周六下午在风车山走的时候中间有以为脱节了，在我们摸鱼组和香菜冲锋组之间，但是最后和香菜碰头的时候没有找到，当时还有点慌，还好最后找到了\n感觉爬坡体力也很好\n\n🐧企鹅\n\n隐藏的粤语歌大佬\n爬山的时候相对沉默一些，现在看来，大概是在养嗓子，准备晚上惊艳一下子别人（他确实做到了，至少对我而言真的挺惊艳的）\n\n野猪🐗\n\n体力真的好，也是蹿的很快\n爬山的时候轻松与当地人交流，使用某种听不懂但是感觉很神奇的语言\n照片拍得很好看\n\n鲍鱼（没有适当表情很可惜）\n\n以一己之力拉高全体成员的物理价位，抢饭的时候感觉过于文明礼让\n\n学到很多奇奇怪怪的有用的知识\n包括阴天的时候其实也有紫外线而且紫外线挺强烈的（尤其如果是海拔高的话）（（下次还是得防晒做好））\n","tags":["出游记录"]},{"title":"数据结构与算法 PART 1","url":"/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"数据结构与算法：PART1\n算法时间分析：https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF\n理解idx:我感觉idx相当于一个分配器，如果需要加入新的结点就用++idx分配出一个下标（最主要可以做到不重复地重新分配下标）\nAcWing 835. 如何理解单(双)链表，Trie树和堆中的idx？ - AcWing\n\n所有数据结构 学习的同时一定要理解该种数据结构的使用范围，干什么的&#x2F;\n科班学习顺序：（如何逐步提高写程序的性能）基础程序设计-&gt;数据结构与算法-&gt;操作系统-&gt;编译器的优化（编译原理）\n提高程序性能办法：好的算法：正确性，可读性，健壮性，效率\n程序运行时间因素\n所用算法\n问题的规模\n书写程序所用语言-&gt;级别越高效率越低\n编译程序所用的机器(mac比windows快)\n机器执行所用的速度（涉及到硬件，比如老电脑和新电脑）\n\n算法时间度量：为了完成某一问题机器所做的操作执行次数\n统计方法：写代码前&#x2F;写代码后\nint i, sum=0, n=100;//执行1次for(i=1;i&lt;=n;i++)//执行n+1次&#123;sum+=i;//执行n次&#125;cout&lt;&lt;sum;//执行n次\n\n\n\n冯诺依曼架构I&#x2F;O&lt;-&gt;中央存储单元&lt;-&gt;\nCPU:解析指令\n内存：存储指令和数据\n程序大小相对不重要，执行操作与数据重要\n空间复杂度：通过计算算法所创建的空间大小。\n基础算法位运算求n的第k位数字: n &gt;&gt; k &amp; 1返回n的最后一位1：lowbit(n) = n &amp; -n\n\n\n\n快排——》重要，面试常用型😍快排本质就是使用分治思想，递归实现\n最快onlogn，最慢oN2\n步骤：\n\n确定分界点\n调整范围（最麻烦部分）\n对左右两边进行操作\n\n模板：void quick_sort(int q[], int l, int r)//记住开头不变，最后右边是j+1&#123;    if (l &gt;= r) return;//左右指针相遇时候返回    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];//这里x暂时设定为左右边界的中间值，原因在于后边是do while指令，因此提前ij各往外移动一个位置     //第一步：分成子问题    while (i &lt; j)    &#123;//注意这个顺序一定不能错        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        //容易错的点：要在这里打一个if        if (i &lt; j) swap(q[i], q[j]);//swap函数自己补充，这里ij可以相等    &#125;//这样操作过一轮之后x左边都是比它小的，右边都是比它大的    //第二步：递归处理子问题                quick_sort(q, l, j), quick_sort(q, j + 1, r);//这里一定一定是j，i会出问题                //这里两步的顺序一定一定记住，不然可能无限划分    //接着对它左右两端进行同样一次的操作，递归到最后就是全部完成排序    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤&#125;\n\n使用说明：\n如原本为a[10]，数据为a[0]-a[9];则排序为    quick_sort(a, 0, 9);//注意这里很容易错误弄范围\n\n\n\n快排合理性分析：AcWing 785. 快速排序算法的证明与边界分析 - AcWing由于使用do-while循环,所以i和j一定会!!!自增!!!,使得循环会继续下去,但是如果采用while循环(i和j的初始化做出对应的变更),i和j在特殊情况下不自增的话,循环就会卡死\n边界问题：\n快排属于分治算法，最怕的就是 n分成0和n，或 n分成n和0,这会造成无限划分\nwhile(q[i] &lt; x) i++;  while(q[j] &gt; x) j--;当q[i]和q[j]都为 x 时, i 和 j 都不会更新,导致 while 陷入死循环\n\n单向移动版本快排（实际使用快慢指针）int partition(int arr[], int low, int high) &#123;\tint pivot = arr[low]; // 待比较的基准元素\tint i = low;\tfor (int j = low + 1; j &lt;= high; j++)     &#123; if (arr[j] &lt; pivot)     \t&#123; i++; \t\t//最终i停留的位置是要交换的位置     \t\tswap(arr[i], arr[j]);\t\t&#125;\t&#125; \tswap(arr[i], arr[low]); \treturn i;&#125;void quickSort(int arr[], int low, int high) &#123;    if (low &lt; high) &#123;     \tint pi = partition(arr, low, high);\t\tquickSort(arr, low, pi - 1); \t\tquickSort(arr, pi + 1, high);\t\t&#125;&#125;/*这种排序实际上将数组分成了三个部分：比pivot小，pivot，比pivot大，因此分治部分只需要对于pi-1和pi+1进行操作就行*/\n\n运行逻辑：指针j运行快，i运行慢，j只会在遇到比基准元素大的时候跳过\n正常流程：如果j指向的都是比pivot小的元素，ji同步运动，指针一直向右走\n\n如果j右边是比pivot大的元素，即i右边紧挨着就是更大的元素，j跳过，i停留不移动\n\n然后让i++，刚好就到了大的元素，进行交换\n结束情况：j遍历完成，i最后右移一次，停止\n\n接着就是分治了\n插入排序void insertionSort(int arr[], int n) &#123;int i, key, j;     for (i = 1; i &lt; n; i++)     &#123;\t\tkey = arr[i];        j = i - 1;// 如果大于key需要向后移动一位\t\twhile (j &gt;= 0 &amp;&amp; arr[j] &gt; key)        &#123;//直接插入是一直插入到对比结束\t\t\tarr[j + 1] = arr[j]; j = j - 1;\t\t&#125;         arr[j + 1] = key;&#125;&#125;\n\n\n\nplus:折半插入排序（插入+二分）——》稳定又好使代码：int binarySearch(int a[], int item, int low, int high) &#123;     if (high &lt;= low) &#123; return (item &gt; a[low]) ? (low + 1) : low;&#125;  \tint mid = (low + high) / 2;     if (item == a[mid]) &#123; return mid + 1;&#125;    if (item &gt; a[mid]) &#123; return binarySearch(a, item, mid + 1, high);&#125;\treturn binarySearch(a, item, low, mid - 1);&#125;//二分搜索部分//注意二分一定有解，但是答案不一定有解void insertionSort(int a[], int n) &#123;    int i, loc, j, k, selected;     for (i = 1; i &lt; n; ++i)     &#123;         j = i - 1;\t\tselected = a[i];\t\t// 寻找应该插入的位置\t\tloc = binarySearch(a, selected, 0, j);        //这里直接找到，后面的while循环就不需要再考虑对比，直接上就行\t\t// 移动后面所有的数据        while (j &gt;= loc)         &#123;             a[j + 1] = a[j];         \tj--;        &#125;        a[j + 1] = selected;\t&#125;&#125;\n\n\n\n希尔排序模板int shellSort(int arr[], int n) &#123;// 从大gap开始，逐步减少gapfor (int gap = n / 2; gap &gt; 0; gap /= 2) \t&#123;     \tfor (int i = gap; i &lt; n; i += 1) \t\t&#123;// i 是直接插入排序算法中待插入的元素int temp = arr[i];// 向前查找，并同时移位\t\t\tint j;\t\t\tfor (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) \t\t\t&#123;     \t\t\tarr[j] = arr[j - gap];\t\t\t&#125;// 把i元素放入合适的位置\t\t\tarr[j] = temp;\t\t&#125;\t&#125;     return 0;&#125;\n\n归并排序（另一个重要排序，也背下来）😃不太好的点：归并排容易爆内存\n模板：void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;//最后拆分成单元素的时候就返回    int mid = l + r &gt;&gt; 1;//二分        merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);//以上先疯狂二分，将整个数组全部拆分成最小部分，然后下面部分开始递归合并    int k = 0, i = l, j = mid + 1;   \t分别作用：        k用于tmp数组，因此从0开始        i从最左，j从中间开始向右            while (i &lt;= mid &amp;&amp; j &lt;= r)//这里由于递归，每一个小数组都归并好了，归并最后的大数组        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//归并，结果合并到tmp，        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//赋值剩下的i    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//赋值剩下的j    for (i = l, k = 0; i &lt;= r; i ++, k ++ ) q[i] = tmp[k];    k代表临时数组的值              //赋值回去，使得q同步变得有序，用于小数组递归回去用    //憋想着省去这一步，不然小数组无法被弄成有序，最后归并会失败&#125;\n\n使用举例：\n几个注意点：\n\ntmp一开始就声明（不然爆内存）\nmerge里面j&#x3D;mid+1（这里弄错之后排序都不对劲）\nmerge函数中i与j的范围记得别被错\n\n#include&lt;iostream&gt;using namespace std;const int N=1e5+10;int array[N];int tmp[N];void merge(int l,int r)&#123;    int mid=(l+r)/2;    int k=0,i=l,j=mid+1;//j的赋值容易不对劲    while(i&lt;=mid&amp;&amp;j&lt;=r)    &#123;        if(array[i]&lt;=array[j])tmp[k++]=array[i++];//这里判断的时候还是加‘=’        else tmp[k++]=array[j++];    &#125;    while(i&lt;=mid)&#123;tmp[k++]=array[i++];&#125;    while(j&lt;=r)&#123;tmp[k++]=array[j++];&#125;    for(i=l,j=0;i&lt;=r;i++,j++)//这里的范围也容易搞混    &#123;//注意归并排序中所有都是&lt;=        array[i]=tmp[j];    &#125;&#125;void mergesort(int l,int r)&#123;    if(l&gt;=r)return;    int i=l-1;    int j=r+1;    int mid=(i+j)/2;//这里有一个特别狠的二分        mergesort(l,mid);    mergesort(mid+1,r);//这里需要+1    merge(l,r);&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;array[i];    &#125;    mergesort(0,n-1);    for(int i=0;i&lt;n;i++)    &#123;        cout&lt;&lt;array[i]&lt;&lt;&#x27; &#x27;;    &#125;    return 0;&#125;\n\n有趣应用：逆序对788. 逆序对的数量 - AcWing题库\ntimsort（优化后归并）这个就看苏老师的ppt课件\n(105条消息) Timsort——自适应、稳定、高效排序算法_码到sucess的博客-CSDN博客_timsort\n核心：提取降序数组升级为升序数组本质都是部分有序的,\n\n因此第一步：将所有部分降序数组全部翻转（这里直接逆序就好）\n这一步模板：\nvoid reverse(int q[],int l,int r)&#123;    for(int i=l,j=r;i&lt;=j;i++,j--)swap(q[i],q[j]);&#125;void array_reverse(int q[],int N)&#123;    if(N==1&amp;&amp;N==0)return;    int i=1,l=0,tmp=0,stage_judge;    if(q[0]&lt;=q[1])stage_judge=1;//升序标记    else  stage_judge=0;    while(i&lt;N)    &#123;        if(q[i]&gt;q[i+1])        &#123;            if(stage_judge==1)stage_judge=0;            ++i;        &#125;        else if(q[i]&lt;=q[i+1])        &#123;            if(stage_judge==0)            &#123;                if(tmp!=l-1)++l;                reverse(q,l,i);                tmp=i;                stage_judge=1;            &#125;            ++i;//前进一个            l=i;//l=前进一位之后的i        &#125;    &#125;&#125;\n\n\n\n核心：栈处理归并先将所有已知的升序排列的压入总栈，\n这一步：\nvoid stack_check(int N)//对栈进行检验,并且要的是归并两个连续短区间&#123;    int stack_pos1,stack_pos2,stack_pos3;    int stack_length1,stack_length2,stack_length3;//1最顶，3最底层    pop(stack_pos1,stack_length1);    pop(stack_pos2,stack_length2);    pop(stack_pos3,stack_length3);    if(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)//x&gt;y或者x+y&gt;z    &#123;        if(stack_length1&gt;stack_length3)        &#123;                push(stack_pos1,stack_length1);                merge(stack_pos3, stack_length3,stack_pos2, stack_length2 );//对yz进行归并        &#125;            else        &#123;                    push(stack_pos3,stack_length3);                    merge(stack_pos2,stack_length2,stack_pos1,stack_length1);//对xy进行归并        &#125;           // cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;        for(int i=0;i&lt;N;i++)        &#123;            cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;        if(stack_idx&gt;=2)stack_check(N);//递归检测    &#125;    else//按照原先顺序再压进去    &#123;        push(stack_pos3,stack_length3);        push(stack_pos2,stack_length2);        push(stack_pos1,stack_length1);        cout&lt;&lt;endl&lt;&lt;endl;    &#125;    return;&#125;\n\n\n\n核心：最小分区长度在排序之前预先计算➢ 归并过程低效的主要原因是大分区和小分区合并\nwhile(stack_idx&gt;=1)//输出阶段,这里就是检测是否正确归并入栈，没有归并   &#123;        pop(stack_pos1,stack_length1);        pop(stack_pos2,stack_length2);       if(stack_pos1&gt;stack_pos2)merge(stack_pos2,stack_length2,stack_pos1,stack_length1);       else merge(stack_pos1,stack_length1,stack_pos2,stack_length2);       for(int i=0;i&lt;N;i++)       &#123;           cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;       &#125;\n\n\n\ntimsort模板（自己写的！）#include&lt;iostream&gt;using namespace  std;const int M =10010;int q[M];int tmp[M];int pos_stack[M];//存储下标int length_stack[M];//存储长度int stack_idx=-1;void push(int pos,int length )&#123;    pos_stack[++stack_idx]=pos;    length_stack[stack_idx]=length;&#125;void pop(int &amp;tmp_pos,int &amp;tmp_length)//给两个数赋值然后弄出去&#123;    tmp_pos= pos_stack[stack_idx];    tmp_length= length_stack[stack_idx];    --stack_idx;    return;&#125;void reverse(int q[],int l,int r)&#123;    for(int i=l,j=r;i&lt;=j;i++,j--)swap(q[i],q[j]);&#125;void array_reverse(int q[],int N)&#123;    if(N==1&amp;&amp;N==0)return;    int i=1,l=0,tmp=0,tem_l=0,stage_judge;    if(q[0]&lt;=q[1])stage_judge=1;//升序标记    else  stage_judge=0;    while(i&lt;N)    &#123;        if(q[i]&gt;q[i+1])        &#123;            if(stage_judge==1)            &#123;                stage_judge=0;//之前是升序这里突然降序了            &#125;            ++i;        &#125;        else if(q[i]&lt;=q[i+1])        &#123;            if(stage_judge==0)            &#123;                if(tmp!=l-1)++l;                reverse(q,l,i);                tmp=i;                stage_judge=1;            &#125;            ++i;//前进一个            l=i;//l=前进一位之后的i        &#125;    &#125;&#125;void merge(int pos1,int length1,int pos2,int length2)&#123;    int r=pos2+length2-1;//最右端    int l=pos1;//最左端    //归并部分    int mid=pos1+length1-1;    int k = 0, i = l, j = pos2 ;    while (i &lt;= mid &amp;&amp; j &lt;= r)//这里由于递归，每一个小数组都归并好了，归并最后的大数组        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//归并，结果合并到tmp，        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//赋值剩下的i    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//赋值剩下的j    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];    push(pos1,length1+length2);//合并完之后进行压栈&#125;void stack_check(int N)//对栈进行检验,并且要的是归并两个连续短区间&#123;    int stack_pos1,stack_pos2,stack_pos3;    int stack_length1,stack_length2,stack_length3;//1最顶，3最底层    pop(stack_pos1,stack_length1);    pop(stack_pos2,stack_length2);    pop(stack_pos3,stack_length3);    if(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)//x&gt;y或者x+y&gt;z    &#123;        if(stack_length1&gt;stack_length3)        &#123;                push(stack_pos1,stack_length1);                merge(stack_pos3, stack_length3,stack_pos2, stack_length2 );//对yz进行归并        &#125;            else        &#123;                    push(stack_pos3,stack_length3);                    merge(stack_pos2,stack_length2,stack_pos1,stack_length1);//对xy进行归并        &#125;           // cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;        for(int i=0;i&lt;N;i++)        &#123;            cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;        if(stack_idx&gt;=2)stack_check(N);//递归检测    &#125;    else//按照原先顺序再压进去    &#123;        push(stack_pos3,stack_length3);        push(stack_pos2,stack_length2);        push(stack_pos1,stack_length1);        cout&lt;&lt;endl&lt;&lt;endl;    &#125;    return;&#125;//归并搞定int main() &#123;    int N;    cin &gt;&gt; N;    int stack_pos1,stack_pos2,stack_pos3;    int stack_length1,stack_length2,stack_length3;    for (int i = 0; i &lt; N; i++) &#123;        cin &gt;&gt; q[i];    &#125;    array_reverse(q, N - 1);//没问题了,别动！    int l=0;    for(int i = 0; i &lt; N; i++) &#123;        if(q[i]&gt;q[i+1])        &#123;            push(l,i-l+1);            l=i+1;        &#125;    &#125;//这里完成将栈压入    //接下来就是找最大的，然后合并    cout&lt;&lt;endl&lt;&lt;endl;    for(int i=0;i&lt;N;i++)    &#123;        cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    if(stack_idx&gt;=2)stack_check(N);    while(stack_idx&gt;=1)//输出阶段,这里就是检测是否正确归并入栈，没有归并   &#123;        pop(stack_pos1,stack_length1);        pop(stack_pos2,stack_length2);       if(stack_pos1&gt;stack_pos2)merge(stack_pos2,stack_length2,stack_pos1,stack_length1);       else merge(stack_pos1,stack_length1,stack_pos2,stack_length2);       for(int i=0;i&lt;N;i++)       &#123;           cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;       &#125;   &#125;    return 0;&#125;//23         2 4 7 8 23 19 16 14 13 12 10 20 18 17 15 11 0 5 6 1 3 21 22\n\n\n\n二分二分本质并不是单调性：有单调性一定可以二分解，可以二分解的题目不一定满足单调性，本质：可以将原本区间分成两个部分\n二分一定有解（自己的二分的性质是一定有边界的），但题目可能会无解（看例题）\n整数二分比实数二分蛋疼很多：整数有边界问题很恶心\n当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了\n整数模板（两种）应用：\n1：找大于等于数的第一个位置 （满足某个条件的第一个数）2：找小于等于数的最后一个数 （满足某个条件的最后一个数）3.查找最大值 （满足该边界的右边界）、4.查找最小值 (满足该边界的左边界)\n然后每次使用这这两个模板的时候，先想是找这个区间的左端点还是还是右端点，然后选择用模板，最后再去写判断条件。\n设置红绿交界点是要求的位置\n\n\n最后收敛到整个数组中满足条件的最右边的点\n最后收敛到数组中满足条件的最左边的点\n\n\n记忆方式：有减必有加\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质//核心在于判断l=mid还是r=mid//收敛到最右边的点// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：情况1int SR(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;//需要补上l+r+1，防止死循环        if (check(mid)) l = mid;        else r = mid - 1;//有减，前面必定有加    &#125;    return l;&#125;//收敛到最左边的点// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：情况2int SL(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;//这里是（l+2）/2        if (check(mid)) r = mid;    // check()判断mid是否满足性质：        else l = mid + 1;    &#125;    //    return l;//这里最终l和r相等，不需要考虑别的&#125;\n\n整数经典例题：789. 数的范围 - AcWing题库经典：二分模板最终一定有解，题目不一定有解（最后的判断不满足题目）\n解答：\n\n#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int q[N];int SL(int l, int r, int x) &#123;//最终结果是最左边满足条件的  while (l &lt; r) &#123;    int mid = l + r &gt;&gt; 1;    if (q[mid] &gt;= x) r = mid;    else l = mid + 1 ;  &#125;  return l;&#125;int SR (int l, int r, int x) &#123;  while (l &lt; r) &#123;    int mid = l + r + 1 &gt;&gt; 1;//有+    if(q[mid] &lt;= x) l = mid;    else r = mid - 1;//有-  &#125;  return r;&#125;int main() &#123; int n,m;    scanf (&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;n;++i) scanf (&quot;%d&quot;,&amp;q[i]);    while ( m-- ) &#123;        int x;        scanf (&quot;%d&quot;,&amp;x);        int l = SL(0, n - 1, x);//查找左边界 并返回下标l        //这里最后的L就是最左边第一个满足&gt;x的数字，也就是满足二分得到的结果（最接近x且&gt;=x）        //因此下一步可以直接判断是否直接=x        if (q[l]!=x) cout &lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;//如果找不到  返回-1 -1        else &#123;            cout &lt;&lt; l &lt;&lt; &#x27; &#x27;; //如果找到了  输出左下标            cout &lt;&lt; SR(0, n - 1, x) &lt;&lt; endl; //输出右下标        &#125;    &#125;    return 0;&#125;\n\n同样的例题：（爷跟你拼了）\n519. 跳石头 - AcWing题库照样使用二分（虽然是比较复杂的二分）：二分,贪心O(NlogL)\n思路：使得选手们在比赛过程中的最短跳跃距离尽可能长，当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了。验证答案具有单调性：拿走的石头越多，最短跳跃距离越大，这就叫答案的单调性\n核心原理：\n\n二分答案二分答案就是把一组数据每次分成两部分，就是把大问题转化成小问题。例如猜数游戏，猜1-100的一个数，就先猜50，若小了，就猜75，若大了，就猜25，就这样一直猜下去，最终找到答案。而我们每一次猜的这个答案就是所求范围内的数据的中间数据，这就是二分答案。这个二分的中间数据就是指要求的内容。\n如果长度 LenLen 可以满足，那么当长度小于 LenLen 时也可以满足，所以我们可以二分出最大的 LenLen。也就是在所有可满足的Len中寻找最右端的答案（这里指从0到最大），因此使用模板SR（再看上一道题实际上一个原理）\n剩下的问题是如何判断给定 LenLen 的情况下，能否最多拿走 M块石头，使得所有相邻两块石头之间的距离不小于 LenLen。这一步可以贪心来做。从前往后扫描，并记一下上一块石头的位置。\n如果当前石头和上一块石头的距离小于 LenLen，则将当前石头拿走\n如果当前石头和上一块石头的距离大于等于 LenLen，则将上一块石头更新成当前这块。（和上一条是贪心时候的两种解法）\n这里给出贪心证明：如果某个最优解中是拿走了上一块石头，那么我们可以改成留下上一块石头，拿走当前这块石头，这样总共拿走的石头数量不变，所以当前选法也是一组最优解。\ncheck函数：我们遍历一遍每一块石头，累计出有多少块石头之间的间隔&lt;&#x3D;mid,如果超过m个，就不合法，如果小于等于m，就合法。(累计间隔小也就是需要搬走多少个石头)\n扫描结束后判断拿走的石头数量是否小于等于 M。（判断这个答案能不能执行，能说明答案mid还能猜测更大，更新l，不能说明mid猜测过大了，更新r）\n\n时间复杂度分析总共二分 O(logL)O(logL) 次，每次贪心的计算是 O(N)O(N)，因此总时间复杂度是 O(NlogL)O(NlogL)。\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50005;int a[N];int n,m,s;bool check(int x) //check函数判断这个最短跳跃距离x是否合法&#123;    int cnt=0,last=0; //last表示的是上一块石头的位置,cnt用来计数    for(int i=1;i&lt;=n;i++)   //枚举每一块石头     &#123;        //不移动走石头，就实时更新上一块石头位置，如果移动，就不更新        if(a[i]-last&lt;x) cnt++;//如果这一块石头和上一块石头的距离比x小,计数+1。而且如果石头移走，last还是上一块石头的位置。        else last=a[i]; //否则这块石头就不必移走，last=这块石头的位置。    &#125;    if(cnt&gt;m) return false; //cnt如果超过m个，就不合法。    else return true;&#125;int main()&#123;    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    a[n+1]=s;//将终点的距离也算进去    n=n+1;//注意这里的n需要加一，check函数需要用    int l=1,r=s; //注意l和r都是最短跳跃距离的边界，而不是石头的边界。     while(l&lt;r)    &#123;        int mid=l+r+1&gt;&gt;1;        if(check(mid)) l=mid;//答案猜小了        else r=mid-1;//答案猜大了    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;\n\nhttps://www.acwing.com/blog/content/21312/\nhttps://www.acwing.com/solution/content/118815/\nhttps://leetcode.cn/leetbook/read/illustration-of-algorithm/59bjss/\nhttps://www.acwing.com/solution/content/120802/\n浮点模板浮点好处在于不用考虑整数二分中的边界问题，因此直接用\nbool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)    &#123;        double mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;//这里就不用多考虑    &#125;    return l;&#125;\n\n例题：790. 数的三次方根 - AcWing题库\n#include &lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;double x;int main () &#123;    cin &gt;&gt; x;    double l = -1000,r = 1000;//这里一开始范围设定大，直接从0开始    while (r - l &gt;= 1e-7) &#123;        double mid = (l + r) / 2;        if (mid * mid * mid &lt;= x) l = mid;  //如果是小于等于的话，就可以说明答案会更大        //比较重要的一步，c++里面几次方就直接弄，别用mid^3,配合c++primer食用        else r = mid;    &#125;    printf (&quot;%.6lf&quot;,l);    return 0;&#125;\n\n二分改进：插值查找应用范围：表长较大，关键字分布均匀\n关键不同：二分mid固定为0.5，插值查找mid参数动态变化\nmid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;\n\n斐波那契查找(104条消息) 七大查找之斐波那契查找_非常规自我实现的博客-CSDN博客_fibonacci查找\n前缀和（应用广泛）数据结构应用：字符串哈希表kmp，自动机kmp，\n前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩压缩部分：解压缩部分：离散化：整数离散化如果使用哈希，会有额外的空间开销\n特点：值域范围大，但是个数少（比如要访问到数组的10^9的位置，但个数只有10^5）也就是对于一个函数a-&gt;b，实际上只需要映射a，不需要操作b（当然高级玩家也可以继续弄b）。一般有两个问题：\n\na数组里面可能有重复元素，因此需要去重，（去重是最重要的）\n如何算出a[i]离散化后的值，保序离散化（a数组本身下标有序的），映射后一定也要是有序的，a[i].由于a有序，可以使用二分\n\n需要使用的知识点：\n\nvector\npair\n\n离散化模板：(c++版本)//alls存储的是最开始的下标vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123;    int l = 0, r = alls.size() - 1;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;        if (alls[mid] &gt;= x) r = mid;        else l = mid + 1;    &#125;    return r + 1; // 映射到1, 2, ...n    //前缀和从1开始相对方便&#125;\n\nAcWing 802. 区间和 - AcWing\n分析：\n使用离散化原因：\n\n存储下标过大，不能开这么大的下标\n使用数轴，会存在负值，不能使用下标\n哈希表不能像离散化缩小数组的空间，可能导致遍历-e9~1e9。此处的含义就是假如我们需要计算1e-9和1e9区间内的值，那我们需要从前到后枚举，无论该值是否存在。因为哈希表不能排序，因此不能提前知道哪些数周上的点不存在，会枚举多次（如最后query的时候，从1到1e9，使用哈希表就要遍历才知道是否有点，时间开销太大），\n\n离散化本质：映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量，也就是如何能够将不连续的点映射到连续的数组的下标。\n本题解法：(离散化) O((n+2∗m)log(n+2∗m))\n\n开辟额外数组存放原来 的下标标志\n对原来的数轴下标进行排序再去重，原因：考虑前缀和思想，我们需要求出的区间内的和的两端断点不一定有元素，提前加如需要求前缀和的两个端点，有利于我们进行二分搜索，其实二分搜索里面我们一般假定有解的，如果没解的话需要特判，所以提前加入了这些元素，从而导致可能出现重复元素\n最多使用n+2m次操作，最多使用的下标跨度为3*10^5,\n\n首先用而二分写好映射后对应的数组下标，复杂度log(n + 2 * m)\nint find(int x)&#123;    int l = 0, r = alls.size() - 1;    while(l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;        if(alls[mid] &gt;= x) r = mid;        else l = mid + 1;    &#125;    return r + 1;&#125;\n\n全解：\n关于unique和erease可以看\n[(100条消息) C++ 之vector元素去重unique()_sandalphon4869的博客-CSDN博客_unique vector](https://blog.csdn.net/sandalphon4869/article/details/98209093?ops_request_misc=%7B%22request%5Fid%22%3A%22166674706816800184111752%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166674706816800184111752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-98209093-null-null.142^v59^pc_rank_34_1,201^v3^control_1,213^v1^t3_control1&amp;utm_term=vector unique&amp;spm&#x3D;1018.2226.3001.4187)\nauto:(100条消息) c++ auto基本用法_lwgkzl的博客-CSDN博客_auto用法\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;//pair可以同时存储两个数据，可以理解成半封装的结构体const int N = 300010;//最多涉及的下标长度int a[N], s[N];int n, m;vector&lt;int&gt; alls;//存储下标值vector&lt;PII&gt; add, query;//分别存储询问和加int find(int x)&#123;    int l = 0, r = alls.size() - 1;    while(l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;        if(alls[mid] &gt;= x) r = mid;        else l = mid + 1;    &#125;    return r + 1;//为了最终的映射从1开始&#125;vector&lt;int&gt;:: iterator unique(vector&lt;int&gt; &amp;a)&#123;//这里是手动实现unique，非c++语言需要手动    //作用为自动去重    int j = 0;    for(int i = 0; i &lt; a.size(); i ++)        if(!i || a[i] != a[i - 1])            a[j ++ ] = a[i];    return a.begin() + j;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0; i &lt; n; i ++ )    &#123;        int x, c;//x是下标        cin &gt;&gt; x &gt;&gt; c;        add.push_back(&#123;x, c&#125;);        alls.push_back(x);    &#125;    for(int i = 0; i &lt; m; i ++ )    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        query.push_back(&#123;l, r&#125;);        alls.push_back(l);        alls.push_back(r);        //全部存储后alls组成为x,x,x,x,x,l1,r1,l2,r2等等    &#125;//直接unique(a)不加其它参数就是默认直接从头到尾，    sort(alls.begin(), alls.end());//对原来的数组下标进行从小到大    vector&lt;int&gt;::iterator pos = unique(alls);     //pos是去重以后vector中没有重复元素的下一个位置的迭代器    //从容器的开始到返回的迭代器位置的元素是不重复的元素，而从返回的迭代器位置到vector.end()的元素都是没有意义的（这东西就是原来排序后的东西，没变过）。    //比如1 2 3 3 4 4 5 5unique后为1 2 3 4 5   5 5 5（别管这三个什么，没意义）    alls.erase(pos, alls.end());//删除重复元素    for(auto item : add)//add是一个vector&lt;PII&gt; add，为方便初始化这么用    &#123;        int x = find(item.first);//第一个值是要加的数的下标        a[x] += item.second;//对应的数组位置加该数    &#125;    for(int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];    //这里用前缀和方法求所有的前缀    for(auto item : query)    &#123;        int l = find(item.first),         r = find(item.second);//两个都是        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;        //这里最后就是对应过来的减去后的值，    &#125;    return 0;&#125;//这些数据是验算用的3 3//m。n1 23 67 51 34 67 8\n\n\n\n补充auto：\nint main()&#123;    vector&lt;int&gt;v;    v.push_back(1);    v.push_back(2);    v.push_back(3);    for(auto i : v)&#123;//这一步就是迭代器从begin走到end        cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    return 0;&#125;\n\n区间合并：不同于离散化应用：很多区间，如果有交集就合并成一个更长的区间\n区间合并算法：快速地进行多个区间的合并,当然可以进行一些特殊处理，比如对于端点就进行统一归并\n步骤：\n按区间左端点进行排序\n扫描过程中，对于所有有交集的区间进行合并。\n\n左边端点设置成start，右边设置成end，可能有的关系：\n\n\n\n左右都在内部：原本区间不变\n仅一部分在内部：新的ed会边长（左端点不会更新，因为是按照左端点从小到大的顺序进行区间的扫描的）\n都不在内部：不用管就完事了\n\n代码模板#include&lt;algorithm&gt;void merge(vector&lt;PII&gt; &amp;segs)&#123;    vector&lt;PII&gt; res;    sort(segs.begin(), segs.end());//这里是因为pair是默认按照左端点排序的    int st = -2e9, ed = -2e9;    for (auto seg : segs)        if (ed &lt; seg.first)//情况3：两个区间无法合并        &#123;            if (st != -2e9) res.push_back(&#123;st, ed&#125;);//区间1放进去res数组            st = seg.first, ed = seg.second;//维护区间2        &#125;        else ed = max(ed, seg.second);//情况12，可以合并，进行更新     //考虑循环结束时的st,ed变量，此时的st,ed变量不需要继续维护，只需要放进res数组即可。    //因为这是最后的一个序列，所以不可能继续进行合并。    if (st != -2e9) res.push_back(&#123;st, ed&#125;);//说的就是你，最后一个序列，if就是防一下空序列    segs = res;//这样回复的就是答案segs&#125;//最大原因：排过序了，不用担心复用//排过序之后，不可能有区间2包含区间1，只能是1包含后面的//本质，遍历，每一次如果两个区间没有相交的部分（无法合并），那么就将一个区间推入作为答案，同时更新左右端点\n\ny总：\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; PII;vector&lt;PII&gt; segs;void merge(vector&lt;PII&gt;&amp;segs)&#123;    vector&lt;PII&gt; res;    sort(segs.begin(),segs.end());//先对于全部区间进行排序    int l = -2e9,r = -2e9;//小就完事了    for(auto item:segs)//定义了一个迭代器，这里是一个遍历的过程    &#123;//! 第一段区间一定是  ed&lt; item.first        if(r &lt; item.first)//当前区间右端点严格小于枚举区间的左边        &#123;//情况1：两个区间无法合并            if(l != -2e9) res.push_back(&#123;l,r&#125;);//! 第一次在这里初始化            //区间1放进去res数组            l = item.first;//! 第一段区间从这里开始即seg[0].first            //维护区间2            r = item.second;//第一段区间的。seg[0].second        &#125;//todo 这个循环结束之后还会剩下一个区间        else r = max(r,item.second);//第二种情况，说明有交集，右端点更新成维护的区间的右端点以及最大值    &#125;//! 如果不是空的  那我们就加上一段    if(l != -2e9) res.push_back(&#123;l,r&#125;);//最后一个区间判断一下，防止空区间    segs = res;//区间更新变成res&#125;int main()&#123;    int n;    cin &gt;&gt; n;    while(n--)    &#123;        int l,r;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        segs.push_back(&#123;l,r&#125;);    &#125;    merge(segs);    cout &lt;&lt; segs.size() &lt;&lt; endl;    return 0;&#125;\n\n\n\n数据结构链表 有限性：数据元素个数有穷\n相同性：数据元素的类型是同一的\n顺序性：相邻的数据元素之间存在序偶关系\n前言：\n链表当中利用结构体制造链表的速度都是非常慢的，会消耗很多的时间，而正常面试中需要使用到链表时候大小都是有限制的，一般是十万或者百万的级别，而单单是new这些节点就会导致超时，在笔试题中最好不要用结构体指针，可以优化比如提前构建好多个节点，但已经类似于数组模拟链表了.算法题中绝对绝对不要考虑内存泄漏的问题\n\n使用结构体去构建链表的另一个问题在于键入指令会很麻烦\n//数组版本int next[N],prev[N],valu[N]void delete(int k)&#123;    next[prev[k]]=next[k];//向右跳过中间    prev[next[k]]=prev[k];//向左跳过中间&#125;//结构体版本struct Node&#123;\tint valu,next,prev;&#125;nodes[N];void delete(int k)&#123;    nodes[nodes[k].prev].next=nodes[k].next;    nodes[nodes[k].next].prev=nodes[k].prev;&#125;//两种类型相比第二种整体结构易于理解但是在使用过程中语句特别长而且不太容易理解\n\nps:算法题中大部分操作都是头插法\n链表制造方式\n结构体+指针（c++需要使用new，费时间）\n数组模拟（这里是静态数组，用空间换时间）\n\n小tips：邻接表本质就是n个单链表拼起来，正常一个head对应一条链表，这个就是开了一个组，head[i]对应第i条链表\n数组模拟链表\n\n单链表：邻接表（实际上n个链表），主要应用在于存储图和树\n双链表：优化某些问题\n\n单链表制作826. 单链表 - AcWing题库\n//通用版本的静态链表  //e[n]:某个点的值，ne[n]:某个点的指针，使用下标关联起来const int n =1000010;//e[i]节点i//ne[i]节点i的next指针指向的值//idx存储已经用过哪一个点int head,e[n],ne[n],idx;/*这个的灵魂在于idx,有了idx可以保证无论新插的节点是头插还是尾插都没区别，都会用来计数，然后在对第k个进行操作的时候直接就定位到了idx*/void initial()&#123;    head=-1;//让head指向一个空的位置    idx=0//idx数量实际上就是链表当中总共节点的数量&#125;void add_to_tail(int x)//尾插&#123;    e[idx]=x;    if(head==-1//当是第一次插入时特殊处理    &#123;        ne[idx]=head;        head=idx;        idx++;        return;    &#125;    int i=head;    if(head!=-1)while(ne[i]!=-1)i=ne[i];//最后ne[i]=-1    ne[idx]=-1;    ne[i]=idx;    idx++;&#125;void add_to_head(int x)//头插&#123;    e[idx]=x;//保存x的值到一个新的位置    ne[idx]=head;//更新指向，新元素指向原先head的位置，也就是-1（第一次跑）    head=idx;//head头节点更新位置，更新到新元素的下标    idx++;//下一个新的元素&#125;void add(int k,int x)//注意和头插的区别在于位置变换的是ne[k]&#123;    k=k-1；//千万注意注意这里要改一下        //否则会出范围的                    e[idx]=x;//先保存    ne[idx]=ne[k];//指向原先k的位置    ne[k]=idx;    idx++;//说明加&#125;void delete(int k)//tm惊为天人的简洁版本&#123;//这里是删除第k个添加的，并不是按照值来删除    k=k-1；//千万注意注意这里要改一下        //同样会出范围                    ne[k]=ne[ne[k]];//我tm直接更新ne[k]指向的位置，中间数直接损失指引&#125;void dele(int a)//这个是删除某一个特定值       &#123;//一个问题是如果只有一个元素需要特判           if(e[head]==a)head=ne[head];//直接清空就行           else for(int i=head;ne[i]!=-1;i=ne[i])//多个元素时候的删除操作           &#123;               if(e[ne[i]]==a)//这里关系是跳过中间               &#123;                   ne[i]=ne[ne[i]];               &#125;          &#125;       &#125;void print()&#123;    for(int i=head;i!=-1;i=ne[i])//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）    &#123;        cout&lt;&lt;e[i]&lt;&lt;&#x27; &#x27;;        cout&lt;&lt;endl;    &#125;&#125;\n\n双链表制作#include&lt;iostream&lt;using namespace std;const int M=20010;int r[M],prev[M],e[M],index;void initial()&#123;   //双链表相对单链表的初始化不同   r[0]=1;//最左端指向最右端   l[1]=0;//最右端指向最左端   index=2;//另一个好处就是非常直白，双数肯定是向右的，单数向左的&#125;void add_to_right(int x,int k)//第k个的右边插入&#123;    e[idx]=x;    r[idx]=r[k];    l[idx]=k;    //新节点的延申部位都搞定了，开始双向连接    l[r[k]]=idx;    r[k]=idx//    idx++;&#125;//向右插就是  add_to_right( x, k+1)//k+1因为index从2开始计数//聪明的方法，在左边插入直接调用add_to_right(x,l[k]),也就是在k的左边节点调用向右插，结果就是第k个节点左边插入add_to_right( x, l[k+1])//同理//如果是最左端或者最右端更简单//最左端 add_to_right( x, 0) //右端add_to_right( x, l[1])      void dele(int k)&#123;    r[l[k]]=r[k];    l[r[k]]=l[k];&#125;void print()&#123;    for(int i=r[0];i!=1;i=r[i])//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）    &#123;        cout&lt;&lt;e[i]&lt;&lt;&#x27; &#x27;;        cout&lt;&lt;endl;    &#125;&#125;//使用的时候的api：\tadd_to_right( x, k+1)    add_to_left(x,k+1)\tdele(k+1)     第k个插入的数左边插入：add_to_right(x,l[k+1])     第k个插入的数右边插入：add_to_right(x,k+1)\n\n//双向链表制作#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;struct Node&#123;\tchar data;\tstruct Node* next;\tstruct Node* pre; &#125;;struct Node*p;struct Node*head;struct Node*tail;void Home()&#123;\tp=head;&#125;void End()&#123;\tp=tail-&gt;pre;&#125;void Left()&#123;\tif(p==head) return;    p=p-&gt;pre;&#125;void Right()&#123;\tif(p-&gt;next==tail) return;\tp=tail-&gt;pre;&#125;void Back()&#123;   \tif(p==head) return;\tstruct Node*tmp=(struct Node*)malloc(sizeof(struct Node));\ttmp=p;\ttmp-&gt;pre-&gt;next=tmp-&gt;next;\ttmp-&gt;next-&gt;pre=tmp-&gt;pre;\tfree(tmp);&#125;\tint main()&#123;\tchar s[50010];\tint i;\tstruct Node*head=(struct Node*)malloc(sizeof(struct Node));\tstruct Node*tail=(struct Node*)malloc(sizeof(struct Node));\tstruct Node*p=head;\thead-&gt;next=tail;\ttail-&gt;pre=head;\ttail-&gt;next=NULL;\thead-&gt;pre=NULL; \t\t\tscanf(&quot;%s&quot;,s);\t\t\tfor(i=0;s[i]!=&#x27;\\0&#x27;;i++)\t&#123;\t\t\t\t\tif(s[i]==&#x27;&#123;&#x27;) Home();\t\telse if(s[i]==&#x27;&#125;&#x27;) End();\t\telse if(s[i]==&#x27;&lt;&#x27;) Left();\t\telse if(s[i]==&#x27;&gt;&#x27;) Right();\t\telse if(s[i]==&#x27;#&#x27;) Back();\t\telse\t\t\t&#123;\t\t\tstruct Node*q=(struct Node*)malloc(sizeof(struct Node));\t\t\tq-&gt;data=s[i];\t\t\tq-&gt;pre=p;\t\t\tq-&gt;next=p-&gt;next;\t\t\tp-&gt;next-&gt;pre=q;\t\t\tp-&gt;next=q;\t\t\tp=p-&gt;next;\t\t\t&#125;\t\t\t\t\t&#125;\t\t\tfor(p=head-&gt;next;p!=tail;p=p-&gt;next)\t&#123;\t\tprintf(&quot;%c&quot;,p-&gt;data);\t&#125;\t&#125;\n\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int M=100090;int nex[M];int pre[M];int valu[M];int idx;void initial(void)&#123;   //双链表相对单链表的初始化不同   nex[0]=1;//最左端指向最右端   pre[1]=0;//最右端指向最左端   idx=2;//另一个好处就是非常直白，双数肯定是向右的，单数向左的&#125;void add_to_right(int x,int k)&#123;    valu[idx]=x;    nex[idx]=nex[k];    pre[idx]=k;    //新节点的延申部位都搞定了，开始双向连接    pre[nex[k]]=idx;    nex[k]=idx;//    idx++;&#125;//更聪明的方法，在左边插入直接调用add_to_right(x,prev[k]),也就是在k的左边节点调用向右插void dele(int k)&#123;    nex[pre[k]]=nex[k];    pre[nex[k]]=pre[k];&#125;int main()&#123;    int tem;    int index;    int n;    cin&gt;&gt;n;    initial();    for(int i=0;i&lt;n;i++)    &#123;        string a;        cin&gt;&gt;a;        if(a==&quot;D&quot;)        &#123;            cin&gt;&gt;index;            dele(index+1);        &#125;        if(a==&quot;L&quot;)        &#123;            cin&gt;&gt;tem;            add_to_right(tem,0);        &#125;        if(a==&quot;R&quot;)        &#123;            cin&gt;&gt;tem;            add_to_right(tem,pre[1]);        &#125;        if(a==&quot;IL&quot; )        &#123;            cin&gt;&gt;index&gt;&gt;tem;            add_to_right(tem,pre[index+1]);        &#125;        if(a==&quot;IR&quot; )        &#123;            cin&gt;&gt;index&gt;&gt;tem;            add_to_right(tem,index+1);        &#125;    &#125;    for(int i=nex[0];i!=1;i=nex[i])    &#123;        cout&lt;&lt;valu[i] &lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;\n\n\n\n链表递归与双指针应用：力扣19题\n方法：未知链表长度情况下通过递归获取长度\n注意这种递归本质上是逆序进行扫描，从null扫描到head（不是空节点头，而是存放第一个值的头）\n读取顺序讲解：\n以1234，2示例如有a,b,c,d四个节点，分别存放1，2，3，4（a是头4是尾，4-&gt;next&#x3D;NULL）\n那么调用函数length时候会先一直向下扫描（因为未满足条件之前不会进行return），扫描到d的下一个节点null这时返回1-&gt;到达节点d，（因为有pos&#x3D;length(node-&gt;next,n)+1,+1导致从节点null返回d时候pos变成1）返回2（到达节点c），返回3（到达节点b），注意这时候满足倒序扫描到第三个了，也就是要删除的节点再向上回溯了1位,因此删除节点c,即node-&gt;next&#x3D;node-&gt;next-&gt;next**(b指向c变成b指向d)**\n好处：时间少（只用扫描一次），空间少（没有额外开辟指针）\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public://尝试递归解决    int length(ListNode *node,int n)//这一段千万千万注意是倒序，倒叙进行读取！！！    &#123;        if(node==NULL)return 0;//递归停止        int pos=length(node-&gt;next,n)+1;        if(pos==n+1)//进行判断了，说明在第几层递归            node-&gt;next=node-&gt;next-&gt;next;        return pos;//递归层层回溯    &#125;                    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        int pos =length(head,n);        if(pos==n)return head-&gt;next;//链表总长度刚好等于倒退长度，即处理头节点情况        return head;//    &#125;&#125;;\n\n参考网址：【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）\n同样利用递归实现链表逆序：（有那么一点点费脑子）原理：链表自身带有递归属性（一个大问题可以拆解成小问题）\n将链表拆分成头节点和剩余节点，同理继续拆解，一直拆解到最后的尾节点和前面的一堆“头”节点,最后一个节点不需要进行翻转\n\n\n这里就是对于子问题，将子链表进行翻转，就可以得到整个链表的反转，也就是递归的第一步\npublic ListNode reverseList(ListNode head) &#123;    // 调用递推公式反转当前结点之后的所有节点    // 返回的结果是反转后的链表的头结点    ListNode newHead = reverseList(head.next);&#125;\n\n这里假设后续子链表已经全部完成翻转，那么只需要对“头节点”完成翻转\n\n\n也就是\nhead-&gt;next-&gt;neat=head;head-&gt;next=NULL;\n\n完善之后就是有\npublic ListNode reverseList(ListNode head) &#123;    // 调用递推公式反转当前结点之后的所有节点    // 返回的结果是反转后的链表的头结点    ListNode newHead = reverseList(head.next);    //到这里已经是假设后面的链表部分已经全部反转完成，也就是只需要处理头节点和剩余部分的关系    head.next.next = head;    head.next = null;    return newHead;//注意哦，这里返回的是newhead，因为newhead是反转之后的链表的头节点，即最尾部的节点&#125;\n\n再加上约束条件（递归终止条件）\n/*if (head == NULL || head-&gt;next == NULL) &#123;//返回条件/结束递归条件            return head;        &#125;   */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (head == NULL || head-&gt;next == NULL) &#123;//返回条件/结束递归条件            return head;        &#125;        ListNode* ret = reverseList(head-&gt;next);//这里递归，ret会在走到链表末端开始翻转        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return ret;//    &#125;&#125;;/*执行起来大概是这么一个既视感\n\n\n\n双指针实现逆序\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* cur = NULL, *pre = head;        while (pre != NULL) &#123;//终止条件，最后的指针pre走到末尾停止            ListNode* temp = pre-&gt;next;            pre-&gt;next = cur;//开始反置指针指向            //cur和pre整体向前移动一个位置            cur = pre;            pre = temp;        &#125;        return cur;    &#125;&#125;;\n\n原理：一开始创建两个指针pre和cur，pre指向head，cur指向null，tem有点类似指针交换数值中的tem，指向正常链表顺序的下一个节点（这里就是head-&gt;next），\n\n有序链表的拼接（又是递归&#x2F;bushi）时间复杂度：O(m+n)\nclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if (l1 == NULL) &#123;//终止条件：l1走到末尾了            return l2;        &#125;        if (l2 == NULL) &#123;//终止条件：l2走到末尾了            return l1;//剩下的都弄上去就是        &#125;                //分割线        if (l1-&gt;val &lt;= l2-&gt;val) &#123;            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);//对l1的剩余部分进行一个递归操作            //重点部分mergeTwoLists(l1-&gt;next, l2)，对l1后面的元素处理                    return l1;//因为L1的这个元素小，因此把它拎出来        &#125;        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);//对l2的剩余部分进行递归操作，l2-&gt;next同理              return l2;//同理    &#125;&#125;;\n\n解释的一个部分关于return L1的个人理解: 递归的核心在于,我只关注我这一层要干什么,返回什么,至于我的下一层(规模减1),我不管,我就是甩手掌柜.好,现在我要merge L1,L2.我要怎么做?- 显然,如果L1空或L2空,我直接返回L2或L1就行,这很好理解.//上方的两个NULL情况- //如果L1第一个元素小于L2的? 那我得把L1的这个元素放到最前面,至于后面的那串长啥样 ,我不管. 我只要接过下级员工干完活后给我的包裹, 然后把我干的活附上去(令L1-&gt;next = 这个包裹)就行- 这个包裹是下级员工干的活,即merge(L1-&gt;next, L2)我该返回啥?- 现在不管我的下一层干了什么,又返回了什么给我, 我只要知道,假设我的工具人们都完成了任务, 那我的任务也就完成了,可以返回最终结果了- 最终结果就是我一开始接手的L1头结点+下级员工给我的大包裹,要一并交上去, 这样我的boss才能根据我给它的L1头节点往下找,检查我完成的工作\n\n回文链表判断：（映射，递归，翻转）映射到数组上再对数组进行操作\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        vector&lt;int&gt; vals;        while (head != nullptr) &#123;            vals.emplace_back(head-&gt;val);//使用迭代器更加节省时间一些，如果是数组会报错            head = head-&gt;next;        &#125;        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;            if (vals[i] != vals[j]) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n优雅递归\n遍历节点的方式可是我看不懂\nclass Solution &#123;    ListNode* frontPointer;//这个是前指针public:    bool recursivelyCheck(ListNode* currentNode) &#123;        if (currentNode != nullptr) &#123;            if (!recursivelyCheck(currentNode-&gt;next)) &#123;                return false;            &#125;            if (currentNode-&gt;val != frontPointer-&gt;val) &#123;                return false;            &#125;            frontPointer = frontPointer-&gt;next;        &#125;        return true;    &#125;    bool isPalindrome(ListNode* head) &#123;        frontPointer = head;        return recursivelyCheck(head);    &#125;&#125;;\n\n解释：currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val !&#x3D; frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。\n复杂度分析\n时间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。空间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。我们要理解计算机如何运行递归函数，在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 nn 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时空间复杂度要考虑堆栈的使用情况。这种方法不仅使用了 O(n)O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。\n快慢指针\n很优雅**但是我照样看不懂***没想到吧老子看懂了哈哈哈哈哈哈哈\nclass Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if (head == nullptr) &#123;            return true;        &#125;        // 找到前半部分链表的尾节点并反转后半部分链表        ListNode* firstHalfEnd = endOfFirstHalf(head);//返回慢的那一半        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);//对中间开始往右的第一个开始翻转        // 判断是否回文        ListNode* p1 = head;        ListNode* p2 = secondHalfStart;        bool result = true;        while (result &amp;&amp; p2 != nullptr) &#123;            if (p1-&gt;val != p2-&gt;val) &#123;                result = false;            &#125;            p1 = p1-&gt;next;            p2 = p2-&gt;next;        &#125;                // 还原链表并返回结果        firstHalfEnd-&gt;next = reverseList(secondHalfStart);//为了保证链表本身不变，实际上可以省略（大概）        return result;    &#125;    ListNode* reverseList(ListNode* head) &#123;//是你最爱的双指针翻转法        ListNode* prev = nullptr;        ListNode* curr = head;        while (curr != nullptr) &#123;            ListNode* nextTemp = curr-&gt;next;            curr-&gt;next = prev;            prev = curr;            curr = nextTemp;        &#125;        return prev;    &#125;    ListNode* endOfFirstHalf(ListNode* head) &#123;//快慢指针，快的走俩，慢的走1，在中点停止        ListNode* fast = head;        ListNode* slow = head;        while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;        &#125;        return slow;    &#125;&#125;;\n\nzhan（栈）不是B站那个前言：栈属于一种FILO数据结构，类似阉割版本的顺序表，在计算机中有非常广泛的应用\n例：使用递归时，编译器自身对于递归指令的使用就是一种栈，或者计算中缀表达式（通过将中缀表达式转换为后缀表达式，再对后缀表达式进行栈运算就可以得出结果）-&gt;全部利用栈的FILO结构\n栈制造方式\n数组栈-&gt;非常非常easy\n链表栈-&gt;参考链表，但是阉割\n\n栈做非降路径问题离散数学组合数学里面的东西，如果对一个栈仅允许出栈入栈操作，对输入固定长度字母求所有的输出模式，其实本质就是一个非降路径，只需要计算从(0,0)到(n,n)的不经过y&#x3D;x+1的所有路径\n中缀表达式转换后缀表达式(104条消息) 中缀表达式转后缀表达式的方法_說詤榢的博客-CSDN博客_中缀表达式转后缀表达式\n正则表达式分析分析：\n\n使用栈来求：中缀表达式可以拆分成一棵中缀树，后缀类似拆分成后缀树，如（1+1）（2+2），中缀中根节点是，叶节点是+，叶子是1 1 2 2，如果用树的思想去做应该使用树的中序遍历，但是问题在于不好处理运算符的优先级问题，而改造成后缀表达式就会方便很多，如同上例子换成后缀表达式变成了1 1 + 2 2 + *，然后使用栈来进行运算，数字压栈，运算符出栈两个进行运算后再次压栈，这样就可以避开运算符优先级的处理问题（相对更好理解一些而且不需要搭建树，可以使用栈来搞）\n使用递归来求：已知将该表达式抽象成为一棵树，那么对每个子树使用递归求值可以不断削减树的层数，最后获得根树的值（**很牛逼但是很麻烦，要提前接触到树**）\n\n这里使用栈来进行一个中缀表达式的计算\n先看下只有 + 和 * 的。\n输入长度为n的字符串，例如：1+2+345\n输出表达式的值，即：63\n应该用什么数据结构？\n栈。\n应该先计算哪一步？\n实际应该先计算1+2。\n“表达式求值”问题，两个核心关键点：\n（1）双栈，一个操作数栈，一个运算符栈；\n（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：\n如果栈顶的运算符优先级低，新运算符直接入栈\n如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈\n仍以1+2+345举例，看是如何利用上述两个关键点实施计算的。\n首先，这个例子只有+和*两个运算符，所以它的运算符表是：\n\n这里的含义是：\n（1）如果栈顶是+，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；\n（2）如果栈顶是+，即将入栈的是*，栈顶优先级低，直接入栈；\n（3）如果栈顶是*，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；\n（4）如果栈顶是， 即将入栈的是，栈顶优先级高，需要先计算，再入栈；\n有了运算符表，一切就好办了。\n\n一开始，初始化好输入的字符串，以及操作数栈，运算符栈。\n\n一步步，扫描字符串，操作数一个个入栈，运算符也入栈。\n\n下一个操作符要入栈时，需要先比较优先级。\n栈内的优先级高，必须先计算，才能入栈。\n\n计算的过程为：\n（1）操作数出栈，作为num2；\n（2）操作数出栈，作为num1；\n（3）运算符出栈，作为op；\n（4）计算出结果；\n\n（5）结果入操作数栈；\n\n接下来，运算符和操作数才能继续入栈。下一个操作符要入栈时，继续比较与栈顶的优先级。\n栈内的优先级低，可以直接入栈。\n\n字符串继续移动。\n\n又要比较优先级了。\n\n栈内的优先级高，还是先计算（3*4&#x3D;12），再入栈。\n\n不断入栈，直到字符串扫描完毕。\n\n不断出栈，直到得到最终结果3+60&#x3D;63，算法完成。\n总结\n“表达式求值”问题，两个核心关键点：\n（1）双栈，一个操作数栈，一个运算符栈；\n（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：如果栈顶的运算符优先级低，新运算符直接入栈\n如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈\n这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。\n运算符有+-&#x2F;()~^&amp;都没问题，如果共有n个运算符，会有一个nn的优先级表。\n正则表达式代码代码：\n上       代        码\n虽然但是接下来这个代码是中缀计算的\n#include &lt;iostream&gt;#include &lt;stack&gt;//stl库中使用栈#include &lt;string&gt;//#include &lt;unordered_map&gt;//一个目前不太懂的头文件，回头看primer自己理解吧using namespace std;stack&lt;int&gt; num;//存储数字的栈stack&lt;char&gt; op;//存储运算符的栈//优先级表unordered_map&lt;char, int&gt; h&#123; &#123;&#x27;+&#x27;, 1&#125;, &#123;&#x27;-&#x27;, 1&#125;, &#123;&#x27;*&#x27;,2&#125;, &#123;&#x27;/&#x27;, 2&#125; &#125;;void eval()//求值&#123;    int a = num.top();//第二个操作数    num.pop();    int b = num.top();//第一个操作数    num.pop();    char p = op.top();//运算符    op.pop();    int r = 0;//结果     //计算结果    if (p == &#x27;+&#x27;) r = b + a;    if (p == &#x27;-&#x27;) r = b - a;    if (p == &#x27;*&#x27;) r = b * a;    if (p == &#x27;/&#x27;) r = b / a;    num.push(r);//结果入栈到num中&#125;int main()&#123;    string s;//读入表达式    cin &gt;&gt; s;    for (int i = 0; i &lt; s.size(); i++)//调用了string的函数s.size()    &#123;        if (isdigit(s[i]))//判断数字入栈        &#123;            int x = 0, j = i;//计算数字            while (j &lt; s.size() &amp;&amp; isdigit(s[j]))            &#123;                x = x * 10 + s[j] - &#x27;0&#x27;;//将string型的数字转换为int？                j++;            &#125;            num.push(x);//数字入栈            i = j - 1;        &#125;        //左括号无优先级，直接入栈        else if (s[i] == &#x27;(&#x27;)//左括号入栈        &#123;            op.push(s[i]);        &#125;        //括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的        else if (s[i] == &#x27;)&#x27;)//右括号        &#123;            while(op.top() != &#x27;(&#x27;)//一直计算到左括号                eval();            op.pop();//左括号出栈        &#125;        else        &#123;            while (op.size() &amp;&amp; h[op.top()] &gt;= h[s[i]])//待入栈运算符优先级低，则先计算                eval();            op.push(s[i]);//操作符入栈        &#125;    &#125;    while (op.size()) eval();//剩余的进行计算    cout &lt;&lt; num.top() &lt;&lt; endl;//输出结果    return 0;&#125;\n\n单调栈（瞳孔地震型题解）😢使用单调递增栈\n麻烦地方：超时\n考虑方式有些类似双指针\n思路：暴力-&gt;优化暴力\n队列里面是否有元素没用\n\n#include&lt;iostream&gt;using namespace std;const int N=10010;int n;int stk[N],tt;int main()&#123;    cin&gt;&gt;n;//总共要输入几次数    for(int i=0;i&lt;n;i++)    &#123;        int x;        cin&gt;&gt;x;        while(tt&amp;&amp;stk[tt]&gt;=x)tt--;//如果栈内元素只要比待进入元素小就弹出        if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;//弹出后输出第一个栈顶元素        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;//栈空后输出-1        stk[++tt]=x;//一轮走下来以后新的元素入栈    &#125;    return 0;&#125;\n\n\n\n队列FIFO构造\n队列构造方式：数组构造（也是hin简单就是了）😒\n//模板用栈直接改都可以const int M=200600;int bottom=0;//队列底部，弹出时候bottom+1int line[M]=&#123;0&#125;;int top=0;//队列头部，增加时候top+1void insert(int x)//入队&#123;        line[top]=x;    ++top;&#125;void pop(void)&#123;    bottom++;//底部上移&#125;void query(void)&#123;   cout&lt;&lt;line[bottom]&lt;&lt;endl;   return;&#125;void empty(void)&#123;    if(top==bottom)cout&lt;&lt;&quot;YES\\n&quot;;    else cout&lt;&lt;&quot;NO\\n&quot;;    return;&#125;\n\n循环队列：模板：\n// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;//如果到达某一特定值那么就重置变成队头// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt)//不为空&#123;&#125;\n\n\n\n单调队列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）😶‍🌫️准备好开始头疼\n思路同单调栈：从暴力解决入手接着开始优化\n可以使用队列对窗口进行维护（标准的入列和出列）\n优化：队列中是否有没用的元素，对没用的元素进行删除看能否得到单调性，如3，-1，-3，在-3入列的时候就有3&gt;-3，则最小值一定不会是3而且-3存在时间更久，因此使用单调栈的同样原理可以求出单调最小，并且是一个单调递增的最小\n可以使用STL标准库来写或者说使用栈和队列数组模拟去写，而相对而言使用数组有很大的好处在于数组速度快，在比赛或者笔试时候会慢一些，在IDE中可能会有O2或者O3优化\n再看一遍单调栈\n#include&lt;iostream&gt;using namespace std;const int N=10010;int n;int stk[N],tt;int main()&#123;    cin&gt;&gt;n;//总共要输入几次数    for(int i=0;i&lt;n;i++)    &#123;        int x;        cin&gt;&gt;x;        while(tt&amp;&amp;stk[tt]&gt;=x)tt--;//如果栈内元素只要比待进入元素大就弹出        if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;//弹出后输出第一个栈顶元素        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;//栈空后输出-1        stk[++tt]=x;//一轮走下来以后新的元素入栈    &#125;    return 0;&#125;\n\n\n\n\n解题思路（以最大值为例）：\n由于我们需要求出的是滑动窗口的最大值。\n如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i&lt;j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：\n当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。\n因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。\n因此我们可以使用一个队列存储所有还没有被移除的下标，这里是q。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。\n当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。\n为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。\n由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。\n窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。\n每一个窗口的最大值\nhh = 0; tt = -1;          //头在左尾在右                         // 重置！    for (int i = 0; i &lt; n; ++ i)        //注意这个栈可以想成朝着右边（tt，正常栈操作），但是底部可以操作（hh，向右缩）    &#123;        //窗口终点是i，那么起点就是i-k+1        if (i - k + 1 &gt; q[hh]) ++ hh;//窗口左边向右移动一个                //这里操作下来要是从大到小的排列                while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;//右边已经有更大的了，之前的小的a[q[tt]]可以不用考虑了，就操作tt        q[++ tt] = i;//窗口右边向右移动一个        //i+1&gt;=k这里就是一个特判，因为一开始窗口没有值，只有窗口全部充满之后才有后面的操作        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);//这里知道栈的底部（也就是q[hh]）对应的下标是该窗口中没有删除而且是最大的    &#125;\n\n判断最小\nint a[N]=&#123;0&#125;;int q[N]=&#123;0&#125;;int hh=0;int tt = -1;//尾部是1int n, k;//hh是头，tt是尾，////头在左尾在右    cin &gt;&gt; n &gt;&gt; k;//k是窗口大小    for (int i = 0; i &lt; n; ++ i)    &#123;        //这里是关于窗口的维护        scanf(&quot;%d&quot;, &amp;a[i]);//数组a存放了所有的数字        if (i - k + 1 &gt; q[hh]) ++ hh;               //数组q存放的是下标        // 若队首出窗口，hh加1，即整体向前移动一格                //这里开始跟单调栈的原理相同        /*        hh&lt;=tt是队列不为空        a[i] &lt;= a[q[tt]]这里就是单调栈的如果新来的a[i]不是栈里面最大的就弹栈，--tt        */        while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1        q[++ tt] = i;                                  // 下标加到队尾，新元素入栈，上面入的是元素本身这里入的是元素下标                if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);       // 这里确定过栈中的都是最小的元素了因此直接输出        //输出结果    &#125;    cout &lt;&lt; endl;//换行\n\n\n\n全部代码！\n# include &lt;iostream&gt;using namespace std;const int N = 1000010;int a[N], q[N], tail = -1;int head=0;//a存储正常原数组的值//注意注意q存储的是a的“下标”，“下标”而不是“值”int main()&#123;    int n, k;//hh是头，tt是尾    cin &gt;&gt; n &gt;&gt; k;    for (int i = 0; i &lt; n; ++ i)//输出最小，每一次循环里面q[head]的值也就是a[q[head]]总是窗口中最小的    &#123;        //i-k+1就是窗口头部位置        scanf(&quot;%d&quot;, &amp;a[i]);        if (i - k + 1 &gt; q[head]) ++ head;                  // 若队首出窗口，head加1        while (head &lt;= tail &amp;&amp; a[i] &lt;= a[q[tail]]) -- tail;    // 若队尾不单调，tail持续减1        q[++ tail] = i;                                  // 下标加到队尾,尾部进入窗口        if (i-k + 1 &gt;= 0) printf(&quot;%d &quot;, a[q[head]]);       // 输出结果(只有窗口形成之后才会输出)    &#125;    cout &lt;&lt; endl;    head = 0; tail = -1;                                   // 重置！    for (int i = 0; i &lt; n; ++ i)    &#123;        if (i - k + 1 &gt; q[head]) ++ head;\t\t\t\t//判断头部是否出窗口        while (head &lt;= tail &amp;&amp; a[i] &gt;= a[q[tail]]) -- tail;        q[++ tail] = i;        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[head]]);    &#125;    return 0;&#125;\n\n\n\n串KMP(100条消息) 数据结构KMP算法配图详解（超详细）_哈顿之光的博客-CSDN博客_kmp算法难吗是什么级别（好好看好好学）\n模板y总注意kmp算法的下标要从1开始弄！\nfor(int i=1;i&lt;=n;i++)//一开始就是1开始弄的&#123;    cin&gt;&gt;p[i];&#125;或者邪教读取法:cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )//与匹配部分基本一样一样&#123;//一点细节，这里是子串p    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];//也是回溯    if (p[i] == p[j + 1]) j ++ ;//匹配成功子串向前走    ne[i] = j;//欸，这里不一样了，    //ne数组其实也是一样样的，i=2是因为实际上1是肯定是0（前面都没字符自然是0），ne数组也是从1开始&#125;// kmp匹配for (int i = 1, j = 0; i &lt;= n; i ++ )//&#123;//一点细节，下面是长串s    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];//不相等的时候递归回退，与代码随想录是一种方法    if (s[i] == p[j + 1]) j ++ ;//如果匹配成功，子串也向前一位走    if (j == m)    &#123;        j = ne[j];//回溯到前一次        // 匹配成功后的逻辑    &#125;&#125;\n\n#include&lt;iostream&gt;using namespace std;const int N=100010,M=1000010;char p[N],s[M];int ne[N];int n,m;int main()&#123;\tcin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;\tfor(int i=2,j=0;i&lt;=n;i++)\t&#123;\t\twhile(j&amp;&amp;p[i]!=p[j+1])j=ne[j];\t\tif(p[i]==p[j+1])j++;\t\tne[i]=j;\t&#125;\tfor(int i=1,j=0;i&lt;=m;i++)\t&#123;\t\twhile(j&amp;&amp;s[i]!=p[j+1])j=ne[j];\t\tif(s[i]==p[j+1])j++;\t\tif(j==n)\t\t&#123;\t\t\tcout&lt;&lt;i-n&lt;&lt;&#x27; &#x27;;//就是输出下标\t\t\tj=ne[j];\t\t&#125;\t&#125;\treturn 0;&#125;\n\n关键：特殊数组next的构造，前缀表\n\n下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了\n前缀表：字符串的最长前缀：不包含尾字符的所有子串\n后缀：相较于前缀，不包含首字母的所有子串\n因此如果仅有单个字符则其前缀为0\n特性：\n目前讲解的构造方法\n例：子串aabaabaaf，前缀表010120(aabaaf)\n\n前缀形式：010120\n全部后移方式：-1 0 10120\n整体减一方式：-1 0 -1 0 1 -1\n\n共同点：最后都应当保持封闭，虽然理解有出入但本质相同\n代码随想录方法：前缀不减形式prev,latter;\nprev:前缀末尾位置，同时代表prev包括prev之前子串最长相等前后缀的长度，也表示前缀末尾\nlatter:后缀末尾位置\n初始化\nprev=0;latter=1;next[0]=0;//初始化latter\n\n开始处理前后缀不同情况\n//prev和latter一直不相等for(latter=1;latter&lt;slength;latter++)//后缀指针只管往前走就完事&#123;    //这里if是出错的根源    while(s[prev]!=s[latter]&amp;&amp;prev&gt;0)//注意这里因为有-1存在所以一定小心越界，    &#123;        prev=next[prev-1];//prev冲突时候是一个连续回退的过程，如果使用if就错了，使用while循环回退    &#125;    //只要s[latter]!=s[prev]时候prev应该向前回退    //原因：使用前缀表在进行kmp对比的时候如果遇到冲突，也是看冲突位置前一位的表进行跳转        分界线：前后缀相同的情况        if(s[prev]==s[latter])        &#123;            prev++;//代表prev之前最长相等前缀可以更新                      //latter因为有for循环，因此自然向前有++操作        &#125;    \t next[latter]=prev;//更新next数组的值        &#125;\n\n这里则是全部操作的部分\n    void getNext(int* next, const string&amp; s) &#123;        int j = 0;        next[0] = 0;        for(int i = 1; i &lt; s.size(); i++) &#123;            while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123;                j = next[j - 1];            &#125;            if (s[i] == s[j]) &#123;                j++;            &#125;            next[i] = j;        &#125;    &#125;//这里是返回第一个找到的下标    int strStr(string haystack, string needle) &#123;        if (needle.size() == 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);//获取next数组        int j = 0;        for (int i = 0; i &lt; haystack.size(); i++) &#123;            while(j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;                j = next[j - 1];//一样进行回溯            &#125;            if (haystack[i] == needle[j]) &#123;                j++;            &#125;//使用循环，直接对prev进行+就行            if (j == needle.size() ) &#123;                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;\n\n\n注意这里是文本串和模式串不匹配时候的操作（这里next数组采用正常前缀表）\n数据结构作业出错原因要求每一个都求出来\n问题在于：当每一次满足条件后进行清零操作，本质上同一次两者不等时候的回溯操作（prev到上一位最接近的前缀位置）,如果使用prev&#x3D;0就会出现可能错过\n例：    ababa  aba 001    //正确解    if(prev==sublength)        &#123;            cout&lt;&lt;endl&lt;&lt;latter-sublength+1&lt;&lt;endl;            prev=next[prev-1];//回溯        &#125;\t//在第一次解的时候prev=3;latter=2(因为latter在一次循环之后才会有增操作)\t/*\t使用回溯prev=1,sub[prev]=b那么就接着从latter=3.T[latter]=b无缝开始向前对比\t*//错误    if(prev==sublength)        &#123;            cout&lt;&lt;endl&lt;&lt;latter-sublength+1&lt;&lt;endl;            prev=0;//这样就会是错误结果        &#125;\n\n\n\nautomata~有限状态自动机参考：\n\n(100条消息) 字符串匹配算法之：有限状态自动机_tyler_download的博客-CSDN博客_有限自动机算法\n苏老师坚果云ppt状态机代码部分\n\n代码（构建自动机状态表）dfa[0][P[0]] = 1; //初始化第一行// dfa[状态][下一个字符] for(int X = 0, j = 1; j &lt; plen; j++) &#123;// 计算 dfa[j][]for(int c = 0; c &lt; R; c++) &#123; // R 为字符种类数量dfa[j][c] = dfa[X][c];&#125; dfa[j][P[j]] = j + 1; X = dfa[X][P[j]]&#125;\n\n\n\n聪明版本自动机已知ascii码总共就128个，直接开一个大表就行\nint dfa[256][256]=0;//这样直接省略后续一系列初始化，使用int转换字符串传入就行，非常省心\n\nTRIE树（有些类似哈夫曼树编码）类似但和哈夫曼树没有关系\n又称字典树、单词查找树\n应用：快速存储和查找字符串集合的数据结构\n如何存储：构建串树从根节点开始存储每一个字符，开始逐个向下进行创建，在单词的末尾打上一个标记表示该单词走到结尾了\n\n\nTRIE树本质是一颗N叉树，有多少种字符一个节点就最多有多少条边\n\n如何查找从单词的首字母开始向下走，走到标记表示到头了\n构建TRIE树这里使用了数组模拟树的知识\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26];//这里是26因为只有小写字母//二维是可以有多少个分支，一维的意义是来自哪一个双亲节点int cnt[N], idx;//idx是下标为0的点，是根节点和空节点，表示当前要插入的节点是第几个,每创建一个节点值+1   // cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）char str[N];//存储要插入/查询的单词void insert(char *str)&#123;    int p = 0; //类似指针，指向当前节点    for (int i = 0; str[i]; i ++ )    &#123;        int u = str[i] - &#x27;a&#x27;;//u表示是具体哪一个字母        //p表示的是第几个结点，u表示的是哪个字母，如果s[p][u]不为空就证明有以这个字母为值的子结点        //它代表的值就是指向了该子结点，即说明了第几个结点是它的子结点         //如s[2][1]=3，表示结点2有一个值为b（第二个数字代表的是a～z）的子结点，是结点3        if (!son[p][u]) son[p][u] = ++ idx;//不存在就创建节点        //令p指向子结点        p = son[p][u];    &#125;    //不管是未存在过的新插入还是已有字典再增加一个，都是以这个结点为末尾的字符串次数加1    cnt[p] ++ ;//结束时的标记，也是记录以此节点结束的字符串个数    //这一步重要！        &#125;int query(char *str)&#123;    int p = 0;    for (int i = 0; str[i]; i ++ )//走到该单词为0    &#123;        int u = str[i] - &#x27;a&#x27;;//获得对应子节点的编号        if (!son[p][u]) return 0;        p = son[p][u];    &#125;    return cnt[p];//返回以p为结尾的单词数量&#125;int main()//这里有I是插入字符串，其它是查找该字符串&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[2];        scanf(&quot;%s%s&quot;, op, str);//前一次输入被覆盖        if (*op == &#x27;I&#x27;) insert(str);        else printf(&quot;%d\\n&quot;, query(str));    &#125;    return 0;&#125;\n\nTRIE树的其它应用https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF\n启示：字典树不单单可以高效存储和查找字符串集合，还可以存储二进制数字\n思路：利用二叉树对所有的aiaj建立一个串数组，对于每一个固定的ai，每一次尽量与和当前不同的分支向下走，走到底这样一定就可以得到最优解\n即顺序：所有值的二进制表示建立树-&gt;遍历一次，每一个ai进行寻找对应的最大的值，最后遍历一次之后获得答案\n算法复杂度：（建立树）+n（每一个ai只需要在已经建立好的树再从头到尾走一次就好）\n代码：insert函数改：\n每个数看作一个31位长度的二进制数，最高位是0往0走，最高位1往1走，然后和类似TRIE的操作，但是构建的是一颗二叉树（一定概率变成斜树）\nvoid insert(int x)&#123;    int p=0;  //根节点    for(int i=30;i&gt;=0;i--)//从最大位开始建立    &#123;        int u=x&gt;&gt;i&amp;1;   /////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)        if(!son[p][u]) son[p][u]=++idx; ///如果插入中发现没有该子节点,开出这条路        p=son[p][u]; //指针指向下一层    &#125;//与上面不一样这里就不需要标记&#125;\n\nint search(int x)&#123;    int p=0;int res=0;    for(int i=30;i&gt;=0;i--)    &#123;                               ///从最大位开始找        int u=x&gt;&gt;i&amp;1;        if(son[p][!u]) ////如果当前层有对应的不相同的数        &#123;   ///p指针就指到不同数的地址          p=son[p][!u];          res=res*2+1;//右移，因为树右儿子是1             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001        &#125;                                                   ///       010         else////   ---&gt;011                                                                                       //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1        &#123;            p=son[p][u];            res=res*2+0;//左移，因为树左儿子是1        &#125;    &#125;    return res;&#125;\n\n#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int const N=100010,M=31*N;//M表示树的节点个数，每个数最多有31个长度，因此建立int n;int a[N];int son[M][2],idx;//M代表一个数字串二进制可以到多长void insert(int x)&#123;    int p=0;  //根节点    for(int i=30;i&gt;=0;i--)//这里相等i&gt;=0    &#123;        int u=x&gt;&gt;i&amp;1;   /////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)        if(!son[p][u]) son[p][u]=++idx; ///如果插入中发现没有该子节点,开出这条路        p=son[p][u]; //指针指向下一层    &#125;&#125;int search(int x)&#123;    int p=0;int res=0;    for(int i=30;i&gt;=0;i--)    &#123;                               ///从最大位开始找        int u=x&gt;&gt;i&amp;1;        if(son[p][!u]) ////如果当前层有对应的不相同的数        &#123;   ///p指针就指到不同数的地址          p=son[p][!u];          res=res*2+1;             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001        &#125;                                                       ///       010         else                                            ////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1        &#123;            p=son[p][u];            res=res*2+0;        &#125;    &#125;    return res;//最后返回是十进制形态的答案&#125;int main(void)&#123;    cin&gt;&gt;n;    idx=0;    for(int i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;a[i];        insert(a[i]);    &#125;    int res=0;    for(int i=0;i&lt;n;i++)    &#123;           res=max(res,search(a[i]));  ///search(a[i])查找的是a[i]值的最大与或值    &#125;    cout&lt;&lt;res&lt;&lt;endl;&#125;\n\n\n\n跳表——同样面试——但是不用手搓一些参考的博客：(101条消息) 十分钟弄懂什么是跳表，不懂可以来打我_愤怒的可乐的博客-CSDN博客_跳表\n优点：将链表查找的时间复杂度改造成log，据说可以取代红黑树\n跳表属于对链表的改进\n有点相似kmp？通过一些手段加快跳跃的速度\n想法：链表中增加一些“超级链接”\n特点：\n跳表结合了链表和二分查找的思想\n由原始链表和一些通过“跳跃”生成的链表组成\n第0层是原始链表，越上层“跳跃”的越高，元素越少\n上层链表是下层链表的子序列\n查找时从顶层向下，不断缩小搜索范围\n每一层增长哪一个节点实际上是随机生长的\n\n核心思想：\n跳表节点中用数组存储不同层级的下一个节点\n随即生长\n空间使用率最高的跳表\n\n实现构建过程：初始化和单链表一样，仅有一个空节点，\nprivate class Node &#123;    //保存值    E data;    //保存了每一层上的节点信息，可能为null    List&lt;Node&gt; forwards;    Node(E data) &#123;        this.data = data;        forwards = new ArrayList&lt;&gt;();        //事先把每一层都置为null，虽然空间利用率没那么高，但是简化了实现        //也可以通过自定义列表(比如B树实现中用到的Vector)来实现，就可以不用下面的操作        for (int i = 0; i &lt;= maxLevel; i++) &#123;            forwards.add(null);        &#125;    &#125;    @Override    public String toString() &#123;        return data == null ? &quot; &quot; : &quot;&quot; + data;    &#125;    /**     * 得到当前节点level层上的下一个(右边一个)节点     *     * @param level     * @return     */    Node next(int level) &#123;        return this.forwards.get(level);    &#125;&#125;\n\nTRIE树的其它散列表——哈希表-面试很重要特点：查找与删除，查找全部在常数时间内完成\n应用：\n\n操作系统\n数据库\n编译器\n计网\n图像检索（最初始用于人脸识别等）\n\n线性表总结：\n哈希定义，应用本质：给定一个输入给出一个唯一的序列号输出，将一个比较大的空间映射到一个比较小的空间，将一个复杂的数据结构映射到一个小的\n应用举例： \n\n输入n个数10^5，数的范围+-10^9,选择一些数字插入，选择另外一些数字查询\n文本压缩和解压缩\n\n定位的过程：元素通过哈希函数转换成唯一的整数（必须快速计算）\n第一步：将一个元素映射成一个整数\n哈希模板（正常+字符串版本）(1) 拉链法    int h[N], e[N], ne[N], idx;\tconst int  N=1e5+3;    // 向哈希表中插入一个数    void insert(int x)//这么理解：就是正常的数组模拟链表，但是加入哈希函数    &#123;        int k = (x % N + N) % N;        e[idx] = x;        ne[idx] = h[k];//就是把head换成了h[k],因为原先是单链，现在多链        h[k] = idx ++ ;    &#125;    // 在哈希表中查询某个数是否存在    bool find(int x)    &#123;        int k = (x % N + N) % N;//首先哈希        for (int i = h[k]; i != -1; i = ne[i])            &#123;if (e[i] == x)                return true;&#125;        return false;    &#125;(2) 开放寻址法    const int N=2e5+3;//开放寻址的大小要放大的    int h[N];\tconst int null=0x3f3f3f3f;    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置    int find(int x)    &#123;        int t = (x % N + N) % N;        while (h[t] != null &amp;&amp; h[t] != x)//这里易错，是&amp;&amp;        &#123;            t ++ ;            if (t == N) t = 0;        &#125;        return t;    &#125;\n\n核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ )&#123;    h[i] = h[i - 1] * P + str[i];    p[i] = p[i - 1] * P;&#125;// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;\n\n\n\n分配索引值这里对字符进行处理，每一种字符都视为一种对应的数字，不同的位数有不同的加权值\nunsigned int hash(char *key)&#123; unsigned int hash_val = 0; while(*key != &#x27;\\0&#x27;)  &#123; hash_val = (hash_val &lt;&lt; 5) + *key++;//这里使用&lt;&lt;实际上就是直接×2^5  //每一次移动5位（这样子硬件便于实现，参考计组）&#125; return hash_val;&#125;\n\n缺点：虽然时间非常高效，但是空间浪费非常大（毕竟不能载满）\n减少索引值：方法1：忽略一部分元素，将另一部分直接视为索引值\n好处：快，坏处：难于分配索引值\n方法2：折叠，使用不同方式将原数据拆分，再合并在一起\n方法3：余数运算，可以元素值除以某一特殊数字，余数用作索引值，\nunsigned int hash(char *key, unsigned int H_SIZE) &#123; unsigned int hash_val = 0; while(*key != &#x27;\\0&#x27;) &#123; hash_val = (hash_val &lt;&lt; 5) + *key++;&#125; return hash_val % H_SIZE;//这里缩了一下&#125;\n\n\n\n字符串哈希——&gt;字符串前缀哈希法作用有些类似kmp，字符串也可以用哈希表做-&gt;一个集合到另一个集合的映射\n实际上是字符串的前缀哈希法，对前缀进行哈希\n问题：\n\n如何定义某一个前缀的哈希值，可以将字符串视为p进制的一个数，每一位上的字母（acscii）视为对应的数字，但是不能映射成0-&gt;相同的字符串映射结果会相同-&gt;AA等等\n哈希字符串假定人品足够不存在碰撞，没有考虑冲突情况，经验值：p取131或13331时候，q取2^64，几乎99%情况不会出现冲突\n\n好处：可以利用最前的哈希计算出所有子串的哈希，\n已知h[r],h[l],\nh[r]中r为第0位，h[l-1]中l-2为第0位\n操作\n\nh[l-1]与h[r]对齐，即向后移动多少位\nh[r]-h[l-1]就能求出来了\n\n小技巧：使用unsigned long long 存储所有h，相当于对所有数取模了(因为溢出就相当于取模)\n总结：左移高位对齐\n之后对前缀全部处理完之后，就能用o1时间计算任意子串哈希值\n预处理：h[i]&#x3D;h[i-1]*p+str[i] (第i位字母)\n牛逼的地方：比kmp牛逼：可以快速判断，快过o(n),是处理字符串的利器\n代码核心部分：\ntypedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ )&#123;    h[i] = h[i - 1] * P + str[i];    p[i] = p[i - 1] * P;&#125;// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;\n\n完整代码：\n841. 字符串哈希 - AcWing题库\nAcWing 841. 字符串哈希 【公式助理解】 - AcWing\n\n#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;typedef unsigned long long ULL;//也就是取模2^64，const int N = 1e5+5,P = 131;//131 13331ULL h[N],p[N];// h[i]前i个字符的hash值// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突// 使用场景： 两个字符串的子串是否相同ULL query(int l,int r)&#123;    return h[r] - h[l-1]*p[r-l+1];    //为求l到r的哈希值    //已知h[r],h[l-1]，也就是1到l-1，1到r的哈希值    //因为字符串视为一个p进制的数，因此越左边权重越高，为高位，右边是低位    //h[r]中r是第0位，h[1]为r-1位    //h[l-1]l-1是第0位，h[1]为l-2位    //两者相差r-1-l+2=r-l+1位    //本质就是高位对齐，h[r]与h[l-1]对齐，&#125;int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    string x;    cin&gt;&gt;x;    //字符串从1开始编号，h[1]为前一个字符的哈希值    p[0] = 1;    h[0] = 0;    //以上是初始化，第0位实际上不加入计算    for(int i=0;i&lt;n;i++)&#123;        p[i+1] = p[i]*P;                    h[i+1] = h[i]*P +x[i];      //前缀和求整个字符串的哈希值        //这里x也是从第一位开始，也就是0    &#125;    while(m--)&#123;        int l1,r1,l2,r2;        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;        if(query(l1,r1) == query(l2,r2)) printf(&quot;Yes\\n&quot;);        else printf(&quot;No\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n哈希碰撞处理（面试高频）😍😍😍😍😍可以把离散化看成一种特殊的哈希方式\n哈希表属于期望算法，可以将哈希表的链长视为一个常数，\n碰撞：两个相同的索引放在相同的索引位置\n碰撞可能性很大-&gt;定义域很大值域比较小\n拉链法（Open Hashing）原理：如果多个索引值最终哈希值相同，使用链表的形式另外存储相同的值\n添加，直接添加链\n查找：对应位置在链表遍历一下\n删除：算法题中一般不会进行删除节点，而是会开 一个数组打一个标记（如bool标记）\n数学上取质数，而且举例2的幂尽可能远冲突概率最小\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 3;  // 取大于1e5的第一个质数，而且要离2的整次幂尽可能远， 取质数冲突的概率最小//* 开一个槽 h//图论中存点的方式和数组的链法一样，都是一个数组一个链int h[N], //哈希表//经典数组实现链表e[N], ne[N], idx;  //邻接表void insert(int x) &#123;    // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数    int k = (x % N + N) % N;//k就是对应的哈希值，这一步实现了映射。接下来是写入    //(x%N+N)这一步为了最后一定是一个正数，如果是负数数组无法写入    e[idx] = x;    ne[idx] = h[k];    h[k] = idx++;&#125;bool find(int x) &#123;    //用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i]) &#123;//这里是遍历对应到的链表        //同时由于初始化是-1，开始哈希数组也要初始化为-1        if (e[i] == x) &#123;            return true;        &#125;    &#125;    return false;&#125;int n;int main() &#123;    cin &gt;&gt; n;    memset(h, -1, sizeof h);  //将槽先清空 空指针一般用 -1 来表示    //    while (n--) &#123;        string op;//字符串的话编译器会自动忽略空格，换行符等，不容易出错        //有些脏数据会增加额外空格        int x;        cin &gt;&gt; op &gt;&gt; x;        if (op == &quot;I&quot;) &#123;            insert(x);        &#125; else &#123;            if (find(x)) &#123;                puts(&quot;Yes&quot;);            &#125; else &#123;                puts(&quot;No&quot;);            &#125;        &#125;    &#125;    return 0;&#125;\n\n缺点：消耗空间\n开放地址法 Open Addressing思路：只用一个一维数组来模拟哈希表，因此形式会相对简洁，但是一般来说一维数组的长度应该是需要的数组大小的2~3倍，\n类似数组模拟链表的方式，将数据存储在空余空间中，想象上厕所，一个坑位完了就下一个\n探测方法：\n\n线性探测\n\n缺点：费时间，元素容易聚集，分布不均匀，聚集越多性能越差\n\n平方探测\n\n避免了元素的聚集，如果顺序表长度为指数，顺序表空位多于一半，平方探测总能插入新元素\n\n伪随机探测\n\n代码\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了const int N = 2e5 + 3;        //大于数据范围的第一个质数const int null = 0x3f3f3f3f;  //规定空指针为 null 0x3f3f3f3f//这个数只要不在原本数据范围内就行int h[N];int find(int x) &#123;//这一个函数同时实现查找和插入功能    int t = (x % N + N) % N;    while (h[t] != null &amp;&amp; h[t] != x) &#123;        t++;//这一步是线性探测，可以使用平方或者伪随机优化        if (t == N) &#123;//如果到头了，就返回从头找            t = 0;        &#125;    &#125;    return t;  //如果这个位置是空的, 则返回的是他应该存储的位置&#125;int n;int main() &#123;    cin &gt;&gt; n;    memset(h, 0x3f, sizeof h);  //规定空指针为 0x3f3f3f3f    while (n--) &#123;        string op;        int x;        cin &gt;&gt; op &gt;&gt; x;        if (op == &quot;I&quot;) &#123;            h[find(x)] = x;//妙啊        &#125; else &#123;            if (h[find(x)] == null) &#123;                puts(&quot;No&quot;);            &#125; else &#123;                puts(&quot;Yes&quot;);            &#125;        &#125;    &#125;    return 0;&#125;\n\n\n\n杜鹃哈希😎感觉：拆东墙补西墙，但是很牛逼\n优点：只要两个表中间有元素，一定可以通过哈希函数在顺序表中直接找到不用探测，非常高效\n原因：所有索引位置都是哈希函数得到\n失败时：\n没有足够空间，路径无限循环\n转移链表过长\n\n缺点：元素过多时候插入元素困难\n(101条消息) 杜鹃散列_EmberWn的博客-CSDN博客_杜鹃散列\n【散列】杜鹃散列详情与C++实现代码 - awst_lee - 博客园 (cnblogs.com)\nCuckoo hash算法分析 - 可酷可乐 - 博客园 (cnblogs.com)\nCuckoo hashing - Wikipedia（科学上网看）\n杜鹃哈希举例：\n坏消息：根本看不懂\n好消息：不用看了\n//为杜鹃散列生成泛型HashFamily接口,用来发出多簇散列函数到杜鹃散列表template&lt;typename AnyType&gt;class CuckooHashFamily &#123;public:\tsize_t hash(const AnyType&amp; x, int which)const;\tint getNumberOfFunctions();\tvoid generateNewFunctions();&#125;; /*** 杜鹃散列法的非正式字符串散列*/template&lt;int count&gt;class StringHashFamily &#123;private:\tstd::vector&lt;int&gt; MULTIPLIERS;\tUniformRandom r; public:\tStringHashFamily() :MULTIPLIERS(count) &#123;\t\tgenerateNewFuntions();\t&#125;\tint getNumberOfFunctions()const &#123;\t\treturn count;\t&#125;\tvoid generateNewFuntions() &#123;\t\tfor (auto&amp; mult : MULTIPLIERS)\t\t\tmult = r.nextInt();\t&#125; \tsize_t hash(const string&amp; x, int which)const &#123;\t\tconst int multiplier = MULTIPLIERS[which];\t\tsize_t hashVal = 0;\t\tfor (auto ch : x)\t\t\thashVal = multiplier * hashVal + ch;\t\treturn hashVal;\t&#125;&#125;; //杜鹃散列类接口，允许(由HashFamily模板参数类型指定)任意个数的散列函数template&lt;typename AnyType, typename HashFamily&gt;class HashTable &#123;private:\tstruct HashEntry &#123;\t\tAnyType element;\t\tbool isActive; \t\tHashEntry(const AnyType&amp;e=AnyType(),bool a=false)\t\t\t:element&#123;e&#125;,isActive&#123;a&#125;&#123;&#125;\t\tHashEntry(AnyType&amp;&amp;e,bool a=false)\t\t\t:element&#123;std::move(e)&#125;,isActive&#123;a&#125;&#123;&#125;\t&#125;; \t/**\t* 杜鹃散列的插入例程使用不同的算法，\t* 该算法随机选择要逐出的项，\t* 但不再试图重新逐出最后的项。\t* 如果存在太多的逐出项则散列表将尝试选取新的散列函数(再散列)，\t* 而若有太多的再散列则散列表将扩张\t*/\tbool insertHelper1(const AnyType&amp; xx) &#123;\t\tconst int COUNT_LIMIT = 100;\t\tAnyType x = xx; \t\twhile (true) &#123;\t\t\tint lastPos = -1;\t\t\tint pos; \t\t\tfor (int count = 0; count &lt; COUNT_LIMIT; ++count) &#123;\t\t\t\tfor (int i = 0; i &lt; numHashFunctions; ++i)\t\t\t\t\tpos = myhash(x, i);\t\t\t\t\t\t\t\t\tif (!isActive(pos)) &#123;\t\t\t\t\tarray[pos] = std::move(HashEntry&#123; std::move(x),true &#125;);\t\t\t\t\t++currentSize;\t\t\t\t\treturn true;\t\t\t\t&#125;\t\t\t&#125; \t\t\t//无可用位置，逐出一个随机项\t\t\tint i = 0;\t\t\tdo &#123;\t\t\t\tpos = myhash(x, r.nextInt(numHashFunctions));\t\t\t&#125; while (pos == lastPos &amp;&amp; i++ &lt; 5); \t\t\tlastPos = pos;\t\t\tstd::swap(x, array[pos].element);\t\t&#125; \t\tif (++rehashes &gt; ALLOWED_REHASHES) &#123;\t\t\texpand();\t\t//使散列表扩大\t\t\trehashes = 0;\t//重置rehashes的计数\t\t&#125;\t\telse\t\t\trehash();\t\t//表大小相同，散列函数都是新的\t&#125;\tbool insertHelper1(AnyType&amp;&amp; x) &#123;\t\tconst int COUNT_LIMIT = 100; \t\twhile (true) &#123;\t\t\tint lastPos = -1;\t\t\tint pos; \t\t\tfor (int count = 0; count &lt; COUNT_LIMIT; ++count) &#123;\t\t\t\tfor (int i = 0; i &lt; numHashFunctions; ++i)\t\t\t\t\tpos = myhash(x, i); \t\t\t\tif (!isActive(pos)) &#123;\t\t\t\t\tarray[pos] = std::move(HashEntry&#123; std::move(x),true &#125;);\t\t\t\t\t++currentSize;\t\t\t\t\treturn true;\t\t\t\t&#125;\t\t\t&#125; \t\t\t//无可用位置，逐出一个随机项\t\t\tint i = 0;\t\t\tdo &#123;\t\t\t\tpos = myhash(x, r.nextInt(numHashFunctions));\t\t\t&#125; while (pos == lastPos &amp;&amp; i++ &lt; 5); \t\t\tlastPos = pos;\t\t\tstd::swap(x, array[pos].element);\t\t&#125; \t\tif (++rehashes &gt; ALLOWED_REHASHES) &#123;\t\t\texpand();\t\t//使散列表扩大\t\t\trehashes = 0;\t//重置rehashes的计数\t\t&#125;\t\telse\t\t\trehash();\t\t//表大小相同，散列函数都是新的\t&#125;\tbool isActive(int currentPos)const &#123;\t\treturn currentPos != -1 &amp;&amp; array[currentPos].isActive;\t&#125; \t/**\t* 使用特定函数计算x的散列代码\t* 选取适当的散列函数，然后把它换算成合法的数组下标\t*/\tsize_t myhash(const AnyType&amp; x, int which)const &#123;\t\treturn hashFunctions.hash(x, which) % array.size();\t&#125; \t/**\t* 查找所有散列函数的位置\t* 返回查阅所有的散列函数以返回包含项x的下标，若找不到则返回-1\t*/\tint findPos(const AnyType&amp; x)const &#123;\t\tfor (int i = 0; i &lt; numHashFunctions; ++i) &#123;\t\t\tint pos = myhash(x, i); \t\t\tif (isActive(pos) &amp;&amp; array[pos].element == x)\t\t\t\treturn pos;\t\t&#125;\t\treturn -1;\t&#125; \t/**\t* 创建一个大数组但使用那些相同的散列函数\t*/\tvoid expand() &#123;\t\trehash(static_cast&lt;int&gt;(array.size() / MAX_LOAD));\t&#125; \t/**\t* 保留数组的大小不变，创建一个新的数组\t* 该数组使用那些新选出的散列函数填充\t*/\tvoid rehash() &#123;\t\thashFunctions.generateNewFuntions();\t\trehash(array.size());\t&#125; \tvoid rehash(int newSize) &#123;\t\tstd::vector&lt;HashEntry&gt; oldArray = array; \t\t//创建新的双倍大小的空散列表\t\tarray.resize(nextPrime(newSize));\t\tfor (auto&amp; entry : array)\t\t\tentry.isActive = false; \t\t//复制整个表\t\tcurrentSize = 0;\t\tfor (auto&amp; entry : oldArray)\t\t\tif (entry.isActive)\t\t\t\tinsert(std::move(entry.element));\t&#125; \tconstexpr static const double MAX_LOAD=0.4; //最大装填因子\tstatic const int ALLOWED_REHASHES = 5; //最大散列次数 \tvector&lt;HashEntry&gt;array;\tint currentSize;\tint numHashFunctions;\tint rehashes;\tUniformRandom r;\tHashFamily hashFunctions; public:\texplicit HashTable(int size = 101) :array(nextPrime(size)) &#123;\t\tnumHashFunctions = hashFunctions.getNumberOfFunctions();\t\trehashes = 0;\t\tmakeEmpty();\t&#125; \t//清空杜鹃散列表\tvoid makeEmpty() &#123;\t\tcurrentSize = 0;\t\tfor (auto&amp; entry : array)\t\t\tentry.isActive = false;\t&#125; \t/**\t* 搜索杜鹃散列表的例程\t* 如果找到x则返回true\t*/\tbool contains(const AnyType&amp; x)const &#123;\t\treturn findPos(x) != -1;\t&#125; \t/**\t* 从散列表中删除x\t* 若项x被找到且被删除则返回true\t*/\tbool remove(const AnyType&amp; x) &#123;\t\tint currentPos = findPos(x);\t\tif (!isActive(currentPos))\t\t\treturn false; \t\tarray[currentPos].isActive = false;\t\t--currentSize;\t\treturn true;\t&#125; \t//杜鹃散列表中公有插入方法\tbool insert(const AnyType&amp; x) &#123;\t\tif (contains(x))\t\t\treturn false; \t\tif (currentSize &gt;= array.size() * MAX_LOAD)\t\t\texpand();  \t\treturn insertHelper1(x);\t&#125;\tbool insert(AnyType&amp;&amp; x) &#123;\t\tif (contains(x))\t\t\treturn false; \t\tif (currentSize &gt;= array.size() * MAX_LOAD)\t\t\texpand();  \t\treturn insertHelper1(std::move(x));\t&#125; \tint size() const\t&#123;\t\treturn currentSize;\t&#125; \tint capacity() const\t&#123;\t\treturn array.size();\t&#125;&#125;;\n\n树最后通过看大神的代码才恍然大悟，二叉树的建立，需要按照一棵满二叉树来建立\n问题来了，我们的节点不够满二叉树的，这就是关键，空节点也需要补上！\n使用数组构造一棵二叉树也是同理！\n完全二叉树的构建（0作为空节点，会有空间浪费）#include&lt;iostream&gt;using namespace std;const int M=1010;//完全二叉树int tree[M]=&#123;0&#125;;//全部初始化成0方便判断int judge=1;//判断是否继续读入int real_depth(int n)&#123;    int ans=0;    while(n!=0)    &#123;        ans++;        n=n/2;    &#125;    return ans;&#125;void DLR(int i)//&#123;    if(tree[i]!=0)    &#123;        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;        DLR(i*2);        DLR(i*2+1);    &#125;&#125;void LDR(int i)//中序遍历&#123;    if(tree[i]!=0)    &#123;                DLR(i*2);        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;        DLR(i*2+1);    &#125;&#125;void LRD(int i)//后序遍历&#123;    if(tree[i]!=0)    &#123;        DLR(i*2);        DLR(i*2+1);        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;    &#125;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    int node_num=1;    for(int j=0;j&lt;n;j++ )//计数是第几组    &#123;        int node;        cin&gt;&gt;node;        tree[1]=node;        int i=1;        if(node==0||node==-1)continue;        while(judge==1)        &#123;            cin&gt;&gt; node;            //cout&lt;&lt;&quot;node:  &quot;&lt;&lt;node&lt;&lt;endl;            ++i;            //cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;endl;            if(node==-1)//实现了深度搞定，接下来是前序遍历            &#123;                cout&lt;&lt;real_depth(i-1) &lt;&lt;&quot; &quot;;                break;            &#125;            else            &#123;                if(tree[i/2]!=0)                &#123;                    tree[i]=node;                &#125;                if(tree[i/2]==0)                &#123;                    while(tree[i/2]==0)i=i/2;//回退到上层节点是有数字                    i=i/2;                    //cout&lt;&lt;&quot;back: &quot;&lt;&lt;i&lt;&lt;endl;                    while(tree[i*2])i=i*2;                    i=i*2;                    //cout&lt;&lt;&quot;go: &quot;&lt;&lt;i&lt;&lt;endl;                    tree[i]=node;                &#125;            &#125;            node_num=i;        &#125;        DLR(1);//完全二叉树记得要从节点1开始，也就是初始的节点       cout&lt;&lt;endl;       for(int i=1;i&lt;=node_num;i++)       &#123;           tree[i]=0;//清零       &#125;    &#125;&#125;\n\n树的恢复(105条消息) 先序遍历中序遍历还原二叉树_May Hacker的博客-CSDN博客_先序遍历中序遍历还原树\n由先序和中序恢复二叉树理论基础：\n105. 从前序与中序遍历序列构造二叉树 - 力扣（Leetcode）\n背也要背会的模板:[(105条消息) 根据先序中序还原二叉树_BugMaker-shen的博客-CSDN博客_由先序和中序恢复二叉树](https://blog.csdn.net/qq_42500831/article/details/105984986?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=先序 + 中序 恢复二叉树&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-0-105984986.142^v63^control,201^v3^control_1,213^v2^t3_control1&amp;spm&#x3D;1018.2226.3001.4187)\n原理：使用递归\n\n\n🙏🙏🙏🙏🙏🙏🙏🙏🙏感谢这位西电的朋友助我脱离苦海，感谢感谢\n可以直接用那种：😭😭😭😭（数据结构放假是机考！机考！机考！我giao！！！）\n#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct Node&#123;    char data;    Node* left;    Node* right;    Node(char data)&#123;        this-&gt;data = data;        this-&gt;left = nullptr;        this-&gt;right = nullptr;    &#125;&#125;;vector&lt;char&gt; getCharArray(string str)&#123;    //这一步就是为了利用vector有现成的构造函数，能省很多步骤    vector&lt;char&gt; res;    for(char c : str)&#123;        //        /*        这里的for(char c:str)就是定义一个遍历字符c，让它分别等于字符串数组str里面的各个字符，然后执行下面的语句，当c被赋值为str里面所有字符各一次后，就会退出这个循环。这相当于JAVA的强for循环的语法结构。相当于C++的：for( int i = 0; i &lt; s.length(); i++)&#123; s[i]…&#125;        */        res.push_back(c);    &#125;    return res;&#125;Node* getTree(vector&lt;char&gt;&amp; preOrder, vector&lt;char&gt;&amp; inOrder)&#123;    if(preOrder.empty())&#123;        return nullptr;    &#125;    Node* root = new Node(preOrder[0]);    //构造根结点，并且将root指针指向前序的第一个节点，即总根节点    vector&lt;char&gt;::iterator mid = find(inOrder.begin(), inOrder.end(), preOrder[0]);//遍历一次找到前序在    int left_nodes = mid - inOrder.begin();//接下来进行分区处理    vector&lt;char&gt; left_inOrder(inOrder.begin(), mid);//中序的左子树    //这里直接用了vector的构造，将inOrder赋值过去，最后一个mid不会复制    vector&lt;char&gt; right_inOrder(mid+1, inOrder.end());//中序的右子树    vector&lt;char&gt; left_preOrder(preOrder.begin()+1, preOrder.begin()+1+left_nodes);//前序的左子树，就省去根节点了    vector&lt;char&gt; right_preOrder(preOrder.begin()+1+left_nodes, preOrder.end());//前序右子树    root-&gt;left = getTree(left_preOrder, left_inOrder);//新树的左子树    root-&gt;right = getTree(right_preOrder, right_inOrder);//新树右子树    return root;//返回一个节点指针&#125;void postOrder(Node* root)&#123;//后续遍历    if(root == nullptr)&#123;        return ;    &#125;    postOrder(root-&gt;left);    postOrder(root-&gt;right);    cout&lt;&lt;root-&gt;data;&#125;int main()&#123;    string pre_str;    string in_str;    while(cin &gt;&gt; pre_str &gt;&gt; in_str)&#123;        vector&lt;char&gt; preOrder = getCharArray(pre_str);//string转换成vector向量形式        vector&lt;char&gt; inOrder = getCharArray(in_str);//        Node* root = getTree(preOrder, inOrder);        postOrder(root);        cout&lt;&lt;endl;    &#125;    return 0;&#125;\n\nLeetCode解法：\nclass Solution &#123;private:        TreeNode* traversal (vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd, vector&lt;int&gt;&amp; preorder, int preorderBegin, int preorderEnd) &#123;        if (preorderBegin == preorderEnd) return NULL;        int rootValue = preorder[preorderBegin]; // 注意用preorderBegin 不要用0        TreeNode* root = new TreeNode(rootValue);        if (preorderEnd - preorderBegin == 1) return root;        int delimiterIndex;        for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;            if (inorder[delimiterIndex] == rootValue) break;        &#125;        // 切割中序数组        // 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)        int leftInorderBegin = inorderBegin;        int leftInorderEnd = delimiterIndex;        // 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)        int rightInorderBegin = delimiterIndex + 1;        int rightInorderEnd = inorderEnd;        // 切割前序数组        // 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)        int leftPreorderBegin =  preorderBegin + 1;        int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 终止位置是起始位置加上中序左区间的大小size        // 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);        int rightPreorderEnd = preorderEnd;        cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;leftInorder :&quot;;        for (int i = leftInorderBegin; i &lt; leftInorderEnd; i++) &#123;            cout &lt;&lt; inorder[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        cout &lt;&lt; &quot;rightInorder :&quot;;        for (int i = rightInorderBegin; i &lt; rightInorderEnd; i++) &#123;            cout &lt;&lt; inorder[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        cout &lt;&lt; &quot;leftPreorder :&quot;;        for (int i = leftPreorderBegin; i &lt; leftPreorderEnd; i++) &#123;            cout &lt;&lt; preorder[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        cout &lt;&lt; &quot;rightPreorder :&quot;;        for (int i = rightPreorderBegin; i &lt; rightPreorderEnd; i++) &#123;            cout &lt;&lt; preorder[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        root-&gt;left = traversal(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);        root-&gt;right = traversal(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);        return root;    &#125;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        if (inorder.size() == 0 || preorder.size() == 0) return NULL;        return traversal(inorder, 0, inorder.size(), preorder, 0, preorder.size());    &#125;&#125;;\n\n\n\n并查集——面试涉及——竞赛频率也高😍面试官一般都习惯去问一些代码短但是思路精巧的（便于手写代码）\n提前学习知识：链表，线性表\n全名：归并查找集合，即判断两个元素是否属于同一个集合\n836. 合并集合 - AcWing题库\n可选方法：\n\n建两个哈希表分别找\n建两个跳表分别找\n\n在集合经常动态变化时候，查找方法效率并不高\n并查集应用：快速处理下列问题：\n\n将两个集合合并\n询问两个元素是否属于同一个集合中\n\n并查集能在近乎O（1）的时间复杂度之内快速支持以上两种操作\n正常：合并元素方式，至少需要对线性表&#x2F;链表整个进行一次遍历，耗时高\n基本原理：每一个集合使用一棵树来维护（不一定是二叉树，可能是三叉树，B+树等），每一个集合的编号就是根节点的编号，树中对于每一个点都存储其父节点（用p[x]表示x的父节点），在求某个元素是否属于某一个集合的时候，就在该元素向上遍历，知道到达根节点，最后判断根节点的编号是否是所需编号\n解决问题与流程：\n\n如何判断树根，\nif(p[x]==x)//对于树根编号等于自身\n\n如何求x的集合编号:\nwhile(p[x]!=x)x=p[x]//多么熟悉的链表的遍历操作，因此是链表实现    //这一步实际上的时间复杂度会高，因为还是会向上进行一个遍历，时间和树的高度有关，因此树最好高度越低越好\n\n如何合并两个集合：加一条边，将一个树插入到另一棵树身上就可以\n\n\n//假设p[x]是x集合编号，p[y]是y的集合编号，那么只需要p[x]=y\n\n写法：int find(int x)//核心的函数    //加上路径压缩，会自动找到根节点&#123;    //if(p[x]!=x)x=p[x];    if(p[x]!=x)p[x]=find(p[x]);    //易错：p[x]=find(p[x])这里要更新的    //易错：这里是if不能是循环while            /*    上面两句分别是普通版本和加过路径优化的版本    第一个就是普通循环进行查找    第二局是调用递归，每一次在寻找的时候都会对当前的节点进行更新，初次执行会慢，之后速度会飞升    */    return p[x];//最后返回一个根节点&#125;void merge(int x,int y)&#123;        p[x]=y;//核心函数二：合并     &#125;\n\n全代码：\n#include&lt;iostream&gt;using namespace std;const int N=100010;int p[N];//定义多个集合int find(int x)&#123;    if(p[x]!=x) p[x]=find(p[x]);    /*    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:    p[x]=x;    */    return p[x];    //找到了便返回祖宗节点的值&#125;void merge(int x ,int y)//这里是把x的头并到y了&#123;    p[find(x)]=find(y);//这里进行操作使用上一步的find函数&#125;int main()&#123;    int n,m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++) p[i]=i;    while(m--)    &#123;        char op[2];        int a,b;        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);        if(*op==&#x27;M&#x27;) merge(a,b);//集合合并操作        else        if(find(a)==find(b))        //如果祖宗节点一样,就输出yes        printf(&quot;Yes\\n&quot;);        else        printf(&quot;No\\n&quot;);    &#125;    return 0;&#125;\n\n\n\n并查集优化：路径压缩并查集最牛逼的优化方式，另一种优化基本写代码时候不会使用\n原理：一旦在向上走的时候找到了根节点，将该路径所有节点都指向根节点，即只需要搜索一次，之后的重复操作速度就会提高，可以视为O（1）优化\n优化：加权合并防止树越来越高\n记录每棵树元素的个数作为树的权重\n堆：完全二叉树的操作应用：\n\n构造优先队列\n\n（不用stl）手搓一个堆，堆的基本\n\n插入一个数\n求这个集合当中的最小值\n删除最小值\n删除任意一个元素（stl无法直接实现）\n修改任意一个元素（stl无法直接实现）\n\n堆的基本结构：堆属于一棵完全二叉树（指除了最后一排其他都是均匀分布，即所有节点都不是非空），最后一层节点从左到右依次排列\n小根堆的性质：每一个点都是小于等于左右儿子（即递归定义），则根节点就是最小值\n大根堆：相反\n凡是完全二叉树都是用一维数组存储的\n1号点是根节点\nx的左儿子下标：2x,\nx的右儿子下标：2x+1\nstl里面的堆就是优先队列\n特点：\n\n时间复杂度非常稳定，不依赖原始记录状态\t \n是一种不稳定的排序方法（记录比较与交换跳跃进行）\n\n基本函数：down(x)：如果某一个点的值变大，就将该值向下压\nup(x)：如果一个点的值变小，向上升\n两个函数的执行次数都和二叉树的深度成正比，也就是logn\n这里的x实际上是所处的位置\n由基本函数构成堆的几种操作：\n\n插入一个数\n\nheap[++size]=x;//这一步将堆数组的最后再一个换成需要的数up(size);\n\n\n求最小值\n\nheap[1];//是小根堆，则就最上面的就是最小的\n\n\n删除最小值(也就是最顶部的根节点的删除)\n\n思路：用堆底部的最后一个元素覆盖掉第一个元素，然后进行down（1)\n原理：存储结构是一个一维数组，删除尾部节点很容易（直接size–就行），但删除头部却很麻烦\n覆盖掉之后再使用向下函数down会让顶部元素下沉到正确位置\nheap[1]=heap[size];size--;down(1);\n\n\n删除任意一个元素,和删除头部不太一样在于不确定改变值之后是大还是小\n\n简单粗暴好使的办法：管他呢，down一次，up一次，因为up和down实际上只会执行一次\nheap[k]=heap[size];size--;//down(k);up(k);\n\n\n修改任意一个元素的值：同删除一个元素的操作\n\nheap[k]=x;down(k);up(k);\n\n构建小细节：不同于其它的一般采用下标从0开始，对于树形结构，因为树的性质有左儿子&#x3D;根&#x2F;2，如果从0开始左儿子也是0，不方便，因此堆排序实际上是从1开始\n开始构建：构建堆可以用插入的方式操作，但每一次插入都是logn，实际上不好\n有时间复杂度为on的方式\nfor(int i=size/2,i&gt;0;i--)down(i);\n\n构建up妙啊（发出抱大佬大腿的声音）😍\nvoid up(int u)&#123;    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//不管u是左右儿子，都不重要，直接/2指向的双亲都是同一个    &#123;        swap(u, u / 2);        u &gt;&gt;= 1;//u变成原先的二分之一    &#125;&#125;\n\n构建downvoid down(int u)&#123;    int t=u;    if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;=h[t])t=u*2+1;//判断右儿子和大小    //最后t存的就是根，左右儿子三者之中最小的值下标    if(u!=t)//不等，说明有可能还要继续递归进行对比    &#123;        swap(h[u],h[t]);        down(t);//递归向下继续弄    &#125;    &#125;\n\n模拟堆难点：支持随机的修改和删除,题中要求是第i个，但是i对应的下标会随着操作变化下标跟着变化，需要实时更新。因此映射也要交换好\n解法：使用映射,老牛逼了\n\n\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;//ph从左到右，hp从右到左、//交换数的时候，指针也要交换// 交换两个点，及其映射关系void heap_swap(int a, int b)//针对这一道题开发的映射关系转换&#123;    swap(ph[hp[a]],ph[hp[b]]);//指针交换    swap(hp[a], hp[b]);//逆指针交换    swap(h[a], h[b]);//数值交换&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;void up(int u)&#123;    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])    &#123;        heap_swap(u, u / 2);        u &gt;&gt;= 1;    &#125;&#125;// O(n)建堆for (int i = n / 2; i; i -- ) down(i);\n\n解题技巧：当题中有明确给出第i个操作数，要考虑如何通过更新操作数的下标\n\n\n堆排序：onlogn一般升序使用大顶堆，降序采用小顶堆\n举例：对数组进行从小到大排序，输出前m小的数\n思路：本题可以使用堆排序，构造小顶堆，然后输出堆顶，输出后把堆顶和堆尾交换。尾部边界缩小，重复执行m次即可。\n注意点：\n\n和完全二叉树一样下标从1开始\n\n代码：易错点：\n模拟堆（直接造小根堆）#include &lt;iostream&gt;using namespace  std;const int M=100100;int h[M];int size;void big_down(int u)//最后大的会向下走&#123;    int t=u;    if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;=h[t])t=u*2+1;//判断右儿子和大小    //最后t存的就是根，左右儿子三者之中最小的值下标    if(u!=t)//不等，说明有可能还要继续递归进行对比    &#123;        swap(h[u],h[t]);        big_down(t);//递归向下继续弄    &#125;&#125;void small_down(int u)//最后小的会向下走&#123;    int t=u;    if(u*2&lt;=size&amp;&amp;h[u*2]&gt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&gt;=h[t])t=u*2+1;//判断右儿子和大小    //最后t存的就是根，左右儿子三者之中最小的值下标    if(u!=t)//不等，说明有可能还要继续递归进行对比    &#123;        swap(h[u],h[t]);        small_down(t);//递归向下继续弄        注意这里向下的还是t    &#125;&#125;int main()&#123;    cin&gt;&gt;size;    for(int i=1;i&lt;=size;i++)//二叉树的读入范围    &#123;        cin&gt;&gt;h[i];    &#125;    for (int i = size / 2; i; i -- ) small_down(i);    for(int i=1;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;&#x27; &#x27;;    cout&lt;&lt;endl;    for (int i = size / 2; i; i -- ) big_down(i);    for(int i=1;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;&#x27; &#x27;;    cout&lt;&lt;endl;    return 0;&#125;\n\n\n\n堆排序（整体）#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N];//保存数组int n, m;//n个点，求前m小int r ;//堆的右边界void down(int u)//调整函数&#123;    //t记录最小点的编号    int t = u;易错部分：这里前面都是u最后对比是t，修改大小也是修改u    if(2 * u &lt;= r &amp;&amp; a[2 * u] &lt; a[t]) t = 2 * u;    if(2 * u + 1 &lt;= r &amp;&amp; a[2 * u + 1] &lt; a[t]) t = 2 * u + 1;    //如果待调整点不是最小的    if(u != t)    &#123;        //和最小的交换        swap(a[u], a[t]);        //递归处理        down(t);    &#125;&#125;因为堆是一棵二叉树构建起来的，因此是从1int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    r = n;//开始时，右边界是数组边界    //读入数据    for (int i = 1; i &lt;= n; i ++ )    &#123;        int x;        cin &gt;&gt; a[i];    &#125;    //从第一个非叶节点开始，从右到左，从下到上处理每个节点   for(int i = n /2 ; i ; i--)//创建小根堆   &#123;       //注意问题在于它小得没有规律       down(i);//因为叶子节点没办法继续向下了，因此从叶子向上一层开始操作   &#125;    //输出m个最小值    while (m -- )    &#123;        //堆顶保存的最小值，输出堆顶        cout &lt;&lt; a[1] &lt;&lt; &quot; &quot;;        //将堆顶和右边界交换        swap(a[1], a[r]);        //右边界左移        r--;        //从新处理堆顶        down(1);    &#125;&#125;\n\n\n\n哈夫曼树下面这个关于编码的，很重要\n(108条消息) 【数据结构——哈夫曼树及其应用】_FEI..的博客-CSDN博客_哈夫曼树的parent怎么求\n哈夫曼编码:字母核心：无前缀编码，从根节点到叶子节点的路径代表编码，只要字母在叶子节点，对应编码就是无前缀\n贪心算法\n从底向上建立一棵无前缀编码树\n频次低的树在最下面\n\n自己写的代码(输入字符串进行编码并输出)：#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;typedef struct&#123;    int weight;//结点的权值    int parent, lchild, rchild;//双亲、左孩子、右孩子的下标&#125;HTnode,*HuffmanTree;void Select(HuffmanTree&amp; HT,int &amp;s1,int &amp;s2,int n)&#123;    s2=1,s1=2;//两个过大的数进行比对    for (int i = 1;i &lt;= n;++s1)//在1到n之间的点进行寻找    &#123;        if(HT[s1].parent==0&amp;&amp;HT[s2].parent==0)//当        &#123;            break;        &#125;        if(HT[s1].parent==0)//当        &#123;            s2=s1;        &#125;        if(s2==s1)++s1;    &#125;    for (int i = 1;i &lt;= n;++i)//在1到n之间的点进行寻找    &#123;        if(HT[i].weight&lt;=HT[s1].weight&amp;&amp;HT[i].parent==0)//当        &#123;            s1=i;//连着更新两次，s1是最小的，s2是次小的        &#125;    &#125;    for (int i = 1;i &lt;= n;++i)//在1到n之间的点进行寻找    &#123;        if(HT[i].weight&lt;=HT[s2].weight&amp;&amp;HT[i].parent==0&amp;&amp;i!=s1)//当        &#123;            s2=i;        &#125;    &#125;&#125;void CreateHuffmanTree(HuffmanTree&amp; HT, int n,int word[])//构造哈夫曼树，n为带权值的叶子结点个数&#123;    //使用了以获取的word数组存取已有的数量    /*初始化*/    int s1,s2;    if (n &lt;= 1)        return;    int m = 2 * n - 1;//m为哈夫曼树中总结点的个数    HT = new HTnode[m + 1];//0号单元未用，所以需要开辟m+1个单元，HT[m]表示根结点    for (int i = 1;i &lt;= m;++i)//将1-m号单元的双亲，左右孩子的下标都初始化为0    &#123;        HT[i].parent = 0;        HT[i].lchild = 0;        HT[i].rchild = 0;    &#125;    int word_select=0;    for (int i = 1;i &lt;= n;++i)    &#123;        for(;word[word_select]==0;word_select++);//        cout&lt;&lt;(char)word_select &lt;&lt;&quot; word=&quot;&lt;&lt;word[word_select]&lt;&lt;endl;        HT[i].weight=word[word_select];//输入前n个单元中叶子结点的权值//        cout&lt;&lt;i&lt;&lt;&quot;个单元叶子节点的权值： &quot;&lt;&lt;HT[i].weight&lt;&lt;endl;//这一句是输入测试，ok了        word_select++;//到下一个防止连续搞    &#125;//到这一步都没问题，叶子节点权值都录入了    /*初始化工作结束，下面开始创建哈夫曼树*///    cout&lt;&lt;&quot;n=:&quot;&lt;&lt;n&lt;&lt;endl;    for (int i = n + 1;i &lt;= m;++i)    &#123;//通过n-1次的选择、删除、合并来创建哈夫曼树        Select(HT,  s1, s2,n);//选择两个其双亲域为0且权值最小的结点//        cout&lt;&lt;i-15&lt;&lt;&quot;次操作之后 &quot; &lt;&lt;&quot;s1 now=&quot;&lt;&lt;s1&lt;&lt;&quot; HT[s1].weight=&quot;&lt;&lt;HT[s1].weight;//        cout&lt;&lt;&quot;  s2 now =&quot;&lt;&lt;s2&lt;&lt;&quot; HT[s2].weight=&quot;&lt;&lt;HT[s2].weight&lt;&lt;endl;        HT[s1].parent = i;HT[s2].parent = i;//得到新结点i,将s1\\s2的双亲域由0改为i        HT[i].lchild = s1;HT[i].rchild = s2;//s1、s2分别作为i的左右孩子        HT[i].weight = HT[s1].weight + HT[s2].weight;//i的权值为左右孩子的权值之和//        cout&lt;&lt;&quot;  HT now =&quot;&lt;&lt;i&lt;&lt;&quot; HT[i].weight=&quot;&lt;&lt;HT[i].weight&lt;&lt;endl;    &#125;&#125;typedef char** HuffmanCode;////动态分配数组存储哈夫曼编码表void CreatHuffmanCode(HuffmanTree HT, HuffmanCode&amp; HC, int n)//完全没有开始写的&#123;//从叶子到根逆向求每个字符的哈夫曼编码，储存在编码表HC中    HC = new char* [n + 1];//分配n个字符编码的头指针矢量     char *cd = new char[n];//分配临时存放编码的动态数组空间     int start;     int c;     int f;    cd[n - 1] = &#x27;\\0&#x27;;//编码结束符    for (int i = 1;i &lt;= n;++i)//逐个字符求哈夫曼编码    &#123;        start = n - 1;//start开始时指向最后，即编码结束符的位置        c = i;f = HT[i].parent;//f指向结点c的双亲结点        while (f != 0)//从叶子结点开始向上回溯，直到根结点        &#123;            --start;//回溯一次，start向前指一个位置            if (HT[f].lchild == c)                cd[start] = &#x27;0&#x27;;//结点c是f的左孩子，则生成代码0            else                cd[start] = &#x27;1&#x27;;//结点c是f的右孩子，则生成代码1            c = f;f = HT[f].parent;//继续向上回溯        &#125;//求出第i个字符的编码        HC[i] = new char[n - start];//为敌i个字符编码分配空间        strcpy(HC[i], &amp;cd[start]);//将求得的编码从临时空间cd复制到HC当前行中    &#125;    delete cd;//释放临时空间&#125;char out[128]=&#123;&#x27;\\0&#x27;&#125;;int word[128]=&#123;0&#125;;//作为字母int main() &#123;    string ans=&quot;&quot;;    string temp;    while (getline(cin, temp)) &#123;        if (temp == &quot;0&quot;) &#123;            break;        &#125;        ans+=temp;    &#125;//读入阶段    int length=ans.size();    for(int i=0;i&lt;length;i++)    &#123;        int idx=(int)(ans[i]);        word[idx]++;    &#125;    int node_num=0;    for(int i=1;i&lt;=128;i++)    &#123;        if(word[i]!=0)        &#123;            ++node_num;            out[node_num]=(char)i;//            cout &lt;&lt;(char)i &lt;&lt; &quot;: &quot;&lt;&lt; word[i] &lt;&lt; endl;            //这里获得了对应的编码        &#125;    &#125;    HuffmanTree HT;    CreateHuffmanTree(HT,node_num,word);    HuffmanCode HC;    CreatHuffmanCode(HT,HC,node_num);    for(int i=1;i&lt;=node_num;i++)    &#123;        cout&lt;&lt;out[i]&lt;&lt;&quot;:&quot;&lt;&lt;HC[i]&lt;&lt;endl;    &#125;    return 0;&#125;\n\n代码：\n// C++ program for Huffman Coding#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;// This constant can be avoided by explicitly// calculating height of Huffman Tree#define MAX_TREE_HT 100// A Huffman tree nodestruct MinHeapNode &#123;\t// One of the input characters\tchar data;\t// Frequency of the character\tunsigned freq;\t// Left and right child of this node\tstruct MinHeapNode *left, *right;&#125;;// A Min Heap: Collection of// min-heap (or Huffman tree) nodesstruct MinHeap &#123;\t// Current size of min heap\tunsigned size;\t// capacity of min heap\tunsigned capacity;\t// Array of minheap node pointers\tstruct MinHeapNode** array;&#125;;// A utility function allocate a new// min heap node with given character// and frequency of the characterstruct MinHeapNode* newNode(char data, unsigned freq)&#123;\tstruct MinHeapNode* temp\t\t= (struct MinHeapNode*)malloc(sizeof(struct MinHeapNode));\ttemp-&gt;left = temp-&gt;right = NULL;\ttemp-&gt;data = data;\ttemp-&gt;freq = freq;\treturn temp;&#125;// A utility function to create// a min heap of given capacitystruct MinHeap* createMinHeap(unsigned capacity)&#123;\tstruct MinHeap* minHeap\t\t= (struct MinHeap*)malloc(sizeof(struct MinHeap));\t// current size is 0\tminHeap-&gt;size = 0;\tminHeap-&gt;capacity = capacity;\tminHeap-&gt;array\t\t= (struct MinHeapNode**)malloc(minHeap-&gt;capacity * sizeof(struct MinHeapNode*));\treturn minHeap;&#125;// A utility function to// swap two min heap nodesvoid swapMinHeapNode(struct MinHeapNode** a,\t\t\t\t\tstruct MinHeapNode** b)&#123;\tstruct MinHeapNode* t = *a;\t*a = *b;\t*b = t;&#125;// The standard minHeapify function.void minHeapify(struct MinHeap* minHeap, int idx)&#123;\tint smallest = idx;\tint left = 2 * idx + 1;\tint right = 2 * idx + 2;\tif (left &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[left]-&gt;freq &lt; minHeap-&gt;array[smallest]-&gt;freq)\t\tsmallest = left;\tif (right &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[right]-&gt;freq &lt; minHeap-&gt;array[smallest]-&gt;freq)\t\tsmallest = right;\tif (smallest != idx) &#123;\t\tswapMinHeapNode(&amp;minHeap-&gt;array[smallest],\t\t\t\t\t\t&amp;minHeap-&gt;array[idx]);\t\tminHeapify(minHeap, smallest);\t&#125;&#125;// A utility function to check// if size of heap is 1 or notint isSizeOne(struct MinHeap* minHeap)&#123;\treturn (minHeap-&gt;size == 1);&#125;// A standard function to extract// minimum value node from heapstruct MinHeapNode* extractMin(struct MinHeap* minHeap)&#123;\tstruct MinHeapNode* temp = minHeap-&gt;array[0];\tminHeap-&gt;array[0]\t\t= minHeap-&gt;array[minHeap-&gt;size - 1];\t--minHeap-&gt;size;\tminHeapify(minHeap, 0);\treturn temp;&#125;// A utility function to insert// a new node to Min Heapvoid insertMinHeap(struct MinHeap* minHeap,\t\t\t\tstruct MinHeapNode* minHeapNode)&#123;\t++minHeap-&gt;size;\tint i = minHeap-&gt;size - 1;\twhile (i &amp;&amp; minHeapNode-&gt;freq &lt; minHeap-&gt;array[(i - 1) / 2]-&gt;freq) &#123;\t\tminHeap-&gt;array[i] = minHeap-&gt;array[(i - 1) / 2];\t\ti = (i - 1) / 2;\t&#125;\tminHeap-&gt;array[i] = minHeapNode;&#125;// A standard function to build min heapvoid buildMinHeap(struct MinHeap* minHeap)&#123;\tint n = minHeap-&gt;size - 1;\tint i;\tfor (i = (n - 1) / 2; i &gt;= 0; --i)\t\tminHeapify(minHeap, i);&#125;// A utility function to print an array of size nvoid printArr(int arr[], int n)&#123;\tint i;\tfor (i = 0; i &lt; n; ++i)\t\tcout&lt;&lt; arr[i];\tcout&lt;&lt;&quot;\\n&quot;;&#125;// Utility function to check if this node is leafint isLeaf(struct MinHeapNode* root)&#123;\treturn !(root-&gt;left) &amp;&amp; !(root-&gt;right);&#125;// Creates a min heap of capacity// equal to size and inserts all character of// data[] in min heap. Initially size of// min heap is equal to capacitystruct MinHeap* createAndBuildMinHeap(char data[], int freq[], int size)&#123;\tstruct MinHeap* minHeap = createMinHeap(size);\tfor (int i = 0; i &lt; size; ++i)\t\tminHeap-&gt;array[i] = newNode(data[i], freq[i]);\tminHeap-&gt;size = size;\tbuildMinHeap(minHeap);\treturn minHeap;&#125;// The main function that builds Huffman treestruct MinHeapNode* buildHuffmanTree(char data[], int freq[], int size)&#123;\tstruct MinHeapNode *left, *right, *top;\t// Step 1: Create a min heap of capacity\t// equal to size. Initially, there are\t// modes equal to size.\tstruct MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);\t// Iterate while size of heap doesn&#x27;t become 1\twhile (!isSizeOne(minHeap)) &#123;\t\t// Step 2: Extract the two minimum\t\t// freq items from min heap\t\tleft = extractMin(minHeap);\t\tright = extractMin(minHeap);\t\t// Step 3: Create a new internal\t\t// node with frequency equal to the\t\t// sum of the two nodes frequencies.\t\t// Make the two extracted node as\t\t// left and right children of this new node.\t\t// Add this node to the min heap\t\t// &#x27;$&#x27; is a special value for internal nodes, not used\t\ttop = newNode(&#x27;$&#x27;, left-&gt;freq + right-&gt;freq);\t\ttop-&gt;left = left;\t\ttop-&gt;right = right;\t\tinsertMinHeap(minHeap, top);\t&#125;\t// Step 4: The remaining node is the\t// root node and the tree is complete.\treturn extractMin(minHeap);&#125;// Prints huffman codes from the root of Huffman Tree.// It uses arr[] to store codesvoid printCodes(struct MinHeapNode* root, int arr[], int top)&#123;\t// Assign 0 to left edge and recur\tif (root-&gt;left) &#123;\t\tarr[top] = 0;\t\tprintCodes(root-&gt;left, arr, top + 1);\t&#125;\t// Assign 1 to right edge and recur\tif (root-&gt;right) &#123;\t\tarr[top] = 1;\t\tprintCodes(root-&gt;right, arr, top + 1);\t&#125;\t// If this is a leaf node, then\t// it contains one of the input\t// characters, print the character\t// and its code from arr[]\tif (isLeaf(root)) &#123;\t\tcout&lt;&lt; root-&gt;data &lt;&lt;&quot;: &quot;;\t\tprintArr(arr, top);\t&#125;&#125;// The main function that builds a// Huffman Tree and print codes by traversing// the built Huffman Treevoid HuffmanCodes(char data[], int freq[], int size)&#123;\t// Construct Huffman Tree\tstruct MinHeapNode* root\t\t= buildHuffmanTree(data, freq, size);\t// Print Huffman codes using\t// the Huffman tree built above\tint arr[MAX_TREE_HT], top = 0;\tprintCodes(root, arr, top);&#125;// Driver codeint main()&#123;\tchar arr[] = &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;;\tint freq[] = &#123; 5, 9, 12, 13, 16, 45 &#125;;\tint size = sizeof(arr) / sizeof(arr[0]);\tHuffmanCodes(arr, freq, size);\treturn 0;&#125;/*结果输出：f: 0c: 100d: 101a: 1100b: 1101e: 111*/\n\nAVL树平衡二叉树：\n(110条消息) AVL树的详细实现(C++)_code_peak的博客-CSDN博客_c++实现avl树\navl树的各种延申应用：伸展树，B树，字典树\n","tags":["学习笔记"]},{"title":"讲座论文啥子的观看想法","url":"/2023/04/15/%E8%AE%BA%E6%96%87%EF%BC%8C%E8%AE%B2%E5%BA%A7%E9%98%85%E8%AF%BB%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/","content":"软件讲座蒋炎岩老师：模型模型：软件系统中的小小世界\n计算机系统是状态机，软件也是状态机\n\n真实系统的状态机过于庞大，只有化简（仅仅关注一个侧面）才能理解\n\n如何用模型指导软件测试软件测试实质：搞破坏\n思路小世界假设：软件bug只需要关注软件系统的一小部分即可触发，而描述bug发生实际上只需要少量信息\n小世界建模：建模系统发生的关键事件，将软件测试问题变成一个搜索问题\n\n操作系统对于进程，文件的抽象本质上上世纪七十年代到当今其实基本没有变化\n\n小世界建模：建模基础系统和演化带来的特性\n例如船，从帆船到航母，实际上破坏船体都会带来相似的结果，可以用相同的思想去测试，即对于测试航母，先建模一个帆船的模型，针对帆船进行测试\n在操作系统内核中，可以建立一个基础的UNIX的文件系统模型，以插件的形式将现代操作系统的功能加入，对该种基础模型进行测试，一般也可以测试出来内核的问题\n对于编译器：\n\n程序&#x3D;框架+语句\n\n框架确定了控制流\n语句确定了数据流和含义\n\n\n\n模型：程序合成软件的动态更新，就像是一台不会停止运行的服务器就可以运行\n目标：能不能调试代码不需要重新编译（这里是编译原理的东西吗？），就不需要停止软件运行\n思路：将对函数的调用改为对函数指针的调用\n难题：代码改一行，数据全变样，即会导致之前数据的迁移异常\n动态更新：对象状态转换，比如原本是数组，通过一个函数更新为链表的存储方式\n期望：自动生成对象状态操作历史\n例如对数组到链表的转换，可以生成一个序列备份这样就可以复原，\n感觉挺好，但是软件复杂度上升然后就顶不住了\n答案：在项目本身中\n在复杂的软件项目中构造一个模型，将一个完整的项目进行拆分，拆分成小的模型和片段，将其中可以替换的部分进行更新，最后再进行一个合成，完成一个动态更新\n模型：计算机系统的构造和解释关于《操作系统》这一门课，就可以为计算机系统进行建模，所有软件都是状态机，对状态机就能进行一个模拟\n为计算机硬件建模将精简为计算机软件提供的核心机制通过C函数实现多处理器硬件的抽象，这样写操作系统不再需要汇编\n为操作系统建模从应用角度，操作系统就可以视为一组API，进行建模之后，也可以了解操作系统的实现正确性和编译器的编译正确性\n总结：化繁为简”对于无法搞懂的复杂系统，就建模成简单系统，搞清楚小的模型的原理，然后再映射回去\n\n模型：更小的系统，更小的状态空间\n\n\n系统&#x3D;行为的总和\n模型便于暂时忽略复杂性，化繁为简\n\n蒋炎岩老师：安卓应用跨设备迁移相同应用在不同设备之间会出现问题（如最简单的计算器会在屏幕尺寸不同时出现不同的显示界面）\n一台机器的测试用例如果能通过但是在别的设备上可以使用，更复杂应用如word的包基本相同，但是在手机上和平板上面界面是很不一样的\n软件工程中的搜索问题\n软件自动化：\n\n生成测试用例\n生成代码\n生成时间\n\n解决方式：使用贪心方法找到相同操作的映射\n搜索+剪枝\n应用向更小屏幕的迁移如手机应用向穿戴设备（手表等）迁移，将原有的移动应用界面“映射”到智能手表上（其中还要能够选出来需要的功能）\n软工vs系统\n\n应用：人类需求在信息世界的投影\n系统：硬件上构建的服务系统\n\nai属于连接软件与系统之间的桥梁\n数据库发展\n\n预测：\n智能化作用逐步加大\n影响数据库发展的因素\n软件计数\n数据模型\n硬件\n计算模式\n架构演进\n新型应用\n\n计算机内存管理（论文读）[原创] 每个程序员都应该知道的内存知识 (带你走读Ulrich Drepper的经典论文)_哔哩哔哩_bilibili\n重点：3，4，6章\n视频1：cpu访问速度与内存访问速度出现显著差距（CPU速度与SRAM速度显著下降，而DRAM速度提升不高，SSD相对于磁盘提升了一部分速度）\n提升方法：\n\n利用cpu缓存\n改进ram架构设计\n内存控制设计\nDMA\n\n最初系统包括南北桥系统（北桥包含RAM内存控制器，南桥包含PCIE和USB，SATA）\n演进时改进成为了一种将cpu集成的设计\n当今使用SDRAM（一种DRAM，但是可以同步时钟信号）行列选通都是低电平有效\n关于预充电与激活：不同芯片在行选中与下一行选中之间有时间间隔，会在其中进行准备\n视频2：存储结构：寄存器到SRAM到DRAM\n冯诺依曼架构实际上使用得不太多\nL1指令缓存与数据缓存是分开的，在二级缓存开始就是分开的\ncpu缓存：缓存不命中原因：\n\n一开始缓存中没有任何数据（预热区间）\n缓存容量不够用\n发生访问冲突（如修改缓存数据时也需要同步修改主存数据）\n\ncpu缓存具体实现：\n全相连缓存\n\n缓存是以行的形式存储\n\n直接映射缓存\n\n硬件实现容易\n缓存容量越大，命中概率越高\n写回缓存写回：缓存数据修改会打上“脏数据”标记，在一段时间后写回主存（延时策略）\n缓存替换策略：选择替换的方式，最常使用LRU（计组部分的知识）\ncpu设计中有很多访问预测的部分（减少流水线停止导致的时间开销，也就是苏老师做的用ai自行判断内存访问部分）\n访问时序部分：\n视频3：第四章：虚拟内存虚拟内存映射（操作系统部分）：每个程序实际上都会自动分配一定的虚拟内存，但是物理内存不足，会出现内存越界情况\n如果内存中有足够一个程序（进程）运行的内存总量（总量是2G，但是是在物理地址上不连续）就没办法运行新的进程\n不同进程之间由于可能占用相同的物理内存，导致改写内存呢使得相应地址的数据是“脏数据”\n虚拟内存属于一种抽象。\n在虚拟地址情况下，使用物理内存方式发生变化，可以灵活映射\n计算机任何问题都可以通过加一层来解决\n例：没有虚拟内存时候只能连续地进行映射，加上虚拟内存，如实际连续物理地址不足会映射到其它空余地方（如硬盘也行），这样进程不会崩溃\n通过映射可以自由决定映射位置，即使进程使用的是同样的虚拟地址，但映射算法会映射到不同的物理地址上（哈希表解决冲突），如果几个程序需要使用同一内存，操作系统就会映射到同一个物理地址保证使用数据相同\n映射是在硬件级别来做（MMU，内存管理单元），在CPU内核和内存之间\nLAZY ALLOCATION：内核使用一种推迟分配内存的方式，当用户申请一块内存，操作系统（硬件）不一定马上分配这一块内存（为了优化性能），实际使用中申请一块内存，接下来使用的机会会其实很少（在链接，装载，一些库函数中也会使用到）\n页：\n\n页是一个内存大小单元\n\nTLB：包含映射的东西，正常在虚拟地址上通过TLB映射到物理地址\n使用Directory索引来查找在具体哪一页，完整页表放在主存中，即访问内存时可能会访问两次内存（间址寻址） \n采用方法：使用硬件（TLB），TLB分为指令部分与数据部分（来加快速度），本质类似CACHE\n增加TLB方法：\n\n单个页变大（4k改2M，命中概率增大）\n再增加一级TLB缓存\n\n视频4：很多内置库函数如new，malloc其实都是设计内存管理\n大公司都在开发自己的内存分配器（如谷歌脸书等等）\n行与列访问具有不同效率\nTLB优化：尽量减少内存使用，\n","tags":["学习笔记"]}]