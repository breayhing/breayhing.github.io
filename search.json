[{"title":"建站踩坑录","url":"/2023/03/02/blog%E5%BB%BA%E7%AB%8B%E7%AB%99%E7%82%B9%E8%AE%B0%E5%BD%95/","content":"在经历长达一天的艰苦修改（改一些奇奇怪怪的神奇bug）之后，这个网站总算是建立起来了，之后的时间应该就是使用这里来记录一些学习中的记录以及一些日常的琐碎话吧\n\n建站鸣谢：傻白的blog以及帮了很大忙的131blog\n传送门：\n启用主题 | 131’s Blog (cxy131.site)\nはくのblog (sirohune.site)\n\n踩坑实录：\nhexo d #部署网站\n\n坑点在于之前使用jekyll部署过网站，因此再使用hexo部署时会导致出现很神奇的bug：github相应网页的代码更新，但是action中显示没有部署。来回摸索好久\n最终解决方案：将原本的GitHub库删除重新搭建（删库跑路法），成功\n","tags":["那些神奇的坑与神奇的问题"]},{"title":"sse-net计算机网络笔记","url":"/2023/03/02/sse-net%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/","content":"参考网课：\nChapter 1protocol:发起连接时候双方都遵守的一定规则(规范语法，语义，时序)\nDSL：最之前家庭网络连接方法（数字用户线）\ninternet标准：\n\nRFC\nIETF\nWIFI\nWAPI\n\nTCP：传输控制协议，应用\n\nHTTP\nFTP\nSMTP\nTelnet\n\nHost:数据发送方\nLinks:实体媒介（网络线缆等等）\n结论：链路交换不适合计算机之间通信\n\n建立时间长\n可靠性低\n浪费资源较多\n\nChapter 2提问部分：\n对于浏览器下载文件通常是分为小切片下载在缓存中并通过相关算法拼凑，如果中断重新连接能否继续下载则看软件相关系统处理方式怎么样\n对于访问github等网站时（应用层web部分）如果访问时间过长系统会判定为连接失败从而放弃\n\n开始讲解分组交换\n分组交换与电路交换电路交换：\n优点：\n\n由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。\n通信双方之间的屋里通路一旦建立，双方可以随时通信，实时性强。\n双方通信时按发送顺序传送数据，不存在失序问题。\n电路交换既适用于传输模拟信号，也适用于传输数字信号。\n电路交换的交换设备及控制均比较简单。\n\n缺陷：\n\n电路交换平均连接建立时间对计算机通信来说较长。\n电路交换家里连接后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低。\n电路交换时，数据直达，不同类型，不同规格，不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。\n\n分组交换\n优点：\n\n不存在连接建立时延，用户可随时发送分组\n传输可靠性高\n通信双方在不同时间段一段一段地部分占有物理通路，提高了通信线路利用率\n加速了数据在网络中的传输\n简化了交换节点中存储器的管理\n分组较短，出错几率减少，可靠性高，时延低\n\n缺点：\n\n通信量越大，时延越大，实时性较差\n只适用于数字信号\n可能出现失序，丢失或者重复分组\n\n综上，若传输的数据量很大，而且传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段链路组成是，采用分组交换较为合适。从提高整个网络的信道利用率上看，分组交换优于电路交换。\nTDM&#x2F;FDM（电路交换）TDM：()时分复用\nFDM：()频分复用\nTDM相对FDM优点：\n\n发生拥塞等网络问题时，TDM中数据丢失可能只会是一部分，FDM中就可能是大部分或全部\n电路交换中时分复用能高效地使用网络，因为频分复用建立后，如果中途没有数据传输时，所占有的频段带宽不能被其它连接使用，可能存在空置\n\n分组交换网络 存储-转发\nISP第一层ISP：面向客户网络结算点（负责收费）\nIXP：连接多个对等之间的ISP\nICP：（conternt provider）部署自身专用网络并且与各级ISP连接\n网络中每一个节点都是不一样的\n四种延迟传输延迟：一个数据分组需要多长时间发送出来（缓存中也有一个排队延迟）\n处理延时：分组时候查看信号是否有错误情况，\n排队延时：随机的，与当前网络情况相关（比如发送请求）\n传播延迟：物理层面传播的延迟（在线路中传输的速度）\n应用：可以根据运营商的中心机房位置去抢票（乐）\nChapter 3TTLtime to live\n连接时候给定连接时间，超过该时间则认定为连接超时，随后显示网络连接失败\n吞吐量给定时间内平均吞吐量\n协议层网络层次：不同邻接层次之间有相应接口来传输，每一层都向上一层提供服务\n分层顺序：5层\n应用层，传输层，网络层，链路层，物理层\n服务访问点：SAP，上层使用下层的服务通过层之间的接口-地点\n举例：邮箱（SMTP）\n无连接服务：无需预留资源，不需要双方活跃（比如email传输和qq等聊天软件发送信息）\n网络连接需要：端口号\n网络安全部分：\n","tags":["学习bi'ji"]},{"title":"CS-net-assignment#1","url":"/2023/03/03/cs-net-assignment-1/","content":"SSE206 Computer Networks Assignment #1Q1：\n今天最流行的无限因特网接入技术有WIFI和4G接入。WIFI速度快但距离短（距离基站近），4G速度慢但距离远（距离基站远），以及最新的5G技术，相对于4G具有更低时间延迟，更高连接速率。\nQ2：\n电路交换更适合。\n原因：对于以稳定速率传输数据，并且持续长时间运行的应用程序。电路交换网可以\n\n传输数据速率稳定，因此电路交换可以为其保留带宽，可以为其保留带宽，保证应用程序以稳定的速率接收数据\n由于需要持续长时间运行，即不需要重复建立连接，分组交换相对电路交换的优势并不大\n通信线路为双方专用，数据直达，故传输时延非常小\n\nQ3：（不确定，回头再检查）\na. 第一个分组交换需要的时间为&#x3D;报文大小&#x2F;链路速率&#x3D; 8 * 10^6 &#x2F; 2 * 10^6 sec &#x3D; 4 sec 源主机到目的主机有三段链路，需要时间为 3 * 4 &#x3D; 12 sec\nb. 从源主机发送第一个分组到第一台交换机1 * 10^4 &#x2F; 2 * 10^6 sec &#x3D; 5 m sec 从第一台交换机发送第一个分组到第二台交换机时间 &#x3D; 从源主机发送第二个分组到第一台交换机时间 &#x3D; 2 * 5 m sec &#x3D; 10 m sec\nc. 第一个分组到达目的地时，花费的时间为 5 m sec * 3 &#x3D; 15 m sec,之后，每隔 5 秒将会有一个分组被接收，一共有 800 个分组 ，除去第一个分组，传输该文件所需要的时间为 15 m sec + 799 * 5 msec &#x3D; 4.01 sec。\nd. \n使用报文分段便于检测错误并且重新传输，不分段的大数据包则容易使得路由器缓存不足导致丢包。\nQ4:\nSkype因为是采用私有信令协议，与运营商的电话网络所使用信令协议不同，因此需要专业的语音网关进行信令转换，因此简单的通信模型如下\nSkype客户端→Skype服务器→语音网关→运营商线路→个人电话\n即语音呼叫必须通过因特网（服务器请求），与电话网（对运营商线路发出请求）\nQ5:\n相对与分组交换网络，电路交换网络优点有：\n\n传输时延非常小\n可以随时通信，实时性强\n不存在失序问题\n交换设备及控制都简单\n\n电路交换网络中，TDM相对FDM优点：\n\n发生拥塞等网络问题时，TDM中数据丢失可能只会是一部分，FDM中就可能是大部分或全部\n电路交换中时分复用能高效地使用网络，因为频分复用建立后，如果中途没有数据传输时，所占有的频段带宽不能被其它连接使用，可能存在空置\n\nQ6:\n\n各层对应: 一-物理层, 二-链路层, 三-网络层, 四-运输层, 五-应用层\n路由器处理第一层到第三层\n链路层交换机处理第一层和第二层\n主机处理所有五层.\n\n","tags":["cs-net"]},{"title":"web技术学习笔记","url":"/2023/03/08/web%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/","content":"关于ReactReact渲染原理：react渲染原理 - 掘金 (juejin.cn)\nReact笔记HOOKs：\nuseState\nuseRef\nuseContext\nuseEffect\n\n","tags":["项目实习笔记"]},{"title":"数电","url":"/2023/03/04/%E6%95%B0%E7%94%B5/","content":"考完试的感觉就是：题量哈人。\n两个小时的考试时间实际上是很紧张的，主要在于画卡诺图和真值表部分。\n\n考题中出现的一些重点（想起啥算啥吧）\n选择&#x2F;填空：第十章和第十一章的比例相当高，而且其实占分比还是挺高的(关于存储器，尤其是第十一章的信号转换)\n大题设计：重点在于了解三个基础芯片（151，138，73都考到了，和老师说的一致），以及快速，准确地画好卡诺图和真值表，否则时间会很紧张\n","tags":["考试复盘"]},{"title":"数据结构与算法 PART 2","url":"/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95PART2/","content":"数据结构与算法：PART 2搜索与图论查找中静态与动态差异仅在于是否可以动态增删元素\n动态查找在几何计算上应用广泛\n搜索种类：无信息搜索：\n1.DFS：递归结束条件的选择+状态标记+递归后的恢复(也可以用栈来搭建出来)2.BFS：模拟队列 q[N], d[N] 使用d数组标记状态3.搜索：解空间的搜索往往需要dfs+剪枝，bfs用来找最短路4.树和图的存储：邻接表 h[N], e[N], ne[N], idx5.树和图的遍历：遍历不用像搜索解空间一样递归后恢复，只用遍历一次即可\n有信息搜索：\nA搜索算法\n建立搜索模型：\n\n\n\nDFS优势：可以获取子树的大小核心：顺序842. 排列数字 - AcWing题库\nDFS人称暴力搜索，对应的是一个多叉树的形式，DFS的搜索顺序和前序遍历其实一样，但是实际上存储结构只会存一条路径，回溯的时候就会消失，不需要真正建立树，但是一定要注意恢复现场\n![深度优先遍历.png](D:\\typora note\\55289_0cd4222d73-深度优先遍历.png)\n举例：全排列做法，使用回溯（还可以使用剪枝）\n全排列做法：时间复杂度为 O(n*n!)。\n空间复杂度为 O(n)。\n算法：\n\n用 path 数组保存排列，当排列的长度为 n 时，是一种方案，输出。\\\n用 state 数组表示数字是否用过。当 state[i] 为 1 时：i 已经被用过，state[i] 为 0 时，i 没有被用过。\ndfs(i) 表示的含义是：在 path[i] 处填写数字，然后递归的在下一个位置填写数字。\n回溯：第 i 个位置填写某个数字的所有情况都遍历后， 第 i 个位置填写下一个数字。\n\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 10;\nint path[N];//保存序列\nint state[N];//数字是否被用过\nint n;\nvoid dfs(int u)\n&#123;\n    if(u &gt; n)//数字填完了，输出\n    &#123;\n        for(int i = 1; i &lt;= n; i++)//输出方案\n            cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; endl;\n    &#125;\n\n    for(int i = 1; i &lt;= n; i++)//这里就是选择如何遍历，想反方向就是逆序遍历了\n        //空位上可以选择的数字为:1 ~ n\n    &#123;//关键在这里\n        /*\n        比如123\n        回溯到1，state[2]=0,2又可以用，但循环走到了2，到3了，因此是132\n        */\n        if(!state[i])//如果数字 i 没有被用过\n        &#123;\n            path[u] = i;//放入空位\n            state[i] = 1;//数字被用，修改状态\n            dfs(u + 1);//填下一个位\n            state[i] = 0;//回溯，取出 i\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n\n    cin &gt;&gt; n;\n    dfs(1);//从1开始\n    &#125;\n\nDFS另一种应用：皇后位置c++直接完整版本代码：（LeetCode 版本）\nclass Solution &#123;\nprivate:\nvector&lt;vector&lt;string&gt;&gt; result;\n// n 为输入的棋盘大小\n// row 是当前递归到棋牌的第几行了\nvoid backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;\n    if (row == n) &#123;//回溯到最后一行，说明满足情况了\n        result.push_back(chessboard);\n        return;\n    &#125;\n    for (int col = 0; col &lt; n; col++) &#123;\n        if (isValid(row, col, chessboard, n)) &#123; // 验证合法就可以放\n            chessboard[row][col] = &#39;Q&#39;; // 放置皇后\n            backtracking(n, row + 1, chessboard);//再进一行进行检验\n            chessboard[row][col] = &#39;.&#39;; // 回溯，撤销皇后\n        &#125;\n    &#125;\n&#125;\nbool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;\n    int count = 0;\n    // 检查列\n    for (int i = 0; i &lt; row; i++) &#123; // 这是一个剪枝\n        if (chessboard[i][col] == &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    // 检查 45度角是否有皇后\n    for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) &#123;//另一个剪支\n        if (chessboard[i][j] == &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    // 检查 135度角是否有皇后\n    for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;\n        if (chessboard[i][j] == &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;\n        result.clear();\n        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));\n        backtracking(n, 0, chessboard);//注意这里是从0开始的，所以最后到n，实际上以及对n层进行了判断\n        return result;\n    &#125;\n&#125;;\n\n/*总结操作流程：\n类似二叉树，对每个节点进行遍历，实际复杂度是n^2，从开头一直向下延申，可满足情况进行返回\n\nc++数组版本皇后问题:老子自己写的！（双手叉腰）\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\nconst int maxn=9;\nint solu[maxn]=&#123;0&#125;;\nint qn[maxn]=&#123;0&#125;;\nbool isValid(int posj,int posi)//最后那个pos也就是棋子的坐标\n&#123;\n    //posi=i,posj=qn[i]\n    if(posi==0)return true;\n    for(int i=0;i&lt;posi;i++)\n    &#123;\n        if(qn[i]==posj)return false;//相同的列判断\n    &#125;\n    for(int i=posi-1;i&gt;=0;i--)//45判断\n    &#123;\n        if(posi-i==posj-qn[i])return false;\n    &#125;\n    for(int i=posi-1;i&gt;=0;i--)//135\n    &#123;\n        if(posi-i==qn[i]-posj)return false;\n    &#125;\n    return true;\n&#125;\nvoid backtracing(int n,int row)\n&#123;\n    if(row==n)&#123;//终止了，找到了其中一种解决方案\n        cout&lt;&lt;&quot;bottom reached\\n&quot;;\n        cout&lt;&lt;&quot;solution:\\n&quot;;\n        for(int  i=0;i&lt;n;i++)\n        &#123;\n            cout&lt;&lt;&quot;row &quot;&lt;&lt;i+1&lt;&lt;&quot; equals to &quot;&lt;&lt;qn[i]+1&lt;&lt;&quot; \\n&quot;;\n        &#125;\n        cout&lt;&lt;&quot;go find other solution\\n\\n&quot;;\n        return;\n    &#125;\n    else&#123;\n        for(int i=0;i&lt;n;i++)//注意这里的传参\n        &#123;\n            qn[row]=i;//row，行固定，列用变量i对每一行进行遍历，如果满足之前条件进入下一行\n            if(isValid(qn[row],row))//该行该位置能否放\n            &#123;\n\n                backtracing(n,row+1);//可以就继续往下走\n\n            &#125;\n        &#125;\n    &#125;\n\n&#125;\n\nint main()\n&#123;\n    int n;\n\n    cin&gt;&gt;n;\n    backtracing(n,0);\n&#125;\n\nBFS（使用二维数组）原因：宽搜的性质：辐射性向外搜索（想想一层一层向外扩张的信号）\n844. 走迷宫 - AcWing题库\n注意：\ndp问题和最短路问题其实是互通的\n边的权重都是1的时候才可以使用BFS求最短路，一般都用最短路\ndp问题不能用最短路算法（最短路时间一般都高)\n第一次搜到的点才是最短的点，之后的都不是\n\n不同于深搜，宽搜一般有一个框架\n\n\n广搜的框架\n初始状态放到队列中\n写一个while循环，只要队列不空，在循环内每一次拿出队头，扩展队头\n\n往上下左右扩展的技巧：使用向量来表示\n代码（如该道题）\nvoid bfs(int a, int b): 广度优遍历函数。输入的是起点坐标。\nqueue q;:用来存储每一步走到的点。\nwhile(!q.empty())循环：循环依次取出同一步数能走到的点，再往前走一步。\nint dx[4] &#x3D; {0, 1, 0, -1}, dy[4] &#x3D; {-1, 0, 1, 0};:一个点往下一步走得时候，可以往上下左右四方向走。\n\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;\nconst int N = 110;\nint g[N][N];//存储地图\nint f[N][N];//存储距离\nint n, m;\nvoid bfs(int a, int b)//广度优先遍历\n&#123;\n    queue&lt;PII&gt; q;\n    q.push(&#123;a, b&#125;);//压入队列\n    while(!q.empty())\n    &#123;\n        PII start = q.front();\n        q.pop();\n        g[start.first][start.second] = 1;\n        int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;-1, 0, 1, 0&#125;;\n        for(int i = 0; i &lt; 4; i++)//往四个方向走\n        &#123;\n            int x = start.first + dx[i], y = start.second + dy[i];//走出一步之后\n            if(g[x][y] == 0)//如果还没有走过\n            &#123;\n                g[x][y] = 1;//该点进行更新,因为广搜中第一次遇到的就是最短路径\n                f[x][y] = f[start.first][start.second] + 1;//从当前点走过去，则距离等于当前点的距离+1.\n                q.push(&#123;x, y&#125;);//再入栈一个\n            &#125;\n\n        &#125;\n    &#125;\n    cout &lt;&lt; f[n][m];\n&#125;\n\nint main()\n&#123;\n    memset(g, 1, sizeof(g));\n    cin &gt;&gt; n &gt;&gt;m;\n    for(int i = 1; i &lt;= n; i++)//对地图进行一个更新\n    &#123;\n        for(int j = 1; j &lt;= m; j++)\n        &#123;\n            cin &gt;&gt; g[i][j];\n        &#125;\n    &#125;\n    bfs(1,1);//对起点进行bfs\n\n&#125;\n\n树和图的DFS，BFS树和图的DFS，BFS就是特殊的搜索（因为有那个环）\n树和图的遍历时间复杂度都是o（n+m）\n树与图的存储选择稠密图：邻接矩阵\n稀疏图：邻接表\n无向图实际上就是有向图进行一个对称\n有向图的存储方式\n邻接矩阵：同BFS，开二维数组存就完事了\n优化：使用vector向量\n int V,num;\n    cin&gt;&gt;V&gt;&gt;num;//V边数量\n    vector&lt;vector&lt;int&gt;&gt; graph(V);\n    vector&lt;vector&lt;int&gt;&gt; price(V);//记录权值\n    for(int i=0;i&lt;V;i++)\n    &#123;\n        graph[i].resize(V);\n        price[i].resize(V);\n    &#125;\n\n邻接表：使用数组模拟链表（还是注意idx的作用类似于分配器）,有多少个点开多少个单链表\n//这个的不好的地方是不好统计哪些地方已经走过和\n\n#include&lt;cstring&gt;//memset位置\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n//h存链表头，e存每一个节点的值，ne存每一个节点的下一个节点的地址，与单链表的不同就是把head换成h数组\n\n// 添加一条边a-&gt;b\nvoid add(int a, int b)\n&#123;\n    e[idx] = b;\n    ne[idx] = h[a];\n    h[a] = idx  ;\n    idx++;//是你熟悉的头插\n&#125;\nvoid add_to_tail(int x)//尾插\n&#123;\n    e[idx]=x;\n    if(head==-1//当是第一次插入时特殊处理\n    &#123;\n        ne[idx]=head;\n        head=idx;\n        idx++;\n        return;\n    &#125;\n    int i=head;\n    if(head!=-1)while(ne[i]!=-1)i=ne[i];//最后ne[i]=-1\n    ne[idx]=-1;\n    ne[i]=idx;\n    idx++;\n&#125;\nvoid dele(int a,int b)\n&#123;\n        if(e[h[a]]==b)h[a]=ne[h[a]];//如果在第一个元素的时候的操作方法\n       else\tfor(int i=h[a];ne[i]!=-1;i=ne[i])\n       &#123;\n           if(e[ne[i]]==b)//这里关系是\n           &#123;\n              ne[i]=ne[ne[i]];\n          &#125;\n      &#125;\n    \n&#125;\nbool find(int a,int b)\n&#123;\n    for(int i=h[a],i!=-1;i=ne[i])\n    &#123;\n        if(e[i]==b)return true;\n    &#125;\n    return false;\n&#125;\n\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);//单链表的n个头节点全部变成-1\n\n另一种选择：使用vector+list来构建（很方便）\n树图DFS模板：这个模板同样是使用邻接表来存储的\n\nbool st[N];//同其它，st数组在一开始开好，用来表示该节点是否被遍历过\nint dfs(int u)\n&#123;\n    st[u] = true; // st[u] 表示点u已经被遍历过\n\n    这里是要对DFS进行的操作部分\n    \n    for (int i = h[u]; i != -1; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (!st[j]) dfs(j);//递归进行向下遍历\n    &#125;\n&#125;\n\n846. 树的重心 - AcWing题库\n树的重心可能不唯一，但是树是唯一的\n该题解法：遍历删掉所有点之后连通块的最大值，之后在一堆最大值里面对比寻找出来最小的就行\n发现：获取了子树的大小也就获得了剩余树的大小（即全部节点数量减去子树的size就好）\n\n\n本题的本质是树的dfs， 每次dfs可以确定以u为重心的最大连通块的节点数，并且更新一下ans。\n也就是说，dfs并不直接返回答案，而是在每次更新中迭代一次答案。\n这样的套路会经常用到，在 树的dfs 题目中\n答案：\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10; //数据范围是10的5次方\nconst int M = 2 * N; //以有向图的格式存储无向图，所以每个节点至多对应2n-2条边\n\nint h[N]; //邻接表存储树，有n个节点，所以需要n个队列头节点\nint e[M]; //存储元素\nint ne[M]; //存储列表的next值\nint idx; //单链表指针\nint n; //题目所给的输入，n个节点\nint ans = N; //在最大连通块中寻找最小的那一个\n\nbool st[N]; //记录节点是否被访问过，访问过则标记为true\n\n//a所对应的单链表中插入b  a作为根 \nvoid add(int a, int b) &#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\n//返回以u为根的子树中节点的个数，包括u节点\nint dfs(int u) &#123;\n    int res = 0; //存储 删掉某个节点之后，最大的连通子图节点数\n    st[u] = true; //标记访问过u节点\n    int sum = 1; //存储 以u为根的树 的节点数, 包括u，如图中的4号节点\n    //访问u的每个子节点\n    for (int i = h[u]; i != -1; i = ne[i]) &#123;//链表的遍历\n        int j = e[i];\n        //因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过\n        if (!st[j]) &#123;// u节点的单棵子树节点数 如图中的size值\n            int s = dfs(j);  //获取j为根的子树中节点个数\n            res = max(res, s); // 记录最大联通子图的节点数\n            sum += s; //以j为根的树 的节点数，也就是1+s\n        &#125;//每一次这样执行一遍就进行了一个节点的更新\n    &#125;\n    //n-sum 如图中的n-size值；\n    res = max(res, n - sum); // 选择u节点为重心，最大的 连通子图节点数\n    ans = min(res, ans); //遍历过的假设重心中，最小的最大联通子图的 节点数\n    return sum;//返回子树的节点个数\n&#125;\n\nint main() &#123;\n    memset(h, -1, sizeof h); //初始化h数组 -1表示尾节点\n    cin &gt;&gt; n; //表示树的结点数\n\n    // 题目接下来会输入，n-1行数据，\n    // 树中是不存在环的，对于有n个节点的树，必定是n-1条边\n    for (int i = 0; i &lt; n - 1; i++) &#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b), add(b, a); //无向图\n    &#125;\n\n    dfs(1); //可以任意选定一个节点开始 u&lt;=n\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n树图BFS思想：从1开始不断扩展一层节点，然后不断向下辐射\n自闭环在dp问题中及逆行讨论\n模板：\n初始状态放到队列中\n写一个while循环，只要队列不空，在循环内每一次拿出队头，扩展队头的所有邻点\n只考虑第一次遍历，只要没有被遍历过，将x入队\n更新路径距离\n\n//使用邻接表进行存储稀疏图\nint ne[N],e[N],h[N];\n\nqueue&lt;int&gt; q;\nbool st[N];//同其它，st数组在一开始开好，用来表示该节点是否被遍历过\nst[1] = true; // 表示1号点已经被遍历过\nq.push(1);//对1进行入队\nwhile (q.size())\n&#123;\n    int t = q.front();//t是队头\n    q.pop();//出队\n\n    for (int i = h[t]; i != -1; i = ne[i])//这里对该头能到达的所有点进行一次访问\n    &#123;\n        int j = e[i];//j也就是对应的节点的值\n        if (!st[j])//只要没有访问过\n        &#123;\n            该干嘛干嘛，进行需要的操作\n            st[j] = true; // 表示点j已经被遍历过\n            q.push(j);//入队\n        &#125;\n    &#125;\n&#125;\n\n847. 图中点的层次 - AcWing题库\n该题答案：\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N=1e5+10;\n\nint h[N], e[N], idx, ne[N];\nint d[N]; //存储每个节点离起点的距离  d[1]=0\nint n, m; //n个节点m条边\nint q[N]; //存储层次遍历序列 0号节点是编号为1的节点\n\nvoid add(int a, int b)\n&#123;\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n&#125;\n\nint bfs()\n&#123;\n    int hh=0,tt=0;\n\n    q[0]=1; //0号节点是编号为1的节点\n\n    memset(d,-1,sizeof d);\n\n    d[1]=0; //存储每个节点离起点的距离\n\n    //当我们的队列不为空时\n    while(hh&lt;=tt)//不同的是这里用了数组模拟队列，一个道理\n    &#123;\n        //取出队列头部节点\n        int t=q[hh++];\n\n        //遍历t节点的每一个邻边\n        for(int i=h[t];i!=-1;i=ne[i])\n        &#123;\n            int j=e[i];\n            //如果j没有被扩展过\n            if(d[j]==-1)\n            &#123;\n                d[j]=d[t]+1; //d[j]存储j节点离起点的距离，并标记为访问过\n                q[++tt] = j; //把j结点 压入队列\n            &#125;\n        &#125;\n    &#125;\n\n    return d[n];//因为题目要求第一个点到第n个点就ok\n&#125;\n\nint main()\n&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i=0;i&lt;m;i++)\n    &#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b);\n    &#125;\n\n    cout&lt;&lt;bfs()&lt;&lt;endl;\n&#125;\n\n一致代价BFS：改进版本BFS\n\n\n拓扑排序：BFS的一种应用（AOV网，流程能否正确执行）拓扑、dfs、并查集都可以图中判断有没有环， floyd可以找最小环\n仅针对有向图，无向图没得拓扑定义：每条边都是起点在终点的前面，即所有的边都是从前指向后面的\n\n\n这种算一个拓扑\n\n\n这种就不算了（有一个环，只要有环就一定木大）\n可以证明：有向无环一定可以整成一个拓扑图\n如何进行一个求一个有向图有入度和出度，由所有都是从前指向后，则所有入度为0的点都可以排在当前最前面的位置\n\n一个无环图一定至少存在一个入度为0的点\n有向无环的top序不唯一\n\n思路：\n所有入度为0的点进行入队\n进行一个BFS，每一次出队一个队头，然后找出所有出队列这个点发出的边，删除边，同时边的另一侧的点的入度 -1。\n如果d[j]&#x3D;&#x3D;0,说明j之前的都排序好了，入队j就完事了\n如果所有点都进过队列，则可以拓扑排序，输出所有顶点。否则输出-1，代表不可以进行拓扑排序。\n\n模板：bool topsort()\n&#123;\n    int hh = 0, tt = -1;\n\n    // d[i] 存储点i的入度\n    for (int i = 1; i &lt;= n; i ++ )\n        if (!d[i])\n            q[ ++ tt] = i;\n\n    while (hh &lt;= tt)\n    &#123;\n        int t = q[hh ++ ];\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i];\n            if (-- d[j] == 0)\n                q[ ++ tt] = j;\n        &#125;\n    &#125;\n\n    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt == n - 1;\n&#125;\n\n848. 有向图的拓扑序列 - AcWing题库\nAcWing 848. $\\color{green}{拓扑排序–思路介绍+图解模拟+详细代码注释 }$ - AcWing\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N = 100010;\nint e[N], ne[N], idx;//邻接表存储图\nint h[N];//邻接表表头\nint q[N], hh = 0, tt = -1;//队列保存入度为0的点，也就是能够输出的点，\nint n, m;//保存图的点数和边数\nint d[N];////保存各个点的入度\n\nvoid add(int a, int b)&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;//邻接表的创建\n&#125;\n\nvoid topsort()&#123;\n    for(int i = 1; i &lt;= n; i++)&#123;//遍历一遍顶点的入度。\n        if(d[i] == 0)//如果入度为 0, 则可以入队列\n            q[++tt] = i;\n    &#125;//tt头，hh尾\n    while(tt &gt;= hh)&#123;//循环处理队列中点的\n        int a = q[hh++];//取出队头元素\n        for(int i = h[a]; i != -1; i = ne[i])&#123;//循环删除 a 发出的边\n            int b = e[i];//a 有一条边指向b\n            d[b]--;//删除边后，b的入度减1\n            if(d[b] == 0)//如果b的入度减为 0,则 b 可以输出，入队列\n                q[++tt] = b;\n        &#125;\n    &#125;\n    if(tt == n - 1)&#123;//进去了n个点\n        //如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序\n        for(int i = 0; i &lt; n; i++)&#123;//队列中保存了所有入度为0的点，依次输出\n            cout &lt;&lt; q[i] &lt;&lt; &quot; &quot;;\n        &#125;\n    &#125;\n    else//如果队列中的点的个数与图中点的个数不相同，则不可以进行拓扑排序\n        cout &lt;&lt; -1;//输出-1，代表错误\n&#125;\n\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;//保存点的个数和边的个数\n    memset(h, -1, sizeof h);//初始化邻接矩阵\n    while (m -- )&#123;//依次读入边\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        d[b]++;//顶点b的入度+1\n        add(a, b);//添加到邻接矩阵\n    &#125;\n    topsort();//进行拓扑排序\n    return 0;\n&#125;\n\n动态查找：二叉搜索树构建树：每个左孩子都比双亲小，每个右孩子都比双亲大\n插入节点：删除节点叶子节点直接删除\n节点p仅有一棵子树：• 直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树\n即类似链表的删除操作（懂得都懂）\n节点p既有左子树又有右子树：#include&lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nconst int M=1024;\nint tree[M]=&#123;0&#125;;\nint char_to_int(char a)\n&#123;\n    return (int)(a-&#39;0&#39;);\n&#125;\nvoid add_tree(int tree[],string a,int str_pos,int tree_pos,int judge)\n&#123;\n    int length=a.size();\n    if(str_pos&gt;length)return;\n    int num=char_to_int(a[str_pos]);\n    if(tree[tree_pos]==-1)//新节点插入\n    &#123;\n        tree[tree_pos]=num;\n        judge=0;\n        return;\n    &#125;\n    else if(num&gt;=tree[tree_pos])tree_pos=2*tree_pos+1;//大，向右边搜索\n    else tree_pos=2*tree_pos;//小,向左边搜索\n    add_tree(tree,a,str_pos,tree_pos,judge);\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    string ans;\n    cin&gt;&gt;ans;//初始化的输入\n    int total=ans.size();\n    for(int i=1;i&lt;=M;i++)\n    &#123;\n        tree[i]=-1;//-1表示是空指针\n    &#125;\n    tree[1]=char_to_int(ans[0]);\n    for(int i=1;i&lt;total;i++)//开始对树进行节点插入\n    &#123;\n        add_tree(tree,ans,i,1,1);\n    &#125;\n//    cout&lt;&lt;&quot;origin tree:  &quot;;\n//    for(int i=1;i&lt;=M;i++) &#123;\n//        if (tree[i] != -1)cout &lt;&lt; tree[i] &lt;&lt; &#39; &#39;;\n//    &#125;\n    cout&lt;&lt;endl;\n    int str_com[M];\n    string str_a;\n    for(int time=0;time&lt;n;time++)//循环多少次\n    &#123;\n        if(time==6)break;\n        for(int i=1;i&lt;=M;i++)\n        &#123;\n            str_com[i]=-1;//进行初始化\n        &#125;\n        cin&gt;&gt;str_a;//新的输入\n        str_com[1]=char_to_int(str_a[0]);\n        for(int i=1;i&lt;total;i++)//开始对树进行节点插入\n        &#123;\n            add_tree(str_com,str_a,i,1,1);\n        &#125;\n        int judge=1;\n//        cout&lt;&lt;&quot;new tree:  &quot;;\n        for(int i=1;i&lt;=M;i++) &#123;\n            if(str_com[i]!=tree[i])\n            &#123;\n                cout&lt;&lt;&quot;NO\\n&quot;;\n                judge=0;\n                break;\n            &#125;\n//            if (str_com[i] != -1)cout &lt;&lt; str_com[i] &lt;&lt; &#39; &#39;;\n        &#125;\n        if(judge==1)cout&lt;&lt;&quot;YES\\n&quot;;\n    &#125;\n    int time;\n    cin&gt;&gt;time;\n    return 0;\n&#125;\n\n动态查找：kd树（图形相关的东西会涉及，很重要的一种数据结构）🙏空间划分树：\n\n网格\n四叉树\n二维树\n二叉空间分割树\n\n二维树：最近邻查找\n实际就使用了剪枝（即切除不可能的子树）\n最短路问题朴素Dijkstra算法(和堆有关)（面试也有）书的作者写的算法通常都很长\n与bf算法最大区别：所有边只松弛一次（bf每条边多次）（这里很有可能数据结构考）\n\n\n堆优化：Dijkstra\n应用场景：（什么时候使用该算法）\n计算机网络中网络传输问题（参考ele实验室路由器）与协议\n迷宫问题（往下看图形化篇章）\n\n核心思想：贪心\n迪杰斯特拉算法适用于求正权有向图中，源点到其余各个节点的最短路径。注意：图中可以有环，但不能有负权边。\n思路：s:当前已经确定最短距离的点\n\n初始化距离（只有起点的距离是确定的）\n开始循环迭代n次，找到不在s中的距离最近的点\n用 t来更新其它所有点的距离（就能更新起点到每个点最短距离）\n\n模板：（朴素版本的Dijkstra）复杂度：n^2849. Dijkstra求最短路 I - AcWing题库\nAcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing\n注意这里读入都是从1开始\ndist注意初始化为+∞\nint g[N][N];  // 存储每条边\nint dist[N];  // 存储1号点到每个点的最短距离\nbool st[N];   // 存储每个点的最短路是否已经确定\nconst int INF=0x3f;//用于标注是无穷点\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    \n    memset(dist, 0x3f, sizeof dist);//所有距离初始化成正无穷\n    dist[1] = 0;//起点到起点当然是0力\n\n    for (int i = 0; i &lt; n - 1; i ++ )//这里i不重要，只知道需要循环n-1次就行（）\n    &#123;\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j &lt;= n; j ++ )\n            &#123;\n                if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))//如果没有确定最短路或者当前路不是最短的\n                &#123;t = j;&#125;//把t给更新，头个节点在第一步这里变成0\n            &#125;\n想想dijkstra的步骤，每一次都是先找到所有里面最近的点\n        // 用t更新其他点的距离\n        for (int j = 1; j &lt;= n; j ++ )\n            &#123;使用一开始寻找到的点逐个遍历所有其它可以到达的点进行比较并更新\n                dist[j] = min(dist[j], dist[t] + g[t][j]);//再次遍历一次所有\n            &#125;\n\n        st[t] = true;//将那一个点标记为已经访问并且\n    &#125;\n\n    if (dist[n] == 0x3f3f3f3f) return -1;//说明1和n不联通\n    return dist[n];//起点到终点的距离\n&#125;\n\n\n//这里是读入的时候，注意注意要从1开始\nfor(int i=1;i&lt;=n;i++)\n    &#123;\n        for(int j=1;j&lt;=n;j++)\n        &#123;\n            int tem;\n            cin&gt;&gt;tem;\n            if(tem==0)g[i][j]=INF;\n            else g[i][j]=tem;\n        &#125;\n    &#125;\n\n对于该题有重边和自环，因此需要考虑一下处理\n\n多重边仅保留路径最短的那一条\n自环肯定不会被纳入最短路，可以不考虑\n\n修改（任意一个点到其它所有点）#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=60;\nint n;      // n表示点数\nint g[N][N];        // 邻接矩阵，存储所有边\nint dist[N];        // 存储其他点到当前最小生成树的距离\nbool st[N];     // 存储每个点是否已经在生成树中，存储已纳入的集合\nvoid dijkstra(int s)//s是源点，其它都不重要\n&#123;\n    s=s+1;\n    memset(dist, 0x3f3f3f3f, sizeof dist);//所有距离初始化成正无穷\n    dist[s] = 0;//起点到起点当然是0力\n    for (int i = 0; i &lt; n - 1; i ++ )//这里i不重要，只知道需要循环n-1次就行（）\n    &#123;\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j &lt;= n; j ++ )\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))//如果没有确定最短路或者当前路不是最短的\n                t = j;//把t给更新，头个节点在第一步这里变成0\n        // 用t更新其他点的距离\n        for (int j = 1; j &lt;= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + g[t][j]);//再次遍历一次所有\n        st[t] = true;\n    &#125;\n    for(int i=1;i&lt;=n;i++)//这里就是最后的输出部分\n    &#123;\n        if(i!=s&amp;&amp;dist[i]!=0x3f3f3f3f)cout&lt;&lt;dist[i]&lt;&lt;&#39; &#39;;\n        else if(i!=s&amp;&amp;dist[i]==0x3f3f3f3f)cout&lt;&lt;-1&lt;&lt;&#39; &#39;;\n    &#125;\n&#125;\nint main()\n&#123;\n    int s;//s标记源点\n    cin&gt;&gt;n&gt;&gt;s;\n    for(int i=1;i&lt;=n;i++)\n    &#123;\n        for(int j=1;j&lt;=n;j++)\n        &#123;\n            int tem;\n            cin&gt;&gt;tem;\n            if(tem==0)g[i][j]=INF;\n            else g[i][j]=tem;\n        &#125;\n    &#125;\n    dijkstra(s);\n\n&#125;\n\n题目模板#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N = 510, M = 100010;\nconst int inf = 0x3f3f3f3f;\nint n, m;\nint g[N][N], dist[N];\nbool vis[N];\n\n\nint dijkstra()\n&#123;\n    memset(vis, 0, sizeof vis);\n    memset(dist, 0x3f, sizeof dist);\n    \n    dist[1] = 0;\n    for(int i = 1; i &lt;= n; i ++ )\n    &#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j ++ )\n        &#123;\n            if(!vis[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n            &#123;\n                t = j;\n            &#125;\n        &#125;\n        \n        vis[t] = 1;\n        for(int j = 1; j &lt;= n; j ++ )\n        &#123;\n            if(dist[j] &gt; g[t][j] + dist[t])\n            &#123;\n                dist[j] = g[t][j] + dist[t];\n            &#125;\n        &#125;\n    &#125;\n    if(dist[n] * 2&gt; inf)\n    &#123;\n        return -1;\n    &#125;\n    return dist[n];\n&#125;\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(g, 0x3f, sizeof g);\n    while (m -- )\n    &#123;\n        int in, out, weight;\n        cin &gt;&gt; in &gt;&gt; out &gt;&gt; weight;\n        g[in][out] = min(g[in][out], weight);\n    &#125;\n    \n    cout &lt;&lt; dijkstra() &lt;&lt; &quot;\\n&quot;;\n    return 0;\n&#125;\n\n模板：（优化版本的Dijkstra）实际有点像广搜的\n如果是一个稀疏图，但是还要用遍历矩阵（n2复杂度）容易时间爆掉\n使用小根堆优化\n\n\n也就是可以优化第一步，可以将第一步时间变成o1，第三步就要修改成mlogn，第二步不变\n即通过堆来存储，就可以减少计算量\n堆的实现方式：\n\n手写堆（好处在于方便维护）\n优先队列（c++的stl库已经预置好了），但是不支持修改任意一个元素，解决思路：每一次改变就插入一个新的数（好处方便操作，坏处会多了操作数，时间复杂度变成mlogm，但是方便，）\n\n因此直接使用c++内置的优先队列就ok\ntypedef pair&lt;int, int&gt; PII;\n//存储方式从邻接矩阵转换成邻接表\nint n;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N];        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\n\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;//这里的初始化和朴素版本是一样的\n    \n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;//这里使用优先队列维护所有距离，\n    heap.push(&#123;0, 1&#125;);      //第一次先把起点放进去，\n    // first存储距离，second存储节点编号\n\n    while (heap.size())//队列里面最多只有m个元素（最多只有m条边）\n    &#123;\n        auto t = heap.top();//堆的性质决定每一次都是距离最小的点\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;//说明这个点已经出来过了，不需要操作直接跳过到下一个点\n        st[ver] = true;\n\n        for (int i = h[ver]; i != -1; i = ne[i])//用这个点去更新其它所有点\n        &#123;\n            int j = e[i];//使用j来存储编号\n            if (dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] = distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);//如果更新成功就把这个点放到队列里面去\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n\n全部：\n有关优先队列库的函数：\n(110条消息) 【C++】优先队列详细讲解（原理+STL库调用）_半路杀出来的小黑同学的博客-CSDN博客_c++ 优先队列遍历\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;//堆的头文件\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;//堆里存储距离和节点编号\n\nconst int N = 1e6 + 10;\n\nint n, m;//节点数量和边数\nint h[N], w[N], e[N], ne[N], idx;//邻接表存储图\nint dist[N];//存储距离\nbool st[N];//存储状态\n\nvoid add(int a, int b, int c)//修改了一下add函数\n&#123;//w存储距离\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;\n&#125;\n\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大\n    dist[1] = 0;\n    //pair的比较，先比较第一个元素，第一个相等比较第二个。\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;//小根堆\n    heap.push(&#123;0, 1&#125;);//插入距离和节点编号\n\n    while (heap.size())//遍历了这个堆\n    &#123;\n        auto t = heap.top();//取距离源点最近的点，最小的\n        heap.pop();\n\n        int ver = t.second, distance = t.first;//ver:节点编号，distance:源点距离ver 的距离\n\n        if (st[ver]) continue;//如果距离已经确定，则跳过该点\n        st[ver] = true;\n\n        for (int i = h[ver]; i != -1; i = ne[i])//这里是链表的遍历方法\n            //更新ver所指向的节点距离\n        &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[ver] + w[i])\n            &#123;\n                dist[j] = dist[ver] + w[i];\n                heap.push(&#123;dist[j], j&#125;);//距离变小，则入堆\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n\nint main()\n&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\n    memset(h, -1, sizeof h);\n    while (m -- )\n    &#123;\n        int a, b, c;\n        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n        add(a, b, c);\n    &#125;\n\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n\nBellman-Ford算法（bf算法）复杂度通常为o（VE）\n会多次访问同一条边\n解决问题：\n可能有负边回路，Dijkstra如果判断的图中有负会导致距离成正无穷\n部分只能使用bf解决（如果有边数限制，就只能用bf）\n\n很牛逼：可以用任意存储方式，也可以用结构体\n应用：比如坐火车不能无限坐火车\n思路：\n\n两重循环，第二次循环所有边\n\nn次迭代，更新思路有点类似dijistra\n\n\n可以判断是否存在负回路,即是可以用来找负环（如果限制了走的边的个数就可以用来找最短路）的，但时间较高，一般使用spfa寻找负环\n模板：int n, m;       // n表示点数，m表示边数\nint dist[N];        // dist[x]存储1到x的最短路距离\n\nstruct Edge     // 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i &lt; n; i ++ )\n    &#123;\n        for (int j = 0; j &lt; m; j ++ )\n        &#123;\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] = dist[a] + w;\n            //正常的模板是自身进行迭代对比的\n        &#125;\n    &#125;\n//这里注意要/2是因为如果有负边到达终点会造成距离不满足，如10^9−2，小于无穷，但仍然并不存在最短路 \n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n&#125;\n\nAcWing 853. 有边数限制的最短路 - AcWing\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n\nusing namespace std;\n\nconst int N = 510, M = 10010;\n\nstruct Edge &#123;//使用结构体来存储所有的边\n    int a;\n    int b;\n    int w;\n&#125; e[M];//把每个边保存下来即可\nint dist[N];\nint back[N];//备份数组防止串联\nint n, m, k;//k代表最短路径最多包涵k条边\n\nint bellman_ford() &#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    for (int i = 0; i &lt; k; i++) &#123;//k次循环\n        memcpy(back, dist, sizeof dist);//每一次迭代之前都要对当前数组进行备份，防止出现串联使得打破有限边数的限制\n        for (int j = 0; j &lt; m; j++) &#123;//遍历所有边\n            int a = e[j].a, b = e[j].b, w = e[j].w;\n            dist[b] = min(dist[b], back[a] + w);\n            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来\n        &#125;\n    &#125;\n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    else return dist[n];\n\n&#125;\n\nint main() &#123;\n    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);\n    for (int i = 0; i &lt; m; i++) &#123;\n        int a, b, w;\n        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);\n        e[i] = &#123;a, b, w&#125;;\n    &#125;\n    int res = bellman_ford();\n    if (res == -1) puts(&quot;impossible&quot;);//说明最短路长度不存在\n    else cout &lt;&lt; res;\n\n    return 0;\n&#125;\n\nspfa(队列优化版本的Bellman-Ford)处理稀疏图，使用邻接表进行存储\n可以视为各方面都更加优秀的bf，就是对于bf进行一个优化\nAcWing 851. spfa求最短路—图解–$\\color{red}{海绵宝宝来喽}$ - AcWing\n其实正权图也可以用spfa去整\nbf缺点：每一次都要迭代所有边进行更新（每一次都要全部扫描）\n优化：使用广搜进行优化\n思路：\n\n起点放到队列里面去\n只要队列不空，就是广搜的迭代操作\n即我更新过谁，我再用谁去更新别人，我后面的人才会更小\n\n图中一定不能有负环(但是可以有负权边)，不然不能用\n时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n;      // 总点数\nint h[N], w[N], e[N], ne[N], idx;  // 邻接表存储所有边\nint dist[N];        // 存储每个点到1号点的最短距离\nbool st[N];     // 存储每个点是否在队列中，防止队列中存储重复点\n\n// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof dist);//初始化所有点的距离\n    dist[1] = 0;\n\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n//使用队列就是为了如起点更新过bc，则下一步仅针对bc进行更新\n    while (q.size())\n    &#123;\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;//该点不在队列里面\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])//如果可以更新\n            &#123;\n                dist[j] = dist[t] + w[i];\n                if (!st[j])     \n                    // 如果队列中已存在j，则不需要将j重复插入\n                &#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n\n851. spfa求最短路 - AcWing题库\nspfa判断是否存在负环时间复杂度是 O(nm), n 表示点数，m 表示边数\n原理：使用dist数组表示1号数组到其它数组的距离，使用cnt表示当前最短路的边数\n模板：int n;      // 总点数\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N], cnt[N];       \n// dist[x]存储1号点到x的最短距离，\n//cnt[x]存储1到x的最短路中经过的点数\n//每一次更新表示\nbool st[N];     // 存储每个点是否在队列中\n\n// 如果存在负环，则返回true，否则返回false。\nbool spfa()\n&#123;\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; i ++ )\n    &#123;\n        q.push(i);//这里不同在于要全部入对保证每个点都能进行判断\n        st[i] = true;\n    &#125;\n\n    while (q.size())\n    &#123;\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;//更新的时候同步更新边数\n                if (cnt[j] &gt;= n) return true; \n // 如果从1号点到x的最短路中包含至少n个边（抽屉原理），则说明存在环\n //这个环一定是个负环（因为spfa选择短的路，为了走短还多走一个点一定是存在负环）\n                if (!st[j])\n                &#123;\n                    q.push(j);\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\nFLOYID算法（Dijkstra进一步输出全部）很简单，针对所有路\n原理：动态规划\nd[k,i,j]，从i点出发，经过k个点，最终到达j点\n那么有d[k,i,j]&#x3D;d[k-1,i,k]+d[k-1,k,j]&#x2F;&#x2F;右边各经过了k-1个点\n可以优化，去掉一维，即d[i,j]&#x3D;d[i,k]&#x3D;d[k,j]\n应用：可以对有负边进行操作（但是不能有负回路）\nFLOYID可以求出所有点之间的最短路径（很暴力很牛逼很简洁很费时）\n使用邻接矩阵存储所有边\n模板时间：n^3\n//邻接矩阵初始化：\n    for (int i = 1; i &lt;= n; i ++ )\n        for (int j = 1; j &lt;= n; j ++ )\n            if (i == j) d[i][j] = 0;//自身到自身为0\n            else d[i][j] = INF;\n\n\n\n// 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k = 1; k &lt;= n; k ++ )\n        for (int i = 1; i &lt;= n; i ++ )\n            for (int j = 1; j &lt;= n; j ++ )\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n\n对于求floyid，类似spfa判断无穷情况：\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N = 210, M = 2e+10, INF = 1e9;\n\nint n, m, k, x, y, z;\nint d[N][N];\n\nvoid floyd() &#123;\n    for(int k = 1; k &lt;= n; k++)\n        for(int i = 1; i &lt;= n; i++)\n            for(int j = 1; j &lt;= n; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n\nint main() &#123;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    for(int i = 1; i &lt;= n; i++)\n        for(int j = 1; j &lt;= n; j++)\n            if(i == j) d[i][j] = 0;\n            else d[i][j] = INF;\n    while(m--) &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        d[x][y] = min(d[x][y], z);\n        //注意保存最小的边\n    &#125;\n    floyd();\n    while(k--) &#123;\n        cin &gt;&gt; x &gt;&gt; y;\n        if(d[x][y] &gt; INF/2) puts(&quot;impossible&quot;);\n        //由于有负权边存在所以约大过INF/2也很合理\n        else cout &lt;&lt; d[x][y] &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\nprim最小生成树非常非常像dijkstra\n处理步骤：\n\n首先全部初始化为+无穷\n开始循环迭代，用t更新到集合的距离（dijkstra这里是t更新到起点的距离）\nst[t]&#x3D;true（真的真的很像dijkstra）\n\n点到集合的距离指点到集合的所有路径中选择最短的那一条\n注意一点 ，这个二维数组要下标是1到n\n一次循环只会更新一个最近点\n每次更新最近点之后就会在该点可触及范围内更新与其它点的距离\n朴素prim模板int n;      // n表示点数\nint g[N][N];        // 邻接矩阵，存储所有边\nint dist[N];        // 存储其他点到当前最小生成树的距离\n\nbool st[N];     // 存储每个点是否已经在生成树中，存储已纳入的集合\nconst int INF=0x3f\n\n// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);//所有距离初始化+∞\n\n    int res = 0;//res存储所有边里面最小生成树的所有边长度之和\n    //每一次为了寻找到当前集合外所有点当中距离最小的点\n \n    for (int i = 0; i &lt; n; i ++ )//n次迭代\n    &#123;\n        int t = -1;\n        //必须要在集合外，所以从1开始，st\n        for (int j = 1; j &lt;= n; j ++ )\n            //必须在集合外并且t的距离大于当前点的距离\n            &#123;\n                if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))//t==-1是最初始时候的情况\n                &#123;\n                    t = j;\n                &#125;\n            &#125;\n        //现在t存的就是当前距离最小的点\n        \n        //不是第一个点并且距离是+∞\n        //说明当前这个图不联通，不存在最小生成树\n        if (i &amp;&amp; dist[t] == INF) return INF;\n\n        if (i) res += dist[t];\n        //否则不是第一条边就把dist加到答案中\n        st[t] = true;//说明这一个点已经是树集合的一份子咧\n\n        //对了注意顺序问题哦，一定要先累加再进行更新\n        //这一步更新一下其它点到集合的距离，同dijkstra\n        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);\n        \n    &#125;\n\n    return res;\n&#125;\n\n858. Prim算法求最小生成树 - AcWing题库\nAcWing 858. Prim算法求最小生成树：图解+详细代码注释（带上了保存路径） - AcWing\nAcWing 858. $\\Huge\\color{MediumTurquoise}{prim 与dijkstra的区别}$ - AcWing\n//2022.6.1 更新\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int N = 510;\nint g[N][N];//存储图\nint dt[N];//存储各个节点到生成树的距离\nint st[N];//节点是否被加入到生成树中\nint pre[N];//节点的前去节点\nint n, m;//n 个节点，m 条边\n\nvoid prim()\n&#123;\n    memset(dt,0x3f, sizeof(dt));//初始化距离数组为一个很大的数（10亿左右）\n    int res= 0;\n    dt[1] = 0;//从 1 号节点开始生成 \n    for(int i = 0; i &lt; n; i++)//每次循环选出一个点加入到生成树\n    &#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j++)//每个节点一次判断\n        &#123;\n            if(!st[j] &amp;&amp; (t == -1 || dt[j] &lt; dt[t]))//如果没有在树中，且到树的距离最短，则选择该点\n                t = j;\n        &#125;\n\n        //2022.6.1 发现测试用例加强后，需要判断孤立点了\n        //如果孤立点，直返输出不能，然后退出\n        if(dt[t] == 0x3f3f3f3f) &#123;\n            cout &lt;&lt; &quot;impossible&quot;;\n            return;\n        &#125;\n\n\n        st[t] = 1;// 选择该点\n        res += dt[t];\n        for(int i = 1; i &lt;= n; i++)//更新生成树外的点到生成树的距离\n        &#123;\n            if(dt[i] &gt; g[t][i] &amp;&amp; !st[i])//从 t 到节点 i 的距离小于原来距离，则更新。\n            &#123;\n                dt[i] = g[t][i];//更新距离\n                pre[i] = t;//从 t 到 i 的距离更短，i 的前驱变为 t.\n            &#125;\n        &#125;\n    &#125;\n\n    cout &lt;&lt; res;\n\n&#125;\n\nvoid getPath()//输出各个边\n&#123;\n    for(int i = n; i &gt; 1; i--)//n 个节点，所以有 n-1 条边。\n\n    &#123;\n        cout &lt;&lt; i &lt;&lt;&quot; &quot; &lt;&lt; pre[i] &lt;&lt; &quot; &quot;&lt;&lt; endl;// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。\n    &#125;\n&#125;\n\nint main()\n&#123;\n    memset(g, 0x3f, sizeof(g));//各个点之间的距离初始化成很大的数\n    cin &gt;&gt; n &gt;&gt; m;//输入节点数和边数\n    while(m --)\n    &#123;\n        int a, b, w;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;//输出边的两个顶点和权重\n        g[a][b] = g[b][a] = min(g[a][b],w);//存储权重\n    &#125;\n\n    prim();//求最下生成树\n    //getPath();//输出路径\n    return 0;\n&#125;\n\n与Dijkstra类似，Prim算法也可以用堆优化，优先队列代替堆，优化的Prim算法时间复杂度O(mlogn)。适用于稀疏图，但是稀疏图的时候求最小生成树，Kruskal 算法更加实用。\n克鲁斯卡尔最小生成树时间是mlogm，思路也简单（不用考虑prim的）\n核心：删除，判断\n优点：\n\n稀疏图尽管使用kruskal就ok\nkruskal也可以处理负权边的哦\nkruskal同bf算法，对于存储方式不挑剔，能存就行，可以用结构体\n\n\n将所有边按照权重从小到大进行排序（这里用原有的排序就行）\n枚举每条边ab（权重是c），如果ab不连通（即在），就将这条边加入到集合里面\n只要边数是节点数-1就ok辽\n\n这里建议参考并查集例题，837题\n837. 连通块中点的数量 - AcWing题库\nkruskal是使用一个并查集去维护的，堆用于去做dijkstra\nAcWing 859. Kruskal算法求最小生成树—$\\color{red}{海绵宝宝来喽}$ - AcWing\n模板#include&lt;algorithm&gt;//需要引入这个头文件实现对结构体的大小排序操作\nint n, m;       // n是点数，m是边数\nint p[N];       // 并查集的父节点数组\n\nstruct Edge     // 存储边\n&#123;\n    int a, b, w;\n\n    //下面这里是结构体的另一个函数，重载一下＜\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];//这里是开了一个结构体数组叫edges,有M个\n\nint find(int x)     // 并查集核心操作\n&#123;\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n&#125;\n\nint kruskal()\n&#123;\n    sort(edges, edges + m);//nlogn\n\n    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集\n\n    //res存最小生成树里边所有边的权重之和\n    //cnt存的是当前增加了多少条边\n    int res = 0, cnt = 0;\n    //这里是从小到大枚举所有边\n    for (int i = 0; i &lt; m; i ++ )\n    &#123;\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n\n        a = find(a), b = find(b);\n        //使用一个并查集来判断两个点是否联通\n           // 如果两个连通块不连通，则将这两个连通块合并\n         if (a != b) \n        &#123;\n            p[a] = b;//这里是两个点的合并操作\n            res += w;\n            cnt ++ ;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;\n\n题：\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nconst int N = 100010;\nint p[N];//保存并查集\n\nstruct E&#123;\n    int a;\n    int b;\n    int w;\n    bool operator &lt; (const E&amp; rhs)&#123;//通过边长进行排序\n        return this-&gt;w &lt; rhs.w;\n    &#125;\n\n&#125;edg[N * 2];\nint res = 0;\n\nint n, m;\nint cnt = 0;\nint find(int a)&#123;//并查集找祖宗\n    if(p[a] != a) p[a] = find(p[a]);\n    return p[a];\n&#125;\nvoid klskr()&#123;\n    for(int i = 1; i &lt;= m; i++)//依次尝试加入每条边\n   &#123;\n        int pa = find(edg[i].a)；// a 点所在的集合\n        int pb = find(edg[i].b);// b 点所在的集合\n        if(pa != pb)&#123;//如果 a b 不在一个集合中\n            res += edg[i].w;//a b 之间这条边要\n            p[pa] = pb;// 合并a b\n            cnt ++; // 保留的边数量+1\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n\n    cin &gt;&gt; n &gt;&gt; m;//同样注意这里是1开始，因此下面sort函数起始也是+1\n    for(int i = 1; i &lt;= n; i++) p[i] = i;//初始化并查集\n    for(int i = 1; i &lt;= m; i++)&#123;//读入每条边\n        int a, b , c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;\n        edg[i] = &#123;a, b, c&#125;;\n    &#125;\n    sort(edg + 1, edg + m + 1);//按边长排序\n    klskr();//并查集初始化包含在函数中\n    if(cnt &lt; n - 1) &#123;//如果保留的边小于点数-1，则不能连通\n        cout&lt;&lt; &quot;impossible&quot;;\n        return 0;\n    &#125;\n    cout &lt;&lt; res;\n    return 0;\n&#125;\n\n二分图染色法判定：使用性质：一个图是二分图当且仅当图中不含奇数环&#x2F;奇圈\n奇数环：环，而且当中边的数量是奇数\n时间复杂度是 O(n+m), n 表示点数，m 表示边数\n思路：一条边的两个端点一定属于不同的集合，一个联通块中只要一个点的颜色确定，其它点的颜色都确定（白色只能与黑色相邻，黑色只能与白色相邻），由于不存在奇数环，染色过程中一定没有矛盾\n因此需要将整个图遍历一遍，由于图没有权，负边，因此可以用dfs，bfs来弄，模板这里使用dfs\n因此，如果有矛盾，那肯定就不是了呗\n则判定两个关键函数：\n\ndfs\n判定是否出现矛盾\n\nint n;      // n表示点数\nint h[N], e[M], ne[M], idx;     // 邻接表存储图\nint color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n//三色染色法，考虑go语言runtime部分三色标定部分\n\n// 参数：u表示当前节点，c表示当前点的颜色\n//这里使用深搜因为相对而言深搜的代码量更少，只用回溯，不需要手写队列\nbool dfs(int u, int c)\n&#123;\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (color[j] == -1)\n        &#123;\n            if (!dfs(j, !c)) return false;\n        &#125;\n        else if (color[j] == c) return false;\n    &#125;\n\n    return true;\n&#125;\n\nbool check()\n&#123;\n    memset(color, -1, sizeof color);\n    bool flag = true;\n    for (int i = 1; i &lt;= n; i ++ )\n        if (color[i] == -1)\n            if (!dfs(i, 0))\n            &#123;\n                flag = false;\n                break;\n            &#125;\n    return flag;\n&#125;\n\n随便整一道例题康康：\nAcWing 860. 染色法判定二分图—$\\color{green}{详细代码注释+图解}$ - AcWing\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N = 100010 * 2;\nint e[N], ne[N], idx;//邻接表存储图\nint h[N];\nint color[N];//保存各个点的颜色，0 未染色，1 是红色，2 是黑色\nint n, m;//点和边\n\nvoid add(int a, int b)//邻接表插入点和边\n&#123;\n    e[idx] = b, ne[idx]= h[a], h[a] = idx++;\n&#125;\n\nbool dfs(int u, int c)//深度优先遍历\n&#123;\n    color[u] = c;//u的点成 c 染色\n\n    //遍历和 u 相邻的点\n    for(int i = h[u]; i!= -1; i = ne[i])\n    &#123;\n        int b = e[i];                   \n        if(!color[b])//相邻的点没有颜色,则递归处理这个相邻点\n        &#123;\n            if(!dfs(b, 3 - c)) return false;//（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）\n                                            //（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）\n        &#125;\n        else if(color[b] &amp;&amp; color[b] != 3 - c)//如果已经染色，判断颜色是否为 3 - c\n        &#123;                                     \n            return false;//如果不是，说明冲突，返回                   \n        &#125;\n    &#125;\n    return true;\n&#125;\n\nint main()\n&#123;\n    memset(h, -1, sizeof h);//初始化邻接表\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)//读入边\n    &#123;\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        add(a, b), add(b, a);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)//遍历点\n    &#123;\n        if(!color[i])//如果没染色\n        &#123;\n            if(!dfs(i, 1))//染色该点，并递归处理和它相邻的点\n            &#123;\n                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;//出现矛盾，输出NO \n                return 0;\n            &#125;\n\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;//全部染色完成，没有矛盾，输出YES\n    return 0;\n&#125;\n\n匈牙利算法作用：给定一个二分图，求它的最大匹配（可以在一个较短的时间内匹配）\n把它想象成月老匹配对象算法\n\n\n一些概念：\n\n二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E}中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。\n二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数\n\n基本思路：\n\n对于每个男生从前往后看（果然开始当月老看了），如果女生处于单身状态则可以匹配\n再看下一个，某个男生匹配某个女生，如果该女生已经被匹配，这个男生也不会善罢甘休（什么黄毛剧情），如果之前匹配的男生a可以更换女生（越来越奇怪了），男生b会与这个女生匹配（他甚至专门用了绿色绝了）\n\n所以很多时候做错是没事的，错过是真的会后悔\n\n\n时间复杂度（n*m）（最坏情况），实际上时间是会很少的\n注意：如果对左边进行遍历，那么边就要存储左边指向右边的\n模板：int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     // 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)//判断能否找到妹子\n&#123;//使用枚举\n    for (int i = h[x]; i != -1; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (!st[j])//如果妹子之前没有考虑过\n        &#123;\n            st[j] = true;\n            \n            //如果妹子之前没有匹配任何男生或者女生匹配的男生可以找到下家\n            if (match[j] == 0 || find(match[j]))\n            &#123;\n                match[j] = x;//当前妹子匹配就改变了\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;//就是在匹配不上，那咱就算了\n&#125;\n\n// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\n//这里是main函数里面的部分\nint res = 0;\nfor (int i = 1; i &lt;= n1; i ++ )\n&#123;\n    memset(st, false, sizeof st);//先把所有的妹子清空\n    if (find(i)) res ++ ;//如果可以找到的话，成功数量增加\n&#125;\n\nAcWing 861. 二分图的最大匹配 - AcWing\nAcWing 861. 二分图最大匹配 - 如果你看了别的题解，仍然对递归写法的st数组心存疑虑，看看这里【21.12.7更新】 - AcWing\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 510 , M = 100010;\nint n1,n2,m;\nint h[N],ne[M],e[M],idx;\nbool st[N];\nint match[N];\n\nvoid add(int a , int b)\n&#123;\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n&#125;\n\nvoid init()\n&#123;\n    memset(h,-1,sizeof h);\n&#125;\n\nint find(int x)\n&#123;\n    //遍历自己喜欢的女孩\n    for(int i = h[x] ; i != -1 ;i = ne[i])\n    &#123;\n        int j = e[i];\n        if(!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定\n        &#123;\n            st[j] = true;//那x就预定这个女孩了\n            //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功\n            if(!match[j]||find(match[j]))\n            &#123;\n                match[j] = x;\n                return true;\n            &#125;\n\n        &#125;\n    &#125;\n    //自己中意的全部都被预定了。配对失败。\n    return false;\n&#125;\nint main()\n&#123;\n    init();\n    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;\n    while(m--)\n    &#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b);\n    &#125;\n\n\n    int res = 0;\n    for(int i = 1; i &lt;= n1 ;i ++)\n    &#123;  \n         //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化\n          memset(st,false,sizeof st);\n        if(find(i)) \n          res++;\n    &#125;  \n\n    cout&lt;&lt;res&lt;&lt;endl;\n&#125;\n\n关键路径（AOE网，拓扑plus版本）基础背景知识：AOE网：AOV网基础上加上每个节点（工序）所消耗的时间\nAOE网要建立再活动之间制约关系没有矛盾的基础之上，再来分析完成整个工程需要多少时间，或者为了缩短完成工程所需时间，应当加快哪些活动\n关键路径：从源点到汇点具有最大长度的路径：\n关键活动：关键路径上的活动（实际上就可以理解成多种活动并行执行，有些耗时最长的活动来衡量整体工程的执行时间）-&gt;修改关键活动才会对整个工期长度进行实际减少\n核心：寻找关键活动方法：找到所有活动的最早开始时间和最晚开始时间，并且进行比较，如果相等意味着此活动是关键活动，活动间的路径是关键路径\n贪心与最短路关系：dp问题可以视为特殊的最短路问题，即最短路包含dp，是一个没有环存在的最短路，dp实际是深搜，保证可以到达终点，但不保证是最短路\n暴力搜索回溯法回溯法效率：低，但比for强\n解决问题：for嵌套无法解决时候理论基础：来源于递归的回溯(隐藏在递归的下面)，与二叉树遍历，深度优先搜索混在一起进行，二叉树在返回的过程中也用到了回溯\n可解决问题：传统for暴力搜索方式无法解决\n\n组合问题：（如一串数字询问可以组合的方式数）组合强调没有顺序\n排列问题：排列强调元素顺序\n切割问题：（字符串，加上某种限定条件，询问切割方式）\n子集问题：找出所有子集\n棋盘问题：（典中典皇后，数独)\n\n小总结，用于解决组合和排列\nADT:可以抽象为一个树形结构，可以抽象为一棵n叉树，树的宽度是集合的大小，即每个节点处理的集合的大小-&gt;这里通常使用for循环来处理。树的深度（纵方向）也就是递归的深度，\n回溯模板void backtracking(参数) &#123;\n    if (终止条件) &#123;//终止条件\n        存放结果;//一般问题都是在叶子节点收集结果（最后一个节点）\n                //而子集问题每一个节点都要收集结果\n        return;//收集完结果之后返回\n    &#125;\n    for (选择：本层集合中元素（树中节点的数量就是集合的大小）) &#123;\n        处理节点;\n        backtracking(路径，选择列表); // 递归，这里是深度，向下探索\n        回溯，\n        撤销处理结果//结束循环\n    &#125;\n&#125;\n\n棋盘典中点：皇后位置c++直接完整版本代码：（LeetCode 版本）\nclass Solution &#123;\nprivate:\nvector&lt;vector&lt;string&gt;&gt; result;\n// n 为输入的棋盘大小\n// row 是当前递归到棋牌的第几行了\nvoid backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;\n    if (row == n) &#123;//回溯到最后一行，说明满足情况了\n        result.push_back(chessboard);\n        return;\n    &#125;\n    for (int col = 0; col &lt; n; col++) &#123;\n        if (isValid(row, col, chessboard, n)) &#123; // 验证合法就可以放\n            chessboard[row][col] = &#39;Q&#39;; // 放置皇后\n            backtracking(n, row + 1, chessboard);//再进一行进行检验\n            chessboard[row][col] = &#39;.&#39;; // 回溯，撤销皇后\n        &#125;\n    &#125;\n&#125;\nbool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;\n    int count = 0;\n    // 检查列\n    for (int i = 0; i &lt; row; i++) &#123; // 这是一个剪枝\n        if (chessboard[i][col] == &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    // 检查 45度角是否有皇后\n    for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) &#123;//另一个剪支\n        if (chessboard[i][j] == &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    // 检查 135度角是否有皇后\n    for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;\n        if (chessboard[i][j] == &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;\n        result.clear();\n        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));\n        backtracking(n, 0, chessboard);//注意这里是从0开始的，所以最后到n，实际上以及对n层进行了判断\n        return result;\n    &#125;\n&#125;;\n\n/*总结操作流程：\n类似二叉树，对每个节点进行遍历，实际复杂度是n^2，从开头一直向下延申，可满足情况进行返回\n\nc++数组版本皇后问题:老子自己写的！（双手叉腰）\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\nconst int maxn=9;\nint solu[maxn]=&#123;0&#125;;\nint qn[maxn]=&#123;0&#125;;\nbool isValid(int posj,int posi)//最后那个pos也就是棋子的坐标\n&#123;\n    //posi=i,posj=qn[i]\n    if(posi==0)return true;\n    for(int i=0;i&lt;posi;i++)\n    &#123;\n        if(qn[i]==posj)return false;//相同的列判断\n    &#125;\n    for(int i=posi-1;i&gt;=0;i--)//45判断\n    &#123;\n        if(posi-i==posj-qn[i])return false;\n    &#125;\n    for(int i=posi-1;i&gt;=0;i--)//135\n    &#123;\n        if(posi-i==qn[i]-posj)return false;\n    &#125;\n    return true;\n&#125;\nvoid backtracing(int n,int row)\n&#123;\n    if(row==n)&#123;//终止了，找到了其中一种解决方案\n        cout&lt;&lt;&quot;bottom reached\\n&quot;;\n        cout&lt;&lt;&quot;solution:\\n&quot;;\n        for(int  i=0;i&lt;n;i++)\n        &#123;\n            cout&lt;&lt;&quot;row &quot;&lt;&lt;i+1&lt;&lt;&quot; equals to &quot;&lt;&lt;qn[i]+1&lt;&lt;&quot; \\n&quot;;\n        &#125;\n        cout&lt;&lt;&quot;go find other solution\\n\\n&quot;;\n        return;\n    &#125;\n    else&#123;\n        for(int i=0;i&lt;n;i++)//注意这里的传参\n        &#123;\n            qn[row]=i;//row，行固定，列用变量i对每一行进行遍历，如果满足之前条件进入下一行\n            if(isValid(qn[row],row))//该行该位置能否放\n            &#123;\n\n                backtracing(n,row+1);//可以就继续往下走\n\n            &#125;\n        &#125;\n    &#125;\n\n&#125;\n\nint main()\n&#123;\n    int n;\n\n    cin&gt;&gt;n;\n    backtracing(n,0);\n&#125;\n\n图形化数据结构学习：栈：非递归汉诺塔难点：不能使用递归（如果使用递归在画图之前会全部更新完，最后只会给出结果），改成非递归方式\n本质：将递归结构在循环中实现\n老师解法：\n参考博客：(99条消息) 汉诺塔的非递归实现（堆栈）_.别拖至春天.的博客-CSDN博客_汉诺塔的非递归实现\n![屏幕截图 2022-10-12 155526](D:\\typora note\\屏幕截图 2022-10-12 155526.png)\n代码以及注释：\nops是空栈，用于保存指令，并且在n&#x3D;&#x3D;1的时候才进行弹出操作\nif(!ops.empty()) &#123;\n                //\n                op current = ops.top();//非空赋值\n                ops.pop();//\n                if(current.n == 1) &#123;//每一个待处理的物品数量变成1的时候进行弹栈，一直弹到不是1\n                    //\n                    // 这里的current.start等等已经改变成对应的代号了\n                    //\n\n                    int d = stacks[current.start]-&gt;top();\n                    stacks[current.start]-&gt;pop();\n                    stacks[current.end]-&gt;push(d);\n                &#125; else &#123;\n                    //这里应该就是正常非递归\n                    //如果不是1，进行分解,\n                    //如要做到(n,a,b,c),n个从a到c\n                    //分解，并且按照顺序进栈（当然弹出的时候就是相反的顺序）\n                    //1:(n-1,a,c,b)\n                    //2:(1,a,b,c)\n                    //3:(n-1,b,a,c)\n                    //因为程序执行语言是从上到下，但是指令压栈应该是321，因此最后是321\n                    //ops是一个存储指令的栈\n                    ops.push(op(current.n - 1, current.via, current.start, current.end));//3\n                    ops.push(op(1, current.start, current.via, current.end));//2\n                    ops.push(op(current.n - 1, current.start, current.end, current.via));//1\n                &#125;\n            &#125;\n\n南大关于非递归的应用（对于C语言作为状态机的分析讲解）\n\n\n队列：迷宫生成及解决重点解决问题：回溯法\n顺便要学习的算法：迪杰斯特拉解法（可以等一等再看看）\n","tags":["学习笔记"]},{"title":"软件分析与设计","url":"/2023/03/08/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/","content":"导论软件生命周期\n\n软件定义\n软件开发\n软件维护\n\n人年&#x2F;人月：工程计量单位：一个人干一年&#x2F;月\n相对于实体制造业，软件开发主要困难：正确的软件需求分析与架构设计\n建模：对于某一问题进行一定程度的抽象以更好理解其本质\n软件建模：编码之前对软件应用进行的设计\nUML：统一模型语言：便于理解\n多视图建模\n用例建模：系统的功能性需求按照用例与参与者进行定义\n静态建模：提供系统的结构化视图，类按照其属性及其与其它类的关系进行定义\n动态建模：系统行为视图，主要描述对象之间的交互行为\n软件体系结构：系统的总体结构\n\n**COMET：主要建模方法，基于面向对象 的核心方法：Collaborative Object Modeling **\nch1：软件生存周期模型（第三章）软件生存周期：将软件本身视为不断迭代的产物，即每一个阶段都有相应目标和计划\n软件过程模型：对于软件开发过程中的抽象\n几种开发模型：瀑布模型：有迭代和重复\n抛弃型模型：复杂系统开发。可以理解为每一个瀑布模型的阶段都开发一个相应的小系统用于检验设计正确性与阐明用户需求\n演化式模型：首先开发一个最小系统（满足基本要求）然后不断在基础上添加内容（想想南大操作系统课程的说法，按照所需内容开发一个最小的核心然后不断添加内容）中级实训实际就可以考虑这种方法\n螺旋模型：强调风险分析\nUSDP：统一软件开发过程\n软件验证和确认：\nSQA：软件测试？\n软件测试：单元测试：\n集成测试：\n系统测试：压力测试等等（如web应用如何处理大量请求）\n3.8日问题：\n\n事件同步是异步的怎么理解？\n\n即发出消息之后是否需要等待\n如网络连接之后发送请求，需要发送方向接收方发送请求，接受方再回复，这需要立刻执行，属于同步\n如聊天，一方说话，一方不需要立刻回复，属于异步\n\n\n生产者&#x2F;消费者问题为何不需要事件同步+ \n\n系统需求与需求分析的差别\n\n需求分析：透过调研问卷、访谈等方式，挖掘客户所描述需求背后的管理诉求和要解决的问题‘\n**系统分析是在需求分析的基础上，抓大放小，针对客户核心价值诉求，结合工具和方法逐步*勾勒和细化解决方案的过程*。\n\n\n消息与事件\n\n\n异步消息通信：\n\n松耦合的消息通信，再生产者和消费者之间可以建立一条消息队列\n\n软件模式经常出现问题：重复造轮子\n软件模式：\n\n体系结构\n\n定义一个系统中主要子系统的结构\n\n\n分析模式：\n\n采用静态模型\n\n\n设计模式：描述重复出现的设计问题，对问题的解决方案以及解决方案工作的上下文（去读大话设计模式）\n\n属于一种比类粒度更大的使用方式\n\n\n习惯用法\n\n针对特定编程语言的设计模式\n如：\nC与C++偏向底层，但是同时内存管理差，自己可以做到的东西多，运行速度快\nGo：垃圾回收机制完整，适合并发，服务器与云的构建\nJavascript:一种脚本语言，但是指网页中的事件\n\n\n\n\n\n构件：\n\n定义：自包含的，且具有良好定义接口的对象\n\n链接器：\n\n封装多个构件之间的互连协议\n\n软件质量属性\n定义：软件的质量需求，也称为非功能性需求\n包括：\n可维护性：部署之后能够被更改的程度\n可修改性：最初开发期间和最初开发之后能够被修改的成都\n可测试性：能够被测试的程度\n可追踪性：每个阶段产品能够被追溯到上一阶段产品的程度\n可伸缩性：针对用户量增长时如何快速应对\n可复用性：之后的系统也可以使用\n性能：吞吐量，响应速度等\n安全性：抵御安全威胁的程度\n可用性：能够解决系统失效问题的程度（某个模块失效了能不能快速顶住）\n\n\n\n总结：\n对象 ，类，信息隐藏，集成\n主动对象，被动对象\n顺序应用，并发应用\n\n软件体系结构COMET：写作的对象建模和设计方法\n差异概念：用户与客户\n\n用户：软件面对的人（如使用聊天系统的人）\n客户：发起系统构建的人（即甲方爸爸），如提出要求构建一个聊天系统\n\n用例：\n\n参与者与用户交互\n\n需求建模：开发需求模型\n分析模型：状态图\n\n如对于各种可能的操作应当有怎样的输出回复\n\n设计建模\n设计系统的体系结构\n\n构建软件与硬件关系\n构件与相关的链接关系确定\n\n\n问题域的分析模型映射到解域的设计模型\n\n提供子系统组织准则将系统组织为子系统\n\n子系统设计\n\n顺序系统\n信息隐藏\n类\n继承\n\n\n并发系统（如实时，客户端&#x2F;服务器和分布式应用，如项目部署多个机器）\n额外考虑并发任务\n\n\n目的：子系统对于构件与链接关系的确定\n\n\n\n增量软件集成软件测试\n\n集成测试（测试好的构件进行组合，属于白盒测试，也在意整体构建方式）\n系统测试（黑盒测试，只管测试输入与输出是否对应）\n\n测试种类\n\n系统测试（功能测试）\n压力测试（如某一时刻的大量数据输入）\n性能测试（吞吐量等等）\n\nCOMET   USDPCOMET的每一个阶段都对应USDP的一个工作流\n需求，分析与设计建模\n\n用例建模\n陈述非功能性需求\n\n分析建模的活动\n\n重点在于问题理解，标识问题域的对象与对象间传递的信息\n\n设计建模的活动\n集成对象通信模型\n子系统结构与接口的决策\n类接口的决策\n消息特性的决策\n\n3.10需求&#x3D;功能需求+ 质量需求+约束\nIT系统\n硬件\n操作系统\n通信协议，\n软件层面\n\n可否理解为：\n\n上下文是开发一个软件&#x2F;系统&#x2F;项目所有需要考虑的方面\n刻面是上下文的组成部分，具体细分\n再由刻面进一步分析需要的技术&#x2F;信息，确认开发方式，技术，协议\n\n","tags":["学习笔记"]},{"title":"数据结构与算法 PART 1","url":"/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"数据结构与算法：PART1\n算法时间分析：https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF\n理解idx:我感觉idx相当于一个分配器，如果需要加入新的结点就用++idx分配出一个下标（最主要可以做到不重复地重新分配下标）\nAcWing 835. 如何理解单(双)链表，Trie树和堆中的idx？ - AcWing\n\n所有数据结构 学习的同时一定要理解该种数据结构的使用范围，干什么的&#x2F;\n科班学习顺序：（如何逐步提高写程序的性能）基础程序设计-&gt;数据结构与算法-&gt;操作系统-&gt;编译器的优化（编译原理）\n提高程序性能办法：好的算法：正确性，可读性，健壮性，效率\n程序运行时间因素\n所用算法\n问题的规模\n书写程序所用语言-&gt;级别越高效率越低\n编译程序所用的机器(mac比windows快)\n机器执行所用的速度（涉及到硬件，比如老电脑和新电脑）\n\n算法时间度量：为了完成某一问题机器所做的操作执行次数\n统计方法：写代码前&#x2F;写代码后\nint i, sum=0, n=100;//执行1次\nfor(i=1;i&lt;=n;i++)//执行n+1次\n&#123;\nsum+=i;//执行n次\n&#125;\ncout&lt;&lt;sum;//执行n次\n\n冯诺依曼架构I&#x2F;O&lt;-&gt;中央存储单元&lt;-&gt;\nCPU:解析指令\n内存：存储指令和数据\n程序大小相对不重要，执行操作与数据重要\n空间复杂度：通过计算算法所创建的空间大小。\n基础算法位运算求n的第k位数字: n &gt;&gt; k &amp; 1\n返回n的最后一位1：lowbit(n) = n &amp; -n\n\n快排——》重要，面试常用型😍快排本质就是使用分治思想，递归实现\n最快onlogn，最慢oN2\n步骤：\n\n确定分界点\n调整范围（最麻烦部分）\n对左右两边进行操作\n\n模板：void quick_sort(int q[], int l, int r)//记住开头不变，最后右边是j+1\n&#123;\n    if (l &gt;= r) return;//左右指针相遇时候返回\n\n    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];//这里x暂时设定为左右边界的中间值，原因在于后边是do while指令，因此提前ij各往外移动一个位置\n     //第一步：分成子问题\n    while (i &lt; j)\n    &#123;//注意这个顺序一定不能错\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        //容易错的点：要在这里打一个if\n        if (i &lt; j) swap(q[i], q[j]);//swap函数自己补充，这里ij可以相等\n    &#125;//这样操作过一轮之后x左边都是比它小的，右边都是比它大的\n    //第二步：递归处理子问题\n    \n    \n    \n    quick_sort(q, l, j), quick_sort(q, j + 1, r);//这里一定一定是j，i会出问题\n    \n    \n    \n    //这里两步的顺序一定一定记住，不然可能无限划分\n    //接着对它左右两端进行同样一次的操作，递归到最后就是全部完成排序\n    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤\n&#125;\n\n使用说明：\n如原本为a[10]，数据为a[0]-a[9];\n则排序为\n    quick_sort(a, 0, 9);//注意这里很容易错误弄范围\n\n快排合理性分析：AcWing 785. 快速排序算法的证明与边界分析 - AcWing由于使用do-while循环,所以i和j一定会!!!自增!!!,使得循环会继续下去,但是如果采用while循环(i和j的初始化做出对应的变更),i和j在特殊情况下不自增的话,循环就会卡死\n边界问题：\n快排属于分治算法，最怕的就是 n分成0和n，或 n分成n和0,这会造成无限划分\nwhile(q[i] &lt; x) i++;\n  while(q[j] &gt; x) j--;\n当q[i]和q[j]都为 x 时, i 和 j 都不会更新,导致 while 陷入死循环\n\n单向移动版本快排（实际使用快慢指针）int partition(int arr[], int low, int high)\n &#123;\n    int pivot = arr[low]; // 待比较的基准元素\n    int i = low;\n    for (int j = low + 1; j &lt;= high; j++) \n    &#123; if (arr[j] &lt; pivot) \n        &#123; i++; \t\t//最终i停留的位置是要交换的位置\n             swap(arr[i], arr[j]);\n        &#125;\n    &#125; \n    swap(arr[i], arr[low]); \n    return i;\n&#125;\nvoid quickSort(int arr[], int low, int high) &#123;\n    if (low &lt; high) &#123; \n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1); \n        quickSort(arr, pi + 1, high);\n        &#125;\n&#125;\n\n/*\n这种排序实际上将数组分成了三个部分：比pivot小，pivot，比pivot大，因此分治部分只需要对于pi-1和pi+1进行操作就行\n*/\n\n运行逻辑：指针j运行快，i运行慢，j只会在遇到比基准元素大的时候跳过\n正常流程：如果j指向的都是比pivot小的元素，ji同步运动，指针一直向右走\n\n如果j右边是比pivot大的元素，即i右边紧挨着就是更大的元素，j跳过，i停留不移动\n\n然后让i++，刚好就到了大的元素，进行交换\n结束情况：j遍历完成，i最后右移一次，停止\n\n接着就是分治了\n插入排序void insertionSort(int arr[], int n) &#123;\n\nint i, key, j; \n    for (i = 1; i &lt; n; i++) \n    &#123;\n        key = arr[i];\n        j = i - 1;\n// 如果大于key需要向后移动一位\n        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key)\n        &#123;//直接插入是一直插入到对比结束\n            arr[j + 1] = arr[j]; j = j - 1;\n        &#125; \n        arr[j + 1] = key;\n&#125;\n&#125;\n\nplus:折半插入排序（插入+二分）——》稳定又好使代码：int binarySearch(int a[], int item, int low, int high) \n&#123; \n    if (high &lt;= low) &#123; return (item &gt; a[low]) ? (low + 1) : low;&#125; \n     int mid = (low + high) / 2; \n    if (item == a[mid]) &#123; return mid + 1;&#125;\n    if (item &gt; a[mid]) &#123; return binarySearch(a, item, mid + 1, high);&#125;\n    return binarySearch(a, item, low, mid - 1);\n\n&#125;//二分搜索部分\n//注意二分一定有解，但是答案不一定有解\nvoid insertionSort(int a[], int n) \n&#123;\n    int i, loc, j, k, selected; \n    for (i = 1; i &lt; n; ++i) \n    &#123;\n         j = i - 1;\n        selected = a[i];\n        // 寻找应该插入的位置\n        loc = binarySearch(a, selected, 0, j);\n        //这里直接找到，后面的while循环就不需要再考虑对比，直接上就行\n        // 移动后面所有的数据\n        while (j &gt;= loc) \n        &#123; \n            a[j + 1] = a[j];\n             j--;\n        &#125;\n        a[j + 1] = selected;\n    &#125;\n\n&#125;\n\n希尔排序模板int shellSort(int arr[], int n) &#123;\n// 从大gap开始，逐步减少gap\nfor (int gap = n / 2; gap &gt; 0; gap /= 2) \n    &#123; \n        for (int i = gap; i &lt; n; i += 1) \n        &#123;\n// i 是直接插入排序算法中待插入的元素int temp = arr[i];\n// 向前查找，并同时移位\n            int j;\n            for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) \n            &#123; \n                arr[j] = arr[j - gap];\n            &#125;\n// 把i元素放入合适的位置\n            arr[j] = temp;\n        &#125;\n    &#125; \n    return 0;\n&#125;\n\n归并排序（另一个重要排序，也背下来）😃不太好的点：归并排容易爆内存\n模板：void merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;= r) return;//最后拆分成单元素的时候就返回\n    int mid = l + r &gt;&gt; 1;//二分\n    \n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n//以上先疯狂二分，将整个数组全部拆分成最小部分，然后下面部分开始递归合并\n    int k = 0, i = l, j = mid + 1;\n       分别作用：\n        k用于tmp数组，因此从0开始\n        i从最左，j从中间开始向右\n    \n    \n    while (i &lt;= mid &amp;&amp; j &lt;= r)//这里由于递归，每一个小数组都归并好了，归并最后的大数组\n        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//归并，结果合并到tmp，\n        else tmp[k ++ ] = q[j ++ ];\n\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//赋值剩下的i\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//赋值剩下的j\n\n    for (i = l, k = 0; i &lt;= r; i ++, k ++ ) q[i] = tmp[k];\n    k代表临时数组的值\n      \n    \n    //赋值回去，使得q同步变得有序，用于小数组递归回去用\n    //憋想着省去这一步，不然小数组无法被弄成有序，最后归并会失败\n&#125;\n\n使用举例：\n几个注意点：\n\ntmp一开始就声明（不然爆内存）\nmerge里面j&#x3D;mid+1（这里弄错之后排序都不对劲）\nmerge函数中i与j的范围记得别被错\n\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N=1e5+10;\nint array[N];\nint tmp[N];\nvoid merge(int l,int r)\n&#123;\n    int mid=(l+r)/2;\n    int k=0,i=l,j=mid+1;//j的赋值容易不对劲\n    while(i&lt;=mid&amp;&amp;j&lt;=r)\n    &#123;\n        if(array[i]&lt;=array[j])tmp[k++]=array[i++];//这里判断的时候还是加‘=’\n        else tmp[k++]=array[j++];\n    &#125;\n    while(i&lt;=mid)&#123;tmp[k++]=array[i++];&#125;\n    while(j&lt;=r)&#123;tmp[k++]=array[j++];&#125;\n    for(i=l,j=0;i&lt;=r;i++,j++)//这里的范围也容易搞混\n    &#123;//注意归并排序中所有都是&lt;=\n        array[i]=tmp[j];\n    &#125;\n&#125;\nvoid mergesort(int l,int r)\n&#123;\n    if(l&gt;=r)return;\n    int i=l-1;\n    int j=r+1;\n    int mid=(i+j)/2;//这里有一个特别狠的二分\n    \n    mergesort(l,mid);\n    mergesort(mid+1,r);//这里需要+1\n    merge(l,r);\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        cin&gt;&gt;array[i];\n    &#125;\n    mergesort(0,n-1);\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        cout&lt;&lt;array[i]&lt;&lt;&#39; &#39;;\n    &#125;\n    return 0;\n&#125;\n\n有趣应用：逆序对788. 逆序对的数量 - AcWing题库\ntimsort（优化后归并）这个就看苏老师的ppt课件\n(105条消息) Timsort——自适应、稳定、高效排序算法_码到sucess的博客-CSDN博客_timsort\n核心：提取降序数组升级为升序数组本质都是部分有序的,\n\n因此第一步：将所有部分降序数组全部翻转（这里直接逆序就好）\n这一步模板：\nvoid reverse(int q[],int l,int r)\n&#123;\n    for(int i=l,j=r;i&lt;=j;i++,j--)swap(q[i],q[j]);\n&#125;\nvoid array_reverse(int q[],int N)\n&#123;\n    if(N==1&amp;&amp;N==0)return;\n    int i=1,l=0,tmp=0,stage_judge;\n    if(q[0]&lt;=q[1])stage_judge=1;//升序标记\n    else  stage_judge=0;\n    while(i&lt;N)\n    &#123;\n        if(q[i]&gt;q[i+1])\n        &#123;\n            if(stage_judge==1)stage_judge=0;\n            ++i;\n        &#125;\n        else if(q[i]&lt;=q[i+1])\n        &#123;\n            if(stage_judge==0)\n            &#123;\n                if(tmp!=l-1)++l;\n                reverse(q,l,i);\n                tmp=i;\n                stage_judge=1;\n            &#125;\n            ++i;//前进一个\n            l=i;//l=前进一位之后的i\n        &#125;\n    &#125;\n&#125;\n\n核心：栈处理归并先将所有已知的升序排列的压入总栈，\n这一步：\nvoid stack_check(int N)//对栈进行检验,并且要的是归并两个连续短区间\n&#123;\n    int stack_pos1,stack_pos2,stack_pos3;\n    int stack_length1,stack_length2,stack_length3;//1最顶，3最底层\n    pop(stack_pos1,stack_length1);\n    pop(stack_pos2,stack_length2);\n    pop(stack_pos3,stack_length3);\n    if(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)//x&gt;y或者x+y&gt;z\n    &#123;\n        if(stack_length1&gt;stack_length3)\n        &#123;\n                push(stack_pos1,stack_length1);\n                merge(stack_pos3, stack_length3,stack_pos2, stack_length2 );//对yz进行归并\n\n        &#125;\n            else\n        &#123;\n                    push(stack_pos3,stack_length3);\n                    merge(stack_pos2,stack_length2,stack_pos1,stack_length1);//对xy进行归并\n        &#125;\n           // cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;\n        for(int i=0;i&lt;N;i++)\n        &#123;\n            cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;\n        &#125;\n        cout&lt;&lt;endl;\n        if(stack_idx&gt;=2)stack_check(N);//递归检测\n    &#125;\n    else//按照原先顺序再压进去\n    &#123;\n        push(stack_pos3,stack_length3);\n        push(stack_pos2,stack_length2);\n        push(stack_pos1,stack_length1);\n        cout&lt;&lt;endl&lt;&lt;endl;\n    &#125;\n    return;\n&#125;\n\n核心：最小分区长度在排序之前预先计算➢ 归并过程低效的主要原因是大分区和小分区合并\nwhile(stack_idx&gt;=1)//输出阶段,这里就是检测是否正确归并入栈，没有归并\n   &#123;\n        pop(stack_pos1,stack_length1);\n        pop(stack_pos2,stack_length2);\n       if(stack_pos1&gt;stack_pos2)merge(stack_pos2,stack_length2,stack_pos1,stack_length1);\n       else merge(stack_pos1,stack_length1,stack_pos2,stack_length2);\n       for(int i=0;i&lt;N;i++)\n       &#123;\n           cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;\n       &#125;\n\ntimsort模板（自己写的！）#include&lt;iostream&gt;\nusing namespace  std;\nconst int M =10010;\nint q[M];\nint tmp[M];\nint pos_stack[M];//存储下标\nint length_stack[M];//存储长度\nint stack_idx=-1;\nvoid push(int pos,int length )\n&#123;\n    pos_stack[++stack_idx]=pos;\n    length_stack[stack_idx]=length;\n&#125;\nvoid pop(int &amp;tmp_pos,int &amp;tmp_length)//给两个数赋值然后弄出去\n&#123;\n    tmp_pos= pos_stack[stack_idx];\n    tmp_length= length_stack[stack_idx];\n    --stack_idx;\n    return;\n&#125;\nvoid reverse(int q[],int l,int r)\n&#123;\n    for(int i=l,j=r;i&lt;=j;i++,j--)swap(q[i],q[j]);\n&#125;\nvoid array_reverse(int q[],int N)\n&#123;\n    if(N==1&amp;&amp;N==0)return;\n    int i=1,l=0,tmp=0,tem_l=0,stage_judge;\n    if(q[0]&lt;=q[1])stage_judge=1;//升序标记\n    else  stage_judge=0;\n    while(i&lt;N)\n    &#123;\n        if(q[i]&gt;q[i+1])\n        &#123;\n            if(stage_judge==1)\n            &#123;\n                stage_judge=0;//之前是升序这里突然降序了\n            &#125;\n            ++i;\n        &#125;\n        else if(q[i]&lt;=q[i+1])\n        &#123;\n            if(stage_judge==0)\n            &#123;\n                if(tmp!=l-1)++l;\n                reverse(q,l,i);\n                tmp=i;\n                stage_judge=1;\n            &#125;\n            ++i;//前进一个\n            l=i;//l=前进一位之后的i\n        &#125;\n    &#125;\n&#125;\nvoid merge(int pos1,int length1,int pos2,int length2)\n&#123;\n    int r=pos2+length2-1;//最右端\n    int l=pos1;//最左端\n    //归并部分\n    int mid=pos1+length1-1;\n    int k = 0, i = l, j = pos2 ;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)//这里由于递归，每一个小数组都归并好了，归并最后的大数组\n        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//归并，结果合并到tmp，\n        else tmp[k ++ ] = q[j ++ ];\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//赋值剩下的i\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//赋值剩下的j\n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n    push(pos1,length1+length2);//合并完之后进行压栈\n&#125;\nvoid stack_check(int N)//对栈进行检验,并且要的是归并两个连续短区间\n&#123;\n    int stack_pos1,stack_pos2,stack_pos3;\n    int stack_length1,stack_length2,stack_length3;//1最顶，3最底层\n    pop(stack_pos1,stack_length1);\n    pop(stack_pos2,stack_length2);\n    pop(stack_pos3,stack_length3);\n    if(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)//x&gt;y或者x+y&gt;z\n    &#123;\n        if(stack_length1&gt;stack_length3)\n        &#123;\n                push(stack_pos1,stack_length1);\n                merge(stack_pos3, stack_length3,stack_pos2, stack_length2 );//对yz进行归并\n\n        &#125;\n            else\n        &#123;\n                    push(stack_pos3,stack_length3);\n                    merge(stack_pos2,stack_length2,stack_pos1,stack_length1);//对xy进行归并\n        &#125;\n           // cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;\n        for(int i=0;i&lt;N;i++)\n        &#123;\n            cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;\n        &#125;\n        cout&lt;&lt;endl;\n        if(stack_idx&gt;=2)stack_check(N);//递归检测\n    &#125;\n    else//按照原先顺序再压进去\n    &#123;\n        push(stack_pos3,stack_length3);\n        push(stack_pos2,stack_length2);\n        push(stack_pos1,stack_length1);\n        cout&lt;&lt;endl&lt;&lt;endl;\n    &#125;\n    return;\n&#125;\n//归并搞定\nint main() &#123;\n    int N;\n    cin &gt;&gt; N;\n    int stack_pos1,stack_pos2,stack_pos3;\n    int stack_length1,stack_length2,stack_length3;\n    for (int i = 0; i &lt; N; i++) &#123;\n        cin &gt;&gt; q[i];\n    &#125;\n    array_reverse(q, N - 1);//没问题了,别动！\n    int l=0;\n    for(int i = 0; i &lt; N; i++) &#123;\n        if(q[i]&gt;q[i+1])\n        &#123;\n            push(l,i-l+1);\n\n            l=i+1;\n        &#125;\n    &#125;//这里完成将栈压入\n    //接下来就是找最大的，然后合并\n    cout&lt;&lt;endl&lt;&lt;endl;\n    for(int i=0;i&lt;N;i++)\n    &#123;\n        cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n    if(stack_idx&gt;=2)stack_check(N);\n    while(stack_idx&gt;=1)//输出阶段,这里就是检测是否正确归并入栈，没有归并\n   &#123;\n        pop(stack_pos1,stack_length1);\n        pop(stack_pos2,stack_length2);\n       if(stack_pos1&gt;stack_pos2)merge(stack_pos2,stack_length2,stack_pos1,stack_length1);\n       else merge(stack_pos1,stack_length1,stack_pos2,stack_length2);\n       for(int i=0;i&lt;N;i++)\n       &#123;\n           cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;\n       &#125;\n   &#125;\n    return 0;\n&#125;//23         2 4 7 8 23 19 16 14 13 12 10 20 18 17 15 11 0 5 6 1 3 21 22\n\n二分二分本质并不是单调性：有单调性一定可以二分解，可以二分解的题目不一定满足单调性，本质：可以将原本区间分成两个部分\n二分一定有解（自己的二分的性质是一定有边界的），但题目可能会无解（看例题）\n整数二分比实数二分蛋疼很多：整数有边界问题很恶心\n当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了\n整数模板（两种）应用：\n1：找大于等于数的第一个位置 （满足某个条件的第一个数）2：找小于等于数的最后一个数 （满足某个条件的最后一个数）3.查找最大值 （满足该边界的右边界）、4.查找最小值 (满足该边界的左边界)\n然后每次使用这这两个模板的时候，先想是找这个区间的左端点还是还是右端点，然后选择用模板，最后再去写判断条件。\n设置红绿交界点是要求的位置\n\n\n最后收敛到整个数组中满足条件的最右边的点\n最后收敛到数组中满足条件的最左边的点\n\n\n记忆方式：有减必有加\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\n//核心在于判断l=mid还是r=mid\n\n//收敛到最右边的点\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：情况1\nint SR(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r + 1 &gt;&gt; 1;//需要补上l+r+1，防止死循环\n        if (check(mid)) l = mid;\n        else r = mid - 1;//有减，前面必定有加\n    &#125;\n    return l;\n&#125;\n\n\n//收敛到最左边的点\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：情况2\nint SL(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;//这里是（l+2）/2\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质：\n        else l = mid + 1;\n    &#125;\n    //\n    return l;//这里最终l和r相等，不需要考虑别的\n&#125;\n\n整数经典例题：789. 数的范围 - AcWing题库经典：二分模板最终一定有解，题目不一定有解（最后的判断不满足题目）\n解答：\n\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N = 1e5 + 10;\nint q[N];\n\nint SL(int l, int r, int x) &#123;//最终结果是最左边满足条件的\n  while (l &lt; r) &#123;\n    int mid = l + r &gt;&gt; 1;\n    if (q[mid] &gt;= x) r = mid;\n    else l = mid + 1 ;\n  &#125;\n  return l;\n&#125;\n\nint SR (int l, int r, int x) &#123;\n  while (l &lt; r) &#123;\n    int mid = l + r + 1 &gt;&gt; 1;//有+\n    if(q[mid] &lt;= x) l = mid;\n    else r = mid - 1;//有-\n  &#125;\n  return r;\n&#125;\n\nint main() &#123; int n,m;\n    scanf (&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=0;i&lt;n;++i) scanf (&quot;%d&quot;,&amp;q[i]);\n    while ( m-- ) &#123;\n        int x;\n        scanf (&quot;%d&quot;,&amp;x);\n        int l = SL(0, n - 1, x);//查找左边界 并返回下标l\n        //这里最后的L就是最左边第一个满足&gt;x的数字，也就是满足二分得到的结果（最接近x且&gt;=x）\n        //因此下一步可以直接判断是否直接=x\n        if (q[l]!=x) cout &lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;//如果找不到  返回-1 -1\n        else &#123;\n            cout &lt;&lt; l &lt;&lt; &#39; &#39;; //如果找到了  输出左下标\n            cout &lt;&lt; SR(0, n - 1, x) &lt;&lt; endl; //输出右下标\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n同样的例题：（爷跟你拼了）\n519. 跳石头 - AcWing题库照样使用二分（虽然是比较复杂的二分）：二分,贪心O(NlogL)\n思路：使得选手们在比赛过程中的最短跳跃距离尽可能长，当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了。验证答案具有单调性：拿走的石头越多，最短跳跃距离越大，这就叫答案的单调性\n核心原理：\n\n二分答案二分答案就是把一组数据每次分成两部分，就是把大问题转化成小问题。例如猜数游戏，猜1-100的一个数，就先猜50，若小了，就猜75，若大了，就猜25，就这样一直猜下去，最终找到答案。而我们每一次猜的这个答案就是所求范围内的数据的中间数据，这就是二分答案。这个二分的中间数据就是指要求的内容。\n如果长度 LenLen 可以满足，那么当长度小于 LenLen 时也可以满足，所以我们可以二分出最大的 LenLen。也就是在所有可满足的Len中寻找最右端的答案（这里指从0到最大），因此使用模板SR（再看上一道题实际上一个原理）\n剩下的问题是如何判断给定 LenLen 的情况下，能否最多拿走 M块石头，使得所有相邻两块石头之间的距离不小于 LenLen。这一步可以贪心来做。从前往后扫描，并记一下上一块石头的位置。\n如果当前石头和上一块石头的距离小于 LenLen，则将当前石头拿走\n如果当前石头和上一块石头的距离大于等于 LenLen，则将上一块石头更新成当前这块。（和上一条是贪心时候的两种解法）\n这里给出贪心证明：如果某个最优解中是拿走了上一块石头，那么我们可以改成留下上一块石头，拿走当前这块石头，这样总共拿走的石头数量不变，所以当前选法也是一组最优解。\ncheck函数：我们遍历一遍每一块石头，累计出有多少块石头之间的间隔&lt;&#x3D;mid,如果超过m个，就不合法，如果小于等于m，就合法。(累计间隔小也就是需要搬走多少个石头)\n扫描结束后判断拿走的石头数量是否小于等于 M。（判断这个答案能不能执行，能说明答案mid还能猜测更大，更新l，不能说明mid猜测过大了，更新r）\n\n时间复杂度分析总共二分 O(logL)O(logL) 次，每次贪心的计算是 O(N)O(N)，因此总时间复杂度是 O(NlogL)O(NlogL)。\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N = 50005;\nint a[N];\nint n,m,s;\n\nbool check(int x) //check函数判断这个最短跳跃距离x是否合法\n&#123;\n    int cnt=0,last=0; //last表示的是上一块石头的位置,cnt用来计数\n    for(int i=1;i&lt;=n;i++)   //枚举每一块石头 \n    &#123;\n        //不移动走石头，就实时更新上一块石头位置，如果移动，就不更新\n        if(a[i]-last&lt;x) cnt++;//如果这一块石头和上一块石头的距离比x小,计数+1。而且如果石头移走，last还是上一块石头的位置。\n        else last=a[i]; //否则这块石头就不必移走，last=这块石头的位置。\n    &#125;\n    if(cnt&gt;m) return false; //cnt如果超过m个，就不合法。\n    else return true;\n&#125;\n\nint main()\n&#123;\n    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];\n    a[n+1]=s;//将终点的距离也算进去\n\n    n=n+1;//注意这里的n需要加一，check函数需要用\n\n    int l=1,r=s; //注意l和r都是最短跳跃距离的边界，而不是石头的边界。 \n    while(l&lt;r)\n    &#123;\n        int mid=l+r+1&gt;&gt;1;\n        if(check(mid)) l=mid;//答案猜小了\n        else r=mid-1;//答案猜大了\n    &#125;\n    cout&lt;&lt;l&lt;&lt;endl;\n&#125;\n\nhttps://www.acwing.com/blog/content/21312/\nhttps://www.acwing.com/solution/content/118815/\nhttps://leetcode.cn/leetbook/read/illustration-of-algorithm/59bjss/\nhttps://www.acwing.com/solution/content/120802/\n浮点模板浮点好处在于不用考虑整数二分中的边界问题，因此直接用\nbool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    &#123;\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;//这里就不用多考虑\n    &#125;\n    return l;\n&#125;\n\n例题：790. 数的三次方根 - AcWing题库\n#include &lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\ndouble x;\nint main () &#123;\n    cin &gt;&gt; x;\n    double l = -1000,r = 1000;//这里一开始范围设定大，直接从0开始\n    while (r - l &gt;= 1e-7) &#123;\n        double mid = (l + r) / 2;\n        if (mid * mid * mid &lt;= x) l = mid;  //如果是小于等于的话，就可以说明答案会更大\n        //比较重要的一步，c++里面几次方就直接弄，别用mid^3,配合c++primer食用\n        else r = mid;\n    &#125;\n    printf (&quot;%.6lf&quot;,l);\n    return 0;\n&#125;\n\n二分改进：插值查找应用范围：表长较大，关键字分布均匀\n关键不同：二分mid固定为0.5，插值查找mid参数动态变化\nmid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;\n\n斐波那契查找(104条消息) 七大查找之斐波那契查找_非常规自我实现的博客-CSDN博客_fibonacci查找\n前缀和（应用广泛）数据结构应用：字符串哈希表kmp，自动机kmp，\n前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩压缩部分：解压缩部分：离散化：整数离散化如果使用哈希，会有额外的空间开销\n特点：值域范围大，但是个数少（比如要访问到数组的10^9的位置，但个数只有10^5）也就是对于一个函数a-&gt;b，实际上只需要映射a，不需要操作b（当然高级玩家也可以继续弄b）。一般有两个问题：\n\na数组里面可能有重复元素，因此需要去重，（去重是最重要的）\n如何算出a[i]离散化后的值，保序离散化（a数组本身下标有序的），映射后一定也要是有序的，a[i].由于a有序，可以使用二分\n\n需要使用的知识点：\n\nvector\npair\n\n离散化模板：(c++版本)//alls存储的是最开始的下标\nvector&lt;int&gt; alls; // 存储所有待离散化的值\nsort(alls.begin(), alls.end()); // 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素\n\n// 二分求出x对应的离散化的值\nint find(int x) // 找到第一个大于等于x的位置\n&#123;\n    int l = 0, r = alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;\n        if (alls[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return r + 1; // 映射到1, 2, ...n\n    //前缀和从1开始相对方便\n&#125;\n\nAcWing 802. 区间和 - AcWing\n分析：\n使用离散化原因：\n\n存储下标过大，不能开这么大的下标\n使用数轴，会存在负值，不能使用下标\n哈希表不能像离散化缩小数组的空间，可能导致遍历-e9~1e9。此处的含义就是假如我们需要计算1e-9和1e9区间内的值，那我们需要从前到后枚举，无论该值是否存在。因为哈希表不能排序，因此不能提前知道哪些数周上的点不存在，会枚举多次（如最后query的时候，从1到1e9，使用哈希表就要遍历才知道是否有点，时间开销太大），\n\n离散化本质：映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量，也就是如何能够将不连续的点映射到连续的数组的下标。\n本题解法：(离散化) O((n+2∗m)log(n+2∗m))\n\n开辟额外数组存放原来 的下标标志\n对原来的数轴下标进行排序再去重，原因：考虑前缀和思想，我们需要求出的区间内的和的两端断点不一定有元素，提前加如需要求前缀和的两个端点，有利于我们进行二分搜索，其实二分搜索里面我们一般假定有解的，如果没解的话需要特判，所以提前加入了这些元素，从而导致可能出现重复元素\n最多使用n+2m次操作，最多使用的下标跨度为3*10^5,\n\n首先用而二分写好映射后对应的数组下标，复杂度log(n + 2 * m)\nint find(int x)\n&#123;\n    int l = 0, r = alls.size() - 1;\n    while(l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;\n        if(alls[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return r + 1;\n&#125;\n\n全解：\n关于unique和erease可以看\n[(100条消息) C++ 之vector元素去重unique()_sandalphon4869的博客-CSDN博客_unique vector](https://blog.csdn.net/sandalphon4869/article/details/98209093?ops_request_misc=%7B%22request%5Fid%22%3A%22166674706816800184111752%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166674706816800184111752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-98209093-null-null.142^v59^pc_rank_34_1,201^v3^control_1,213^v1^t3_control1&amp;utm_term=vector unique&amp;spm&#x3D;1018.2226.3001.4187)\nauto:(100条消息) c++ auto基本用法_lwgkzl的博客-CSDN博客_auto用法\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;//pair可以同时存储两个数据，可以理解成半封装的结构体\nconst int N = 300010;//最多涉及的下标长度\nint a[N], s[N];\nint n, m;\n\nvector&lt;int&gt; alls;//存储下标值\nvector&lt;PII&gt; add, query;//分别存储询问和加\n\nint find(int x)\n&#123;\n    int l = 0, r = alls.size() - 1;\n    while(l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;\n        if(alls[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return r + 1;//为了最终的映射从1开始\n&#125;\nvector&lt;int&gt;:: iterator unique(vector&lt;int&gt; &amp;a)\n&#123;//这里是手动实现unique，非c++语言需要手动\n    //作用为自动去重\n    int j = 0;\n    for(int i = 0; i &lt; a.size(); i ++)\n        if(!i || a[i] != a[i - 1])\n            a[j ++ ] = a[i];\n    return a.begin() + j;\n&#125;\n\nint main()\n&#123;\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for(int i = 0; i &lt; n; i ++ )\n    &#123;\n        int x, c;//x是下标\n        cin &gt;&gt; x &gt;&gt; c;\n        add.push_back(&#123;x, c&#125;);\n        alls.push_back(x);\n    &#125;\n\n    for(int i = 0; i &lt; m; i ++ )\n    &#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        query.push_back(&#123;l, r&#125;);\n        alls.push_back(l);\n        alls.push_back(r);\n        //全部存储后alls组成为x,x,x,x,x,l1,r1,l2,r2等等\n    &#125;\n\n//直接unique(a)不加其它参数就是默认直接从头到尾，\n    sort(alls.begin(), alls.end());//对原来的数组下标进行从小到大\n    vector&lt;int&gt;::iterator pos = unique(alls);\n     //pos是去重以后vector中没有重复元素的下一个位置的迭代器\n    //从容器的开始到返回的迭代器位置的元素是不重复的元素，而从返回的迭代器位置到vector.end()的元素都是没有意义的（这东西就是原来排序后的东西，没变过）。\n    //比如1 2 3 3 4 4 5 5unique后为1 2 3 4 5   5 5 5（别管这三个什么，没意义）\n\n    alls.erase(pos, alls.end());//删除重复元素\n\n    for(auto item : add)//add是一个vector&lt;PII&gt; add，为方便初始化这么用\n    &#123;\n        int x = find(item.first);//第一个值是要加的数的下标\n        a[x] += item.second;//对应的数组位置加该数\n    &#125;\n\n    for(int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];\n    //这里用前缀和方法求所有的前缀\n\n    for(auto item : query)\n    &#123;\n        int l = find(item.first), \n        r = find(item.second);//两个都是\n        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;\n        //这里最后就是对应过来的减去后的值，\n    &#125;\n\n    return 0;\n&#125;\n//这些数据是验算用的\n3 3//m。n\n1 2\n3 6\n7 5\n1 3\n4 6\n7 8\n\n补充auto：\nint main()&#123;\n    vector&lt;int&gt;v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    for(auto i : v)&#123;//这一步就是迭代器从begin走到end\n        cout&lt;&lt;i&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n    return 0;\n&#125;\n\n区间合并：不同于离散化应用：很多区间，如果有交集就合并成一个更长的区间\n区间合并算法：快速地进行多个区间的合并,当然可以进行一些特殊处理，比如对于端点就进行统一归并\n步骤：\n按区间左端点进行排序\n扫描过程中，对于所有有交集的区间进行合并。\n\n左边端点设置成start，右边设置成end，可能有的关系：\n\n\n\n左右都在内部：原本区间不变\n仅一部分在内部：新的ed会边长（左端点不会更新，因为是按照左端点从小到大的顺序进行区间的扫描的）\n都不在内部：不用管就完事了\n\n代码模板#include&lt;algorithm&gt;\n\n\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());//这里是因为pair是默认按照左端点排序的\n\n    int st = -2e9, ed = -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)//情况3：两个区间无法合并\n        &#123;\n            if (st != -2e9) res.push_back(&#123;st, ed&#125;);//区间1放进去res数组\n            st = seg.first, ed = seg.second;//维护区间2\n        &#125;\n        else ed = max(ed, seg.second);//情况12，可以合并，进行更新\n\n     //考虑循环结束时的st,ed变量，此时的st,ed变量不需要继续维护，只需要放进res数组即可。\n    //因为这是最后的一个序列，所以不可能继续进行合并。\n    if (st != -2e9) res.push_back(&#123;st, ed&#125;);//说的就是你，最后一个序列，if就是防一下空序列\n\n    segs = res;//这样回复的就是答案segs\n&#125;\n\n//最大原因：排过序了，不用担心复用\n//排过序之后，不可能有区间2包含区间1，只能是1包含后面的\n//本质，遍历，每一次如果两个区间没有相交的部分（无法合并），那么就将一个区间推入作为答案，同时更新左右端点\n\ny总：\n#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int,int&gt; PII;\nvector&lt;PII&gt; segs;\n\nvoid merge(vector&lt;PII&gt;&amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n    sort(segs.begin(),segs.end());//先对于全部区间进行排序\n    int l = -2e9,r = -2e9;//小就完事了\n    for(auto item:segs)//定义了一个迭代器，这里是一个遍历的过程\n    &#123;//! 第一段区间一定是  ed&lt; item.first\n        if(r &lt; item.first)//当前区间右端点严格小于枚举区间的左边\n        &#123;//情况1：两个区间无法合并\n            if(l != -2e9) res.push_back(&#123;l,r&#125;);//! 第一次在这里初始化\n            //区间1放进去res数组\n            l = item.first;//! 第一段区间从这里开始即seg[0].first\n            //维护区间2\n            r = item.second;//第一段区间的。seg[0].second\n        &#125;//todo 这个循环结束之后还会剩下一个区间\n        else r = max(r,item.second);//第二种情况，说明有交集，右端点更新成维护的区间的右端点以及最大值\n    &#125;//! 如果不是空的  那我们就加上一段\n    if(l != -2e9) res.push_back(&#123;l,r&#125;);//最后一个区间判断一下，防止空区间\n    segs = res;//区间更新变成res\n&#125;\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n\n    while(n--)\n    &#123;\n        int l,r;\n        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n        segs.push_back(&#123;l,r&#125;);\n    &#125;\n    merge(segs);\n    cout &lt;&lt; segs.size() &lt;&lt; endl;\n    return 0;\n&#125;\n\n数据结构链表 有限性：数据元素个数有穷\n相同性：数据元素的类型是同一的\n顺序性：相邻的数据元素之间存在序偶关系\n前言：\n链表当中利用结构体制造链表的速度都是非常慢的，会消耗很多的时间，而正常面试中需要使用到链表时候大小都是有限制的，一般是十万或者百万的级别，而单单是new这些节点就会导致超时，在笔试题中最好不要用结构体指针，可以优化比如提前构建好多个节点，但已经类似于数组模拟链表了.算法题中绝对绝对不要考虑内存泄漏的问题\n\n使用结构体去构建链表的另一个问题在于键入指令会很麻烦\n//数组版本\nint next[N],prev[N],valu[N]\nvoid delete(int k)\n&#123;\n    next[prev[k]]=next[k];//向右跳过中间\n    prev[next[k]]=prev[k];//向左跳过中间\n&#125;\n//结构体版本\nstruct Node\n&#123;\n    int valu,next,prev;\n&#125;nodes[N];\nvoid delete(int k)\n&#123;\n    nodes[nodes[k].prev].next=nodes[k].next;\n    nodes[nodes[k].next].prev=nodes[k].prev;\n&#125;\n//两种类型相比第二种整体结构易于理解但是在使用过程中语句特别长而且不太容易理解\n\n\n\nps:算法题中大部分操作都是头插法\n链表制造方式\n结构体+指针（c++需要使用new，费时间）\n数组模拟（这里是静态数组，用空间换时间）\n\n小tips：邻接表本质就是n个单链表拼起来，正常一个head对应一条链表，这个就是开了一个组，head[i]对应第i条链表\n数组模拟链表\n\n单链表：邻接表（实际上n个链表），主要应用在于存储图和树\n双链表：优化某些问题\n\n单链表制作826. 单链表 - AcWing题库\n//通用版本的静态链表  \n//e[n]:某个点的值，ne[n]:某个点的指针，使用下标关联起来\nconst int n =1000010;\n\n//e[i]节点i\n//ne[i]节点i的next指针指向的值\n//idx存储已经用过哪一个点\nint head,e[n],ne[n],idx;\n/*\n这个的灵魂在于idx,有了idx可以保证无论新插的节点是头插还是尾插都没区别，都会用来计数，然后在对第k个进行操作的时候直接就定位到了idx\n*/\nvoid initial()\n&#123;\n    head=-1;//让head指向一个空的位置\n    idx=0//idx数量实际上就是链表当中总共节点的数量\n&#125;\nvoid add_to_tail(int x)//尾插\n&#123;\n    e[idx]=x;\n    if(head==-1//当是第一次插入时特殊处理\n    &#123;\n        ne[idx]=head;\n        head=idx;\n        idx++;\n        return;\n    &#125;\n    int i=head;\n    if(head!=-1)while(ne[i]!=-1)i=ne[i];//最后ne[i]=-1\n    ne[idx]=-1;\n    ne[i]=idx;\n    idx++;\n&#125;\nvoid add_to_head(int x)//头插\n&#123;\n    e[idx]=x;//保存x的值到一个新的位置\n    ne[idx]=head;//更新指向，新元素指向原先head的位置，也就是-1（第一次跑）\n    head=idx;//head头节点更新位置，更新到新元素的下标\n    idx++;//下一个新的元素\n&#125;\nvoid add(int k,int x)//注意和头插的区别在于位置变换的是ne[k]\n&#123;\n    k=k-1；//千万注意注意这里要改一下\n        //否则会出范围的\n        \n        \n    e[idx]=x;//先保存\n    ne[idx]=ne[k];//指向原先k的位置\n    ne[k]=idx;\n    idx++;//说明加\n&#125;\nvoid delete(int k)//tm惊为天人的简洁版本\n&#123;//这里是删除第k个添加的，并不是按照值来删除\n    k=k-1；//千万注意注意这里要改一下\n        //同样会出范围\n        \n        \n    ne[k]=ne[ne[k]];//我tm直接更新ne[k]指向的位置，中间数直接损失指引\n&#125;\nvoid dele(int a)//这个是删除某一个特定值\n       &#123;//一个问题是如果只有一个元素需要特判\n           if(e[head]==a)head=ne[head];//直接清空就行\n           else for(int i=head;ne[i]!=-1;i=ne[i])//多个元素时候的删除操作\n           &#123;\n               if(e[ne[i]]==a)//这里关系是跳过中间\n               &#123;\n                   ne[i]=ne[ne[i]];\n               &#125;\n          &#125;\n       &#125;\nvoid print()\n&#123;\n    for(int i=head;i!=-1;i=ne[i])//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）\n    &#123;\n        cout&lt;&lt;e[i]&lt;&lt;&#39; &#39;;\n        cout&lt;&lt;endl;\n    &#125;\n&#125;\n\n双链表制作#include&lt;iostream&lt;\nusing namespace std;\nconst int M=20010;\nint r[M],prev[M],e[M],index;\nvoid initial()\n&#123;\n   //双链表相对单链表的初始化不同\n   r[0]=1;//最左端指向最右端\n   l[1]=0;//最右端指向最左端\n   index=2;//另一个好处就是非常直白，双数肯定是向右的，单数向左的\n&#125;\nvoid add_to_right(int x,int k)//第k个的右边插入\n&#123;\n    e[idx]=x;\n    r[idx]=r[k];\n    l[idx]=k;\n    //新节点的延申部位都搞定了，开始双向连接\n    l[r[k]]=idx;\n    r[k]=idx//\n    idx++;\n&#125;\n//向右插就是\n  add_to_right( x, k+1)//k+1因为index从2开始计数\n//聪明的方法，在左边插入直接调用add_to_right(x,l[k]),也就是在k的左边节点调用向右插，结果就是第k个节点左边插入\nadd_to_right( x, l[k+1])//同理\n//如果是最左端或者最右端更简单\n//最左端\n add_to_right( x, 0)\n //右端\nadd_to_right( x, l[1])      \nvoid dele(int k)\n&#123;\n    r[l[k]]=r[k];\n    l[r[k]]=l[k];\n&#125;\nvoid print()\n&#123;\n    for(int i=r[0];i!=1;i=r[i])//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）\n    &#123;\n        cout&lt;&lt;e[i]&lt;&lt;&#39; &#39;;\n        cout&lt;&lt;endl;\n    &#125;\n&#125;\n\n\n//使用的时候的api：\n    add_to_right( x, k+1)\n    add_to_left(x,k+1)\n    dele(k+1)\n     第k个插入的数左边插入：add_to_right(x,l[k+1])\n     第k个插入的数右边插入：add_to_right(x,k+1)\n\n//双向链表制作\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nstruct Node&#123;\n    char data;\n    struct Node* next;\n    struct Node* pre; \n&#125;;\nstruct Node*p;\nstruct Node*head;\nstruct Node*tail;\nvoid Home()\n&#123;\n    p=head;\n&#125;\n\nvoid End()\n&#123;\n    p=tail-&gt;pre;\n&#125;\n\nvoid Left()\n&#123;\n    if(p==head) return;\n    p=p-&gt;pre;\n&#125;\n\nvoid Right()\n&#123;\n    if(p-&gt;next==tail) return;\n    p=tail-&gt;pre;\n&#125;\n\nvoid Back()\n&#123;   \n    if(p==head) return;\n    struct Node*tmp=(struct Node*)malloc(sizeof(struct Node));\n    tmp=p;\n    tmp-&gt;pre-&gt;next=tmp-&gt;next;\n    tmp-&gt;next-&gt;pre=tmp-&gt;pre;\n    free(tmp);\n&#125;\n    \n\nint main()&#123;\n    char s[50010];\n    int i;\n    struct Node*head=(struct Node*)malloc(sizeof(struct Node));\n    struct Node*tail=(struct Node*)malloc(sizeof(struct Node));\n    struct Node*p=head;\n    head-&gt;next=tail;\n    tail-&gt;pre=head;\n    tail-&gt;next=NULL;\n    head-&gt;pre=NULL; \n    \n    \n    scanf(&quot;%s&quot;,s);\n    \n    \n    for(i=0;s[i]!=&#39;\\0&#39;;i++)\n    &#123;\n            \n        if(s[i]==&#39;&#123;&#39;) Home();\n        else if(s[i]==&#39;&#125;&#39;) End();\n        else if(s[i]==&#39;&lt;&#39;) Left();\n        else if(s[i]==&#39;&gt;&#39;) Right();\n        else if(s[i]==&#39;#&#39;) Back();\n        else\n            &#123;\n            struct Node*q=(struct Node*)malloc(sizeof(struct Node));\n            q-&gt;data=s[i];\n            q-&gt;pre=p;\n            q-&gt;next=p-&gt;next;\n            p-&gt;next-&gt;pre=q;\n            p-&gt;next=q;\n            p=p-&gt;next;\n            &#125;\t\n            \n    &#125;\n    \n    \n    for(p=head-&gt;next;p!=tail;p=p-&gt;next)\n    &#123;\n        printf(&quot;%c&quot;,p-&gt;data);\n    &#125;\t\n\n&#125;\n\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nconst int M=100090;\nint nex[M];\nint pre[M];\nint valu[M];\nint idx;\nvoid initial(void)\n&#123;\n   //双链表相对单链表的初始化不同\n   nex[0]=1;//最左端指向最右端\n   pre[1]=0;//最右端指向最左端\n   idx=2;//另一个好处就是非常直白，双数肯定是向右的，单数向左的\n&#125;\nvoid add_to_right(int x,int k)\n&#123;\n    valu[idx]=x;\n    nex[idx]=nex[k];\n    pre[idx]=k;\n    //新节点的延申部位都搞定了，开始双向连接\n    pre[nex[k]]=idx;\n    nex[k]=idx;//\n    idx++;\n&#125;\n//更聪明的方法，在左边插入直接调用add_to_right(x,prev[k]),也就是在k的左边节点调用向右插\n\nvoid dele(int k)\n&#123;\n    nex[pre[k]]=nex[k];\n    pre[nex[k]]=pre[k];\n&#125;\nint main()\n&#123;\n    int tem;\n    int index;\n    int n;\n    cin&gt;&gt;n;\n    initial();\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        string a;\n        cin&gt;&gt;a;\n        if(a==&quot;D&quot;)\n        &#123;\n            cin&gt;&gt;index;\n            dele(index+1);\n        &#125;\n        if(a==&quot;L&quot;)\n        &#123;\n            cin&gt;&gt;tem;\n            add_to_right(tem,0);\n        &#125;\n        if(a==&quot;R&quot;)\n        &#123;\n            cin&gt;&gt;tem;\n            add_to_right(tem,pre[1]);\n        &#125;\n        if(a==&quot;IL&quot; )\n        &#123;\n            cin&gt;&gt;index&gt;&gt;tem;\n            add_to_right(tem,pre[index+1]);\n        &#125;\n        if(a==&quot;IR&quot; )\n        &#123;\n            cin&gt;&gt;index&gt;&gt;tem;\n            add_to_right(tem,index+1);\n        &#125;\n    &#125;\n    for(int i=nex[0];i!=1;i=nex[i])\n    &#123;\n        cout&lt;&lt;valu[i] &lt;&lt;&quot; &quot;;\n    &#125;\n    return 0;\n&#125;\n\n\n链表递归与双指针应用：力扣19题\n方法：未知链表长度情况下通过递归获取长度\n注意这种递归本质上是逆序进行扫描，从null扫描到head（不是空节点头，而是存放第一个值的头）\n读取顺序讲解：\n以1234，2示例如有a,b,c,d四个节点，分别存放1，2，3，4（a是头4是尾，4-&gt;next&#x3D;NULL）\n那么调用函数length时候会先一直向下扫描（因为未满足条件之前不会进行return），扫描到d的下一个节点null这时返回1-&gt;到达节点d，（因为有pos&#x3D;length(node-&gt;next,n)+1,+1导致从节点null返回d时候pos变成1）返回2（到达节点c），返回3（到达节点b），注意这时候满足倒序扫描到第三个了，也就是要删除的节点再向上回溯了1位,因此删除节点c,即node-&gt;next&#x3D;node-&gt;next-&gt;next**(b指向c变成b指向d)**\n好处：时间少（只用扫描一次），空间少（没有额外开辟指针）\n/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic://尝试递归解决\n\n    int length(ListNode *node,int n)//这一段千万千万注意是倒序，倒叙进行读取！！！\n    &#123;\n        if(node==NULL)return 0;//递归停止\n        int pos=length(node-&gt;next,n)+1;\n        if(pos==n+1)//进行判断了，说明在第几层递归\n            node-&gt;next=node-&gt;next-&gt;next;\n        return pos;//递归层层回溯\n    &#125;\n    \n    \n    \n    \n    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;\n        int pos =length(head,n);\n        if(pos==n)return head-&gt;next;//链表总长度刚好等于倒退长度，即处理头节点情况\n        return head;//\n    &#125;\n&#125;;\n\n参考网址：【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）\n同样利用递归实现链表逆序：（有那么一点点费脑子）原理：链表自身带有递归属性（一个大问题可以拆解成小问题）\n将链表拆分成头节点和剩余节点，同理继续拆解，一直拆解到最后的尾节点和前面的一堆“头”节点,最后一个节点不需要进行翻转\n\n\n这里就是对于子问题，将子链表进行翻转，就可以得到整个链表的反转，也就是递归的第一步\npublic ListNode reverseList(ListNode head) &#123;\n    // 调用递推公式反转当前结点之后的所有节点\n    // 返回的结果是反转后的链表的头结点\n    ListNode newHead = reverseList(head.next);\n&#125;\n\n这里假设后续子链表已经全部完成翻转，那么只需要对“头节点”完成翻转\n\n\n也就是\nhead-&gt;next-&gt;neat=head;\nhead-&gt;next=NULL;\n\n完善之后就是有\npublic ListNode reverseList(ListNode head) &#123;\n    // 调用递推公式反转当前结点之后的所有节点\n    // 返回的结果是反转后的链表的头结点\n    ListNode newHead = reverseList(head.next);\n    //到这里已经是假设后面的链表部分已经全部反转完成，也就是只需要处理头节点和剩余部分的关系\n    head.next.next = head;\n    head.next = null;\n    return newHead;//注意哦，这里返回的是newhead，因为newhead是反转之后的链表的头节点，即最尾部的节点\n&#125;\n\n再加上约束条件（递归终止条件）\n/*\nif (head == NULL || head-&gt;next == NULL) &#123;//返回条件/结束递归条件\n            return head;\n        &#125;\n   */\n\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        if (head == NULL || head-&gt;next == NULL) &#123;//返回条件/结束递归条件\n            return head;\n        &#125;\n        ListNode* ret = reverseList(head-&gt;next);//这里递归，ret会在走到链表末端开始翻转\n        head-&gt;next-&gt;next = head;\n        head-&gt;next = NULL;\n        return ret;//\n    &#125;\n&#125;;\n/*执行起来大概是这么一个既视感\n\n双指针实现逆序\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode* cur = NULL, *pre = head;\n        while (pre != NULL) &#123;//终止条件，最后的指针pre走到末尾停止\n            ListNode* temp = pre-&gt;next;\n            pre-&gt;next = cur;//开始反置指针指向\n            //cur和pre整体向前移动一个位置\n            cur = pre;\n            pre = temp;\n        &#125;\n        return cur;\n    &#125;\n&#125;;\n\n原理：一开始创建两个指针pre和cur，pre指向head，cur指向null，tem有点类似指针交换数值中的tem，指向正常链表顺序的下一个节点（这里就是head-&gt;next），\n\n有序链表的拼接（又是递归&#x2F;bushi）时间复杂度：O(m+n)\nclass Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;\n        if (l1 == NULL) &#123;//终止条件：l1走到末尾了\n            return l2;\n        &#125;\n        if (l2 == NULL) &#123;//终止条件：l2走到末尾了\n            return l1;//剩下的都弄上去就是\n        &#125;\n        \n        //分割线\n        if (l1-&gt;val &lt;= l2-&gt;val) &#123;\n            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);//对l1的剩余部分进行一个递归操作\n            //重点部分mergeTwoLists(l1-&gt;next, l2)，对l1后面的元素处理\n        \n            return l1;//因为L1的这个元素小，因此把它拎出来\n        &#125;\n        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);//对l2的剩余部分进行递归操作，l2-&gt;next同理\n      \n        return l2;//同理\n    &#125;\n&#125;;\n\n解释的一个部分\n\n关于return L1的个人理解: 递归的核心在于,我只关注我这一层要干什么,返回什么,至于我的下一层(规模减1),我不管,我就是甩手掌柜.\n\n好,现在我要merge L1,L2.我要怎么做?\n\n- 显然,如果L1空或L2空,我直接返回L2或L1就行,这很好理解.//上方的两个NULL情况\n- //如果L1第一个元素小于L2的? 那我得把L1的这个元素放到最前面,至于后面的那串长啥样 ,我不管. 我只要接过下级员工干完活后给我的包裹, 然后把我干的活附上去(令L1-&gt;next = 这个包裹)就行\n- 这个包裹是下级员工干的活,即merge(L1-&gt;next, L2)\n\n我该返回啥?\n\n- 现在不管我的下一层干了什么,又返回了什么给我, 我只要知道,假设我的工具人们都完成了任务, 那我的任务也就完成了,可以返回最终结果了\n- 最终结果就是我一开始接手的L1头结点+下级员工给我的大包裹,要一并交上去, 这样我的boss才能根据我给它的L1头节点往下找,检查我完成的工作\n\n回文链表判断：（映射，递归，翻转）映射到数组上再对数组进行操作\nclass Solution &#123;\npublic:\n    bool isPalindrome(ListNode* head) &#123;\n        vector&lt;int&gt; vals;\n        while (head != nullptr) &#123;\n            vals.emplace_back(head-&gt;val);//使用迭代器更加节省时间一些，如果是数组会报错\n            head = head-&gt;next;\n        &#125;\n        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;\n            if (vals[i] != vals[j]) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n优雅递归\n遍历节点的方式可是我看不懂\nclass Solution &#123;\n    ListNode* frontPointer;//这个是前指针\npublic:\n    bool recursivelyCheck(ListNode* currentNode) &#123;\n        if (currentNode != nullptr) &#123;\n            if (!recursivelyCheck(currentNode-&gt;next)) &#123;\n                return false;\n            &#125;\n            if (currentNode-&gt;val != frontPointer-&gt;val) &#123;\n                return false;\n            &#125;\n            frontPointer = frontPointer-&gt;next;\n        &#125;\n        return true;\n    &#125;\n\n    bool isPalindrome(ListNode* head) &#123;\n        frontPointer = head;\n        return recursivelyCheck(head);\n    &#125;\n&#125;;\n\n解释：currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val !&#x3D; frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。\n复杂度分析\n时间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。空间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。我们要理解计算机如何运行递归函数，在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 nn 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时空间复杂度要考虑堆栈的使用情况。这种方法不仅使用了 O(n)O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。\n快慢指针\n很优雅**但是我照样看不懂***没想到吧老子看懂了哈哈哈哈哈哈哈\nclass Solution &#123;\npublic:\n    bool isPalindrome(ListNode* head) &#123;\n        if (head == nullptr) &#123;\n            return true;\n        &#125;\n\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode* firstHalfEnd = endOfFirstHalf(head);//返回慢的那一半\n        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);//对中间开始往右的第一个开始翻转\n\n        // 判断是否回文\n        ListNode* p1 = head;\n        ListNode* p2 = secondHalfStart;\n        bool result = true;\n        while (result &amp;&amp; p2 != nullptr) &#123;\n            if (p1-&gt;val != p2-&gt;val) &#123;\n                result = false;\n            &#125;\n            p1 = p1-&gt;next;\n            p2 = p2-&gt;next;\n        &#125;        \n\n        // 还原链表并返回结果\n        firstHalfEnd-&gt;next = reverseList(secondHalfStart);//为了保证链表本身不变，实际上可以省略（大概）\n        return result;\n    &#125;\n\n    ListNode* reverseList(ListNode* head) &#123;//是你最爱的双指针翻转法\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr != nullptr) &#123;\n            ListNode* nextTemp = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = nextTemp;\n        &#125;\n        return prev;\n    &#125;\n\n    ListNode* endOfFirstHalf(ListNode* head) &#123;//快慢指针，快的走俩，慢的走1，在中点停止\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123;\n            fast = fast-&gt;next-&gt;next;\n            slow = slow-&gt;next;\n        &#125;\n        return slow;\n    &#125;\n&#125;;\n\nzhan（栈）不是B站那个前言：栈属于一种FILO数据结构，类似阉割版本的顺序表，在计算机中有非常广泛的应用\n例：使用递归时，编译器自身对于递归指令的使用就是一种栈，或者计算中缀表达式（通过将中缀表达式转换为后缀表达式，再对后缀表达式进行栈运算就可以得出结果）-&gt;全部利用栈的FILO结构\n栈制造方式\n数组栈-&gt;非常非常easy\n链表栈-&gt;参考链表，但是阉割\n\n栈做非降路径问题离散数学组合数学里面的东西，如果对一个栈仅允许出栈入栈操作，对输入固定长度字母求所有的输出模式，其实本质就是一个非降路径，只需要计算从(0,0)到(n,n)的不经过y&#x3D;x+1的所有路径\n中缀表达式转换后缀表达式(104条消息) 中缀表达式转后缀表达式的方法_說詤榢的博客-CSDN博客_中缀表达式转后缀表达式\n正则表达式分析分析：\n\n使用栈来求：中缀表达式可以拆分成一棵中缀树，后缀类似拆分成后缀树，如（1+1）（2+2），中缀中根节点是，叶节点是+，叶子是1 1 2 2，如果用树的思想去做应该使用树的中序遍历，但是问题在于不好处理运算符的优先级问题，而改造成后缀表达式就会方便很多，如同上例子换成后缀表达式变成了1 1 + 2 2 + *，然后使用栈来进行运算，数字压栈，运算符出栈两个进行运算后再次压栈，这样就可以避开运算符优先级的处理问题（相对更好理解一些而且不需要搭建树，可以使用栈来搞）\n使用递归来求：已知将该表达式抽象成为一棵树，那么对每个子树使用递归求值可以不断削减树的层数，最后获得根树的值（**很牛逼但是很麻烦，要提前接触到树**）\n\n这里使用栈来进行一个中缀表达式的计算\n先看下只有 + 和 * 的。\n输入长度为n的字符串，例如：1+2+345\n输出表达式的值，即：63\n应该用什么数据结构？\n栈。\n应该先计算哪一步？\n实际应该先计算1+2。\n“表达式求值”问题，两个核心关键点：\n（1）双栈，一个操作数栈，一个运算符栈；\n（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：\n如果栈顶的运算符优先级低，新运算符直接入栈\n如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈\n仍以1+2+345举例，看是如何利用上述两个关键点实施计算的。\n首先，这个例子只有+和*两个运算符，所以它的运算符表是：\n\n这里的含义是：\n（1）如果栈顶是+，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；\n（2）如果栈顶是+，即将入栈的是*，栈顶优先级低，直接入栈；\n（3）如果栈顶是*，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；\n（4）如果栈顶是， 即将入栈的是，栈顶优先级高，需要先计算，再入栈；\n有了运算符表，一切就好办了。\n\n一开始，初始化好输入的字符串，以及操作数栈，运算符栈。\n\n一步步，扫描字符串，操作数一个个入栈，运算符也入栈。\n\n下一个操作符要入栈时，需要先比较优先级。\n栈内的优先级高，必须先计算，才能入栈。\n\n计算的过程为：\n（1）操作数出栈，作为num2；\n（2）操作数出栈，作为num1；\n（3）运算符出栈，作为op；\n（4）计算出结果；\n\n（5）结果入操作数栈；\n\n接下来，运算符和操作数才能继续入栈。下一个操作符要入栈时，继续比较与栈顶的优先级。\n栈内的优先级低，可以直接入栈。\n\n字符串继续移动。\n\n又要比较优先级了。\n\n栈内的优先级高，还是先计算（3*4&#x3D;12），再入栈。\n\n不断入栈，直到字符串扫描完毕。\n\n不断出栈，直到得到最终结果3+60&#x3D;63，算法完成。\n总结\n“表达式求值”问题，两个核心关键点：\n（1）双栈，一个操作数栈，一个运算符栈；\n（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：如果栈顶的运算符优先级低，新运算符直接入栈\n如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈\n这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。\n运算符有+-&#x2F;()~^&amp;都没问题，如果共有n个运算符，会有一个nn的优先级表。\n正则表达式代码代码：\n上       代        码\n虽然但是接下来这个代码是中缀计算的\n#include &lt;iostream&gt;\n#include &lt;stack&gt;//stl库中使用栈\n#include &lt;string&gt;//\n#include &lt;unordered_map&gt;//一个目前不太懂的头文件，回头看primer自己理解吧\nusing namespace std;\n\nstack&lt;int&gt; num;//存储数字的栈\nstack&lt;char&gt; op;//存储运算符的栈\n\n//优先级表\nunordered_map&lt;char, int&gt; h&#123; &#123;&#39;+&#39;, 1&#125;, &#123;&#39;-&#39;, 1&#125;, &#123;&#39;*&#39;,2&#125;, &#123;&#39;/&#39;, 2&#125; &#125;;\n\n\nvoid eval()//求值\n&#123;\n    int a = num.top();//第二个操作数\n    num.pop();\n\n    int b = num.top();//第一个操作数\n    num.pop();\n\n    char p = op.top();//运算符\n    op.pop();\n\n    int r = 0;//结果 \n\n    //计算结果\n    if (p == &#39;+&#39;) r = b + a;\n    if (p == &#39;-&#39;) r = b - a;\n    if (p == &#39;*&#39;) r = b * a;\n    if (p == &#39;/&#39;) r = b / a;\n\n    num.push(r);//结果入栈到num中\n&#125;\n\nint main()\n&#123;\n    string s;//读入表达式\n    cin &gt;&gt; s;\n\n    for (int i = 0; i &lt; s.size(); i++)//调用了string的函数s.size()\n    &#123;\n        if (isdigit(s[i]))//判断数字入栈\n        &#123;\n            int x = 0, j = i;//计算数字\n            while (j &lt; s.size() &amp;&amp; isdigit(s[j]))\n            &#123;\n                x = x * 10 + s[j] - &#39;0&#39;;//将string型的数字转换为int？\n                j++;\n            &#125;\n            num.push(x);//数字入栈\n            i = j - 1;\n        &#125;\n        //左括号无优先级，直接入栈\n        else if (s[i] == &#39;(&#39;)//左括号入栈\n        &#123;\n            op.push(s[i]);\n        &#125;\n        //括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的\n        else if (s[i] == &#39;)&#39;)//右括号\n        &#123;\n            while(op.top() != &#39;(&#39;)//一直计算到左括号\n                eval();\n            op.pop();//左括号出栈\n        &#125;\n        else\n        &#123;\n            while (op.size() &amp;&amp; h[op.top()] &gt;= h[s[i]])//待入栈运算符优先级低，则先计算\n                eval();\n            op.push(s[i]);//操作符入栈\n        &#125;\n    &#125;\n    while (op.size()) eval();//剩余的进行计算\n    cout &lt;&lt; num.top() &lt;&lt; endl;//输出结果\n    return 0;\n&#125;\n\n单调栈（瞳孔地震型题解）😢使用单调递增栈\n麻烦地方：超时\n考虑方式有些类似双指针\n思路：暴力-&gt;优化暴力\n队列里面是否有元素没用\n\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N=10010;\nint n;\nint stk[N],tt;\nint main()\n&#123;\n    cin&gt;&gt;n;//总共要输入几次数\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        int x;\n        cin&gt;&gt;x;\n        while(tt&amp;&amp;stk[tt]&gt;=x)tt--;//如果栈内元素只要比待进入元素小就弹出\n        if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;//弹出后输出第一个栈顶元素\n        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;//栈空后输出-1\n        stk[++tt]=x;//一轮走下来以后新的元素入栈\n    &#125;\n    return 0;\n&#125;\n\n队列FIFO构造\n队列构造方式：数组构造（也是hin简单就是了）😒\n//模板用栈直接改都可以\nconst int M=200600;\n\nint bottom=0;//队列底部，弹出时候bottom+1\nint line[M]=&#123;0&#125;;\nint top=0;//队列头部，增加时候top+1\nvoid insert(int x)//入队\n&#123;\n    \n    line[top]=x;\n    ++top;\n&#125;\nvoid pop(void)\n&#123;\n    bottom++;//底部上移\n&#125;\nvoid query(void)\n&#123;\n   cout&lt;&lt;line[bottom]&lt;&lt;endl;\n   return;\n&#125;\nvoid empty(void)\n&#123;\n    if(top==bottom)cout&lt;&lt;&quot;YES\\n&quot;;\n    else cout&lt;&lt;&quot;NO\\n&quot;;\n    return;\n&#125;\n\n循环队列：模板：\n// hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh = 0, tt = 0;\n\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;//如果到达某一特定值那么就重置变成队头\n\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空\nif (hh != tt)//不为空\n&#123;\n\n&#125;\n\n单调队列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）😶‍🌫️准备好开始头疼\n思路同单调栈：从暴力解决入手接着开始优化\n可以使用队列对窗口进行维护（标准的入列和出列）\n优化：队列中是否有没用的元素，对没用的元素进行删除看能否得到单调性，如3，-1，-3，在-3入列的时候就有3&gt;-3，则最小值一定不会是3而且-3存在时间更久，因此使用单调栈的同样原理可以求出单调最小，并且是一个单调递增的最小\n可以使用STL标准库来写或者说使用栈和队列数组模拟去写，而相对而言使用数组有很大的好处在于数组速度快，在比赛或者笔试时候会慢一些，在IDE中可能会有O2或者O3优化\n再看一遍单调栈\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N=10010;\nint n;\nint stk[N],tt;\nint main()\n&#123;\n    cin&gt;&gt;n;//总共要输入几次数\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        int x;\n        cin&gt;&gt;x;\n        while(tt&amp;&amp;stk[tt]&gt;=x)tt--;//如果栈内元素只要比待进入元素大就弹出\n        if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;//弹出后输出第一个栈顶元素\n        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;//栈空后输出-1\n        stk[++tt]=x;//一轮走下来以后新的元素入栈\n    &#125;\n    return 0;\n&#125;\n\n\n解题思路（以最大值为例）：\n由于我们需要求出的是滑动窗口的最大值。\n如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i&lt;j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：\n当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。\n因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。\n因此我们可以使用一个队列存储所有还没有被移除的下标，这里是q。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。\n当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。\n为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。\n由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。\n窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。\n每一个窗口的最大值\nhh = 0; tt = -1;          //头在左尾在右                         // 重置！\n    for (int i = 0; i &lt; n; ++ i)\n        //注意这个栈可以想成朝着右边（tt，正常栈操作），但是底部可以操作（hh，向右缩）\n    &#123;\n        //窗口终点是i，那么起点就是i-k+1\n        if (i - k + 1 &gt; q[hh]) ++ hh;//窗口左边向右移动一个\n        \n        //这里操作下来要是从大到小的排列\n        \n        while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;//右边已经有更大的了，之前的小的a[q[tt]]可以不用考虑了，就操作tt\n        q[++ tt] = i;//窗口右边向右移动一个\n        //i+1&gt;=k这里就是一个特判，因为一开始窗口没有值，只有窗口全部充满之后才有后面的操作\n        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);//这里知道栈的底部（也就是q[hh]）对应的下标是该窗口中没有删除而且是最大的\n    &#125;\n\n判断最小\nint a[N]=&#123;0&#125;;\nint q[N]=&#123;0&#125;;\nint hh=0;\nint tt = -1;//尾部是1\nint n, k;//hh是头，tt是尾，\n//\n\n//头在左尾在右\n\n\n\n    cin &gt;&gt; n &gt;&gt; k;//k是窗口大小\n    for (int i = 0; i &lt; n; ++ i)\n    &#123;\n        //这里是关于窗口的维护\n        scanf(&quot;%d&quot;, &amp;a[i]);//数组a存放了所有的数字\n        if (i - k + 1 &gt; q[hh]) ++ hh;       \n        //数组q存放的是下标\n        // 若队首出窗口，hh加1，即整体向前移动一格\n        \n        //这里开始跟单调栈的原理相同\n        /*\n        hh&lt;=tt是队列不为空\n        a[i] &lt;= a[q[tt]]这里就是单调栈的如果新来的a[i]不是栈里面最大的就弹栈，--tt\n        */\n        while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1\n        q[++ tt] = i;                                  // 下标加到队尾，新元素入栈，上面入的是元素本身这里入的是元素下标\n        \n        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);       // 这里确定过栈中的都是最小的元素了因此直接输出\n        //输出结果\n    &#125;\n    cout &lt;&lt; endl;//换行\n\n全部代码！\n# include &lt;iostream&gt;\nusing namespace std;\nconst int N = 1000010;\nint a[N], q[N], tail = -1;\nint head=0;\n//a存储正常原数组的值\n//注意注意q存储的是a的“下标”，“下标”而不是“值”\nint main()\n&#123;\n    int n, k;//hh是头，tt是尾\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++ i)//输出最小，每一次循环里面q[head]的值也就是a[q[head]]总是窗口中最小的\n    &#123;\n        //i-k+1就是窗口头部位置\n        scanf(&quot;%d&quot;, &amp;a[i]);\n        if (i - k + 1 &gt; q[head]) ++ head;                  // 若队首出窗口，head加1\n        while (head &lt;= tail &amp;&amp; a[i] &lt;= a[q[tail]]) -- tail;    // 若队尾不单调，tail持续减1\n        q[++ tail] = i;                                  // 下标加到队尾,尾部进入窗口\n        if (i-k + 1 &gt;= 0) printf(&quot;%d &quot;, a[q[head]]);       // 输出结果(只有窗口形成之后才会输出)\n    &#125;\n    cout &lt;&lt; endl;\n    head = 0; tail = -1;                                   // 重置！\n    for (int i = 0; i &lt; n; ++ i)\n    &#123;\n        if (i - k + 1 &gt; q[head]) ++ head;\t\t\t\t//判断头部是否出窗口\n        while (head &lt;= tail &amp;&amp; a[i] &gt;= a[q[tail]]) -- tail;\n        q[++ tail] = i;\n        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[head]]);\n    &#125;\n    return 0;\n&#125;\n\n串KMP(100条消息) 数据结构KMP算法配图详解（超详细）_哈顿之光的博客-CSDN博客_kmp算法难吗是什么级别（好好看好好学）\n模板y总注意kmp算法的下标要从1开始弄！\nfor(int i=1;i&lt;=n;i++)//一开始就是1开始弄的\n&#123;\n    cin&gt;&gt;p[i];\n&#125;\n\n或者邪教读取法:cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1\n\n// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度\n求模式串的Next数组：\nfor (int i = 2, j = 0; i &lt;= m; i ++ )//与匹配部分基本一样一样\n&#123;//一点细节，这里是子串p\n    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];//也是回溯\n    if (p[i] == p[j + 1]) j ++ ;//匹配成功子串向前走\n    ne[i] = j;//欸，这里不一样了，\n    //ne数组其实也是一样样的，i=2是因为实际上1是肯定是0（前面都没字符自然是0），ne数组也是从1开始\n&#125;\n\n// kmp匹配\nfor (int i = 1, j = 0; i &lt;= n; i ++ )//\n&#123;//一点细节，下面是长串s\n    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];//不相等的时候递归回退，与代码随想录是一种方法\n    if (s[i] == p[j + 1]) j ++ ;//如果匹配成功，子串也向前一位走\n    if (j == m)\n    &#123;\n        j = ne[j];//回溯到前一次\n        // 匹配成功后的逻辑\n    &#125;\n&#125;\n\n\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N=100010,M=1000010;\nchar p[N],s[M];\nint ne[N];\nint n,m;\nint main()\n&#123;\n    cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;\n    for(int i=2,j=0;i&lt;=n;i++)\n    &#123;\n        while(j&amp;&amp;p[i]!=p[j+1])j=ne[j];\n        if(p[i]==p[j+1])j++;\n        ne[i]=j;\n    &#125;\n    for(int i=1,j=0;i&lt;=m;i++)\n    &#123;\n        while(j&amp;&amp;s[i]!=p[j+1])j=ne[j];\n        if(s[i]==p[j+1])j++;\n        if(j==n)\n        &#123;\n            cout&lt;&lt;i-n&lt;&lt;&#39; &#39;;//就是输出下标\n            j=ne[j];\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n关键：特殊数组next的构造，前缀表\n\n下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了\n前缀表：字符串的最长前缀：不包含尾字符的所有子串\n后缀：相较于前缀，不包含首字母的所有子串\n因此如果仅有单个字符则其前缀为0\n特性：\n目前讲解的构造方法\n例：子串aabaabaaf，前缀表010120(aabaaf)\n\n前缀形式：010120\n全部后移方式：-1 0 10120\n整体减一方式：-1 0 -1 0 1 -1\n\n共同点：最后都应当保持封闭，虽然理解有出入但本质相同\n代码随想录方法：前缀不减形式prev,latter;\nprev:前缀末尾位置，同时代表prev包括prev之前子串最长相等前后缀的长度，也表示前缀末尾\nlatter:后缀末尾位置\n初始化\nprev=0;\nlatter=1;\nnext[0]=0;\n//初始化latter\n\n开始处理前后缀不同情况\n\n//prev和latter一直不相等\nfor(latter=1;latter&lt;slength;latter++)//后缀指针只管往前走就完事\n&#123;\n    //这里if是出错的根源\n    while(s[prev]!=s[latter]&amp;&amp;prev&gt;0)//注意这里因为有-1存在所以一定小心越界，\n    &#123;\n        prev=next[prev-1];//prev冲突时候是一个连续回退的过程，如果使用if就错了，使用while循环回退\n    &#125;\n    //只要s[latter]!=s[prev]时候prev应该向前回退\n    //原因：使用前缀表在进行kmp对比的时候如果遇到冲突，也是看冲突位置前一位的表进行跳转\n    \n    分界线：前后缀相同的情况\n        if(s[prev]==s[latter])\n        &#123;\n            prev++;//代表prev之前最长相等前缀可以更新\n           \n           //latter因为有for循环，因此自然向前有++操作\n        &#125;\n         next[latter]=prev;//更新next数组的值\n    \n    \n&#125;\n\n这里则是全部操作的部分\n    void getNext(int* next, const string&amp; s) &#123;\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i &lt; s.size(); i++) &#123;\n            while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123;\n                j = next[j - 1];\n            &#125;\n            if (s[i] == s[j]) &#123;\n                j++;\n            &#125;\n            next[i] = j;\n        &#125;\n    &#125;\n//这里是返回第一个找到的下标\n    int strStr(string haystack, string needle) &#123;\n        if (needle.size() == 0) &#123;\n            return 0;\n        &#125;\n        int next[needle.size()];\n        getNext(next, needle);//获取next数组\n        int j = 0;\n        for (int i = 0; i &lt; haystack.size(); i++) &#123;\n            while(j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;\n                j = next[j - 1];//一样进行回溯\n            &#125;\n            if (haystack[i] == needle[j]) &#123;\n                j++;\n            &#125;//使用循环，直接对prev进行+就行\n            if (j == needle.size() ) &#123;\n                return (i - needle.size() + 1);\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n\n注意这里是文本串和模式串不匹配时候的操作（这里next数组采用正常前缀表）\n数据结构作业出错原因要求每一个都求出来\n问题在于：当每一次满足条件后进行清零操作，本质上同一次两者不等时候的回溯操作（prev到上一位最接近的前缀位置）,如果使用prev&#x3D;0就会出现可能错过\n例：\n    ababa  aba 001\n    //正确解\n    if(prev==sublength)\n        &#123;\n            cout&lt;&lt;endl&lt;&lt;latter-sublength+1&lt;&lt;endl;\n            prev=next[prev-1];//回溯\n        &#125;\n    //在第一次解的时候prev=3;latter=2(因为latter在一次循环之后才会有增操作)\n    /*\n    使用回溯prev=1,sub[prev]=b那么就接着从latter=3.T[latter]=b无缝开始向前对比\n    */\n\n/错误\n    if(prev==sublength)\n        &#123;\n            cout&lt;&lt;endl&lt;&lt;latter-sublength+1&lt;&lt;endl;\n            prev=0;//这样就会是错误结果\n        &#125;\n\nautomata~有限状态自动机参考：\n\n(100条消息) 字符串匹配算法之：有限状态自动机_tyler_download的博客-CSDN博客_有限自动机算法\n苏老师坚果云ppt状态机代码部分\n\n代码（构建自动机状态表）dfa[0][P[0]] = 1; //初始化第一行\n// dfa[状态][下一个字符] for(int X = 0, j = 1; j &lt; plen; j++) &#123;\n\n// 计算 dfa[j][]\n\nfor(int c = 0; c &lt; R; c++) &#123; // R 为字符种类数量\n\ndfa[j][c] = dfa[X][c];\n\n&#125; dfa[j][P[j]] = j + 1; X = dfa[X][P[j]]\n\n&#125;\n\n\n\n聪明版本自动机已知ascii码总共就128个，直接开一个大表就行\nint dfa[256][256]=0;//这样直接省略后续一系列初始化，使用int转换字符串传入就行，非常省心\n\nTRIE树（有些类似哈夫曼树编码）类似但和哈夫曼树没有关系\n又称字典树、单词查找树\n应用：快速存储和查找字符串集合的数据结构\n如何存储：构建串树从根节点开始存储每一个字符，开始逐个向下进行创建，在单词的末尾打上一个标记表示该单词走到结尾了\n\n\nTRIE树本质是一颗N叉树，有多少种字符一个节点就最多有多少条边\n\n如何查找从单词的首字母开始向下走，走到标记表示到头了\n构建TRIE树这里使用了数组模拟树的知识\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint son[N][26];\n//这里是26因为只有小写字母\n//二维是可以有多少个分支，一维的意义是来自哪一个双亲节点\nint cnt[N], idx;//idx是下标为0的点，是根节点和空节点，表示当前要插入的节点是第几个,每创建一个节点值+1\n   // cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）\nchar str[N];//存储要插入/查询的单词\n\nvoid insert(char *str)\n&#123;\n    int p = 0; //类似指针，指向当前节点\n    for (int i = 0; str[i]; i ++ )\n    &#123;\n        int u = str[i] - &#39;a&#39;;//u表示是具体哪一个字母\n        //p表示的是第几个结点，u表示的是哪个字母，如果s[p][u]不为空就证明有以这个字母为值的子结点\n        //它代表的值就是指向了该子结点，即说明了第几个结点是它的子结点\n         //如s[2][1]=3，表示结点2有一个值为b（第二个数字代表的是a～z）的子结点，是结点3\n        if (!son[p][u]) son[p][u] = ++ idx;//不存在就创建节点\n        //令p指向子结点\n        p = son[p][u];\n    &#125;\n    //不管是未存在过的新插入还是已有字典再增加一个，都是以这个结点为末尾的字符串次数加1\n    cnt[p] ++ ;//结束时的标记，也是记录以此节点结束的字符串个数\n    //这一步重要！\n    \n    \n&#125;\n\nint query(char *str)\n&#123;\n    int p = 0;\n    for (int i = 0; str[i]; i ++ )//走到该单词为0\n    &#123;\n        int u = str[i] - &#39;a&#39;;//获得对应子节点的编号\n        if (!son[p][u]) return 0;\n        p = son[p][u];\n    &#125;\n    return cnt[p];//返回以p为结尾的单词数量\n&#125;\n\nint main()//这里有I是插入字符串，其它是查找该字符串\n&#123;\n    int n;\n    scanf(&quot;%d&quot;, &amp;n);\n    while (n -- )\n    &#123;\n        char op[2];\n        scanf(&quot;%s%s&quot;, op, str);//前一次输入被覆盖\n        if (*op == &#39;I&#39;) insert(str);\n        else printf(&quot;%d\\n&quot;, query(str));\n    &#125;\n\n    return 0;\n&#125;\n\nTRIE树的其它应用https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF\n启示：字典树不单单可以高效存储和查找字符串集合，还可以存储二进制数字\n思路：利用二叉树对所有的aiaj建立一个串数组，对于每一个固定的ai，每一次尽量与和当前不同的分支向下走，走到底这样一定就可以得到最优解\n即顺序：所有值的二进制表示建立树-&gt;遍历一次，每一个ai进行寻找对应的最大的值，最后遍历一次之后获得答案\n算法复杂度：（建立树）+n（每一个ai只需要在已经建立好的树再从头到尾走一次就好）\n代码：insert函数改：\n每个数看作一个31位长度的二进制数，最高位是0往0走，最高位1往1走，然后和类似TRIE的操作，但是构建的是一颗二叉树（一定概率变成斜树）\nvoid insert(int x)\n&#123;\n    int p=0;  //根节点\n    for(int i=30;i&gt;=0;i--)//从最大位开始建立\n    &#123;\n        int u=x&gt;&gt;i&amp;1;   /////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)\n        if(!son[p][u]) son[p][u]=++idx; ///如果插入中发现没有该子节点,开出这条路\n        p=son[p][u]; //指针指向下一层\n    &#125;//与上面不一样这里就不需要标记\n&#125;\n\nint search(int x)\n&#123;\n    int p=0;int res=0;\n    for(int i=30;i&gt;=0;i--)\n    &#123;                               ///从最大位开始找\n        int u=x&gt;&gt;i&amp;1;\n        if(son[p][!u]) ////如果当前层有对应的不相同的数\n        &#123;   ///p指针就指到不同数的地址\n\n          p=son[p][!u];\n          res=res*2+1;//右移，因为树右儿子是1\n             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001\n        &#125;                                                   ///       010 \n        else////   ---&gt;011                                                                           \n            //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1\n        &#123;\n            p=son[p][u];\n            res=res*2+0;//左移，因为树左儿子是1\n        &#125;\n    &#125;\n    return res;\n&#125;\n\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint const N=100010,M=31*N;//M表示树的节点个数，每个数最多有31个长度，因此建立\nint n;\nint a[N];\nint son[M][2],idx;\n//M代表一个数字串二进制可以到多长\n\nvoid insert(int x)\n&#123;\n    int p=0;  //根节点\n    for(int i=30;i&gt;=0;i--)//这里相等i&gt;=0\n    &#123;\n        int u=x&gt;&gt;i&amp;1;   /////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)\n        if(!son[p][u]) son[p][u]=++idx; ///如果插入中发现没有该子节点,开出这条路\n        p=son[p][u]; //指针指向下一层\n    &#125;\n&#125;\nint search(int x)\n&#123;\n    int p=0;int res=0;\n    for(int i=30;i&gt;=0;i--)\n    &#123;                               ///从最大位开始找\n        int u=x&gt;&gt;i&amp;1;\n        if(son[p][!u]) ////如果当前层有对应的不相同的数\n        &#123;   ///p指针就指到不同数的地址\n\n          p=son[p][!u];\n          res=res*2+1;\n             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001\n        &#125;                                                       ///       010 \n        else                                            ////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1\n        &#123;\n            p=son[p][u];\n            res=res*2+0;\n        &#125;\n    &#125;\n    return res;//最后返回是十进制形态的答案\n&#125;\nint main(void)\n&#123;\n    cin&gt;&gt;n;\n    idx=0;\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        cin&gt;&gt;a[i];\n        insert(a[i]);\n    &#125;\n    int res=0;\n    for(int i=0;i&lt;n;i++)\n    &#123;   \n        res=max(res,search(a[i]));  ///search(a[i])查找的是a[i]值的最大与或值\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n&#125;\n\n跳表——同样面试——但是不用手搓一些参考的博客：(101条消息) 十分钟弄懂什么是跳表，不懂可以来打我_愤怒的可乐的博客-CSDN博客_跳表\n优点：将链表查找的时间复杂度改造成log，据说可以取代红黑树\n跳表属于对链表的改进\n有点相似kmp？通过一些手段加快跳跃的速度\n想法：链表中增加一些“超级链接”\n特点：\n跳表结合了链表和二分查找的思想\n由原始链表和一些通过“跳跃”生成的链表组成\n第0层是原始链表，越上层“跳跃”的越高，元素越少\n上层链表是下层链表的子序列\n查找时从顶层向下，不断缩小搜索范围\n每一层增长哪一个节点实际上是随机生长的\n\n核心思想：\n跳表节点中用数组存储不同层级的下一个节点\n随即生长\n空间使用率最高的跳表\n\n实现构建过程：初始化和单链表一样，仅有一个空节点，\nprivate class Node &#123;\n    //保存值\n    E data;\n    //保存了每一层上的节点信息，可能为null\n    List&lt;Node&gt; forwards;\n\n    Node(E data) &#123;\n        this.data = data;\n        forwards = new ArrayList&lt;&gt;();\n        //事先把每一层都置为null，虽然空间利用率没那么高，但是简化了实现\n        //也可以通过自定义列表(比如B树实现中用到的Vector)来实现，就可以不用下面的操作\n        for (int i = 0; i &lt;= maxLevel; i++) &#123;\n            forwards.add(null);\n        &#125;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return data == null ? &quot; &quot; : &quot;&quot; + data;\n    &#125;\n\n    /**\n     * 得到当前节点level层上的下一个(右边一个)节点\n     *\n     * @param level\n     * @return\n     */\n    Node next(int level) &#123;\n        return this.forwards.get(level);\n    &#125;\n\n&#125;\n\nTRIE树的其它散列表——哈希表-面试很重要特点：查找与删除，查找全部在常数时间内完成\n应用：\n\n操作系统\n数据库\n编译器\n计网\n图像检索（最初始用于人脸识别等）\n\n线性表总结：\n哈希定义，应用本质：给定一个输入给出一个唯一的序列号输出，将一个比较大的空间映射到一个比较小的空间，将一个复杂的数据结构映射到一个小的\n应用举例： \n\n输入n个数10^5，数的范围+-10^9,选择一些数字插入，选择另外一些数字查询\n文本压缩和解压缩\n\n定位的过程：元素通过哈希函数转换成唯一的整数（必须快速计算）\n第一步：将一个元素映射成一个整数\n哈希模板（正常+字符串版本）(1) 拉链法\n    int h[N], e[N], ne[N], idx;\n    const int  N=1e5+3;\n    // 向哈希表中插入一个数\n    void insert(int x)//这么理解：就是正常的数组模拟链表，但是加入哈希函数\n    &#123;\n        int k = (x % N + N) % N;\n        e[idx] = x;\n        ne[idx] = h[k];//就是把head换成了h[k],因为原先是单链，现在多链\n        h[k] = idx ++ ;\n    &#125;\n\n    // 在哈希表中查询某个数是否存在\n    bool find(int x)\n    &#123;\n        int k = (x % N + N) % N;//首先哈希\n        for (int i = h[k]; i != -1; i = ne[i])\n            &#123;if (e[i] == x)\n                return true;&#125;\n\n        return false;\n    &#125;\n\n(2) 开放寻址法\n    const int N=2e5+3;//开放寻址的大小要放大的\n    int h[N];\n    const int null=0x3f3f3f3f;\n    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n    int find(int x)\n    &#123;\n        int t = (x % N + N) % N;\n        while (h[t] != null &amp;&amp; h[t] != x)//这里易错，是&amp;&amp;\n        &#123;\n            t ++ ;\n            if (t == N) t = 0;\n        &#125;\n        return t;\n    &#125;\n\n核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\n\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n&#123;\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n&#125;\n\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\n分配索引值这里对字符进行处理，每一种字符都视为一种对应的数字，不同的位数有不同的加权值\nunsigned int hash(char *key)\n&#123; unsigned int hash_val = 0;\n while(*key != &#39;\\0&#39;) \n &#123; hash_val = (hash_val &lt;&lt; 5) + *key++;\n//这里使用&lt;&lt;实际上就是直接×2^5\n  //每一次移动5位（这样子硬件便于实现，参考计组）\n&#125; return hash_val;\n\n&#125;\n\n缺点：虽然时间非常高效，但是空间浪费非常大（毕竟不能载满）\n减少索引值：方法1：忽略一部分元素，将另一部分直接视为索引值\n好处：快，坏处：难于分配索引值\n方法2：折叠，使用不同方式将原数据拆分，再合并在一起\n方法3：余数运算，可以元素值除以某一特殊数字，余数用作索引值，\nunsigned int hash(char *key, unsigned int H_SIZE) \n&#123; unsigned int hash_val = 0; while(*key != &#39;\\0&#39;) &#123; hash_val = (hash_val &lt;&lt; 5) + *key++;\n\n&#125; return hash_val % H_SIZE;//这里缩了一下\n\n&#125;\n\n字符串哈希——&gt;字符串前缀哈希法作用有些类似kmp，字符串也可以用哈希表做-&gt;一个集合到另一个集合的映射\n实际上是字符串的前缀哈希法，对前缀进行哈希\n问题：\n\n如何定义某一个前缀的哈希值，可以将字符串视为p进制的一个数，每一位上的字母（acscii）视为对应的数字，但是不能映射成0-&gt;相同的字符串映射结果会相同-&gt;AA等等\n哈希字符串假定人品足够不存在碰撞，没有考虑冲突情况，经验值：p取131或13331时候，q取2^64，几乎99%情况不会出现冲突\n\n好处：可以利用最前的哈希计算出所有子串的哈希，\n已知h[r],h[l],\nh[r]中r为第0位，h[l-1]中l-2为第0位\n操作\n\nh[l-1]与h[r]对齐，即向后移动多少位\nh[r]-h[l-1]就能求出来了\n\n小技巧：使用unsigned long long 存储所有h，相当于对所有数取模了(因为溢出就相当于取模)\n总结：左移高位对齐\n之后对前缀全部处理完之后，就能用o1时间计算任意子串哈希值\n预处理：h[i]&#x3D;h[i-1]*p+str[i] (第i位字母)\n牛逼的地方：比kmp牛逼：可以快速判断，快过o(n),是处理字符串的利器\n代码核心部分：\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n&#123;\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n&#125;\n\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\n完整代码：\n841. 字符串哈希 - AcWing题库\nAcWing 841. 字符串哈希 【公式助理解】 - AcWing\n\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;string&gt;\nusing namespace std;\ntypedef unsigned long long ULL;//也就是取模2^64，\nconst int N = 1e5+5,P = 131;//131 13331\nULL h[N],p[N];\n\n// h[i]前i个字符的hash值\n// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字\n// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突\n// 使用场景： 两个字符串的子串是否相同\nULL query(int l,int r)&#123;\n    return h[r] - h[l-1]*p[r-l+1];\n    //为求l到r的哈希值\n    //已知h[r],h[l-1]，也就是1到l-1，1到r的哈希值\n    //因为字符串视为一个p进制的数，因此越左边权重越高，为高位，右边是低位\n    //h[r]中r是第0位，h[1]为r-1位\n    //h[l-1]l-1是第0位，h[1]为l-2位\n    //两者相差r-1-l+2=r-l+1位\n    //本质就是高位对齐，h[r]与h[l-1]对齐，\n&#125;\nint main()&#123;\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    string x;\n    cin&gt;&gt;x;\n\n    //字符串从1开始编号，h[1]为前一个字符的哈希值\n    p[0] = 1;\n    h[0] = 0;\n    //以上是初始化，第0位实际上不加入计算\n    for(int i=0;i&lt;n;i++)&#123;\n        p[i+1] = p[i]*P;            \n        h[i+1] = h[i]*P +x[i];      //前缀和求整个字符串的哈希值\n        //这里x也是从第一位开始，也就是0\n    &#125;\n\n    while(m--)&#123;\n        int l1,r1,l2,r2;\n        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;\n        if(query(l1,r1) == query(l2,r2)) printf(&quot;Yes\\n&quot;);\n        else printf(&quot;No\\n&quot;);\n\n    &#125;\n    return 0;\n&#125;\n\n哈希碰撞处理（面试高频）😍😍😍😍😍可以把离散化看成一种特殊的哈希方式\n哈希表属于期望算法，可以将哈希表的链长视为一个常数，\n碰撞：两个相同的索引放在相同的索引位置\n碰撞可能性很大-&gt;定义域很大值域比较小\n拉链法（Open Hashing）原理：如果多个索引值最终哈希值相同，使用链表的形式另外存储相同的值\n添加，直接添加链\n查找：对应位置在链表遍历一下\n删除：算法题中一般不会进行删除节点，而是会开 一个数组打一个标记（如bool标记）\n数学上取质数，而且举例2的幂尽可能远冲突概率最小\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 3;  // 取大于1e5的第一个质数，而且要离2的整次幂尽可能远， 取质数冲突的概率最小\n\n//* 开一个槽 h\n//图论中存点的方式和数组的链法一样，都是一个数组一个链\nint h[N], //哈希表\n//经典数组实现链表\ne[N], \nne[N], \nidx;  //邻接表\n\nvoid insert(int x) &#123;\n    // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数\n    int k = (x % N + N) % N;//k就是对应的哈希值，这一步实现了映射。接下来是写入\n    //(x%N+N)这一步为了最后一定是一个正数，如果是负数数组无法写入\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx++;\n&#125;\n\nbool find(int x) &#123;\n    //用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i]) &#123;//这里是遍历对应到的链表\n        //同时由于初始化是-1，开始哈希数组也要初始化为-1\n        if (e[i] == x) &#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint n;\n\nint main() &#123;\n    cin &gt;&gt; n;\n\n    memset(h, -1, sizeof h);  //将槽先清空 空指针一般用 -1 来表示\n    //\n\n    while (n--) &#123;\n        string op;//字符串的话编译器会自动忽略空格，换行符等，不容易出错\n        //有些脏数据会增加额外空格\n        int x;\n        cin &gt;&gt; op &gt;&gt; x;\n        if (op == &quot;I&quot;) &#123;\n            insert(x);\n        &#125; else &#123;\n            if (find(x)) &#123;\n                puts(&quot;Yes&quot;);\n            &#125; else &#123;\n                puts(&quot;No&quot;);\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n缺点：消耗空间\n开放地址法 Open Addressing思路：只用一个一维数组来模拟哈希表，因此形式会相对简洁，但是一般来说一维数组的长度应该是需要的数组大小的2~3倍，\n类似数组模拟链表的方式，将数据存储在空余空间中，想象上厕所，一个坑位完了就下一个\n探测方法：\n\n线性探测\n\n缺点：费时间，元素容易聚集，分布不均匀，聚集越多性能越差\n\n平方探测\n\n避免了元素的聚集，如果顺序表长度为指数，顺序表空位多于一半，平方探测总能插入新元素\n\n伪随机探测\n\n代码\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了\nconst int N = 2e5 + 3;        //大于数据范围的第一个质数\nconst int null = 0x3f3f3f3f;  //规定空指针为 null 0x3f3f3f3f\n//这个数只要不在原本数据范围内就行\n\nint h[N];\n\nint find(int x) &#123;//这一个函数同时实现查找和插入功能\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x) &#123;\n        t++;//这一步是线性探测，可以使用平方或者伪随机优化\n        if (t == N) &#123;//如果到头了，就返回从头找\n            t = 0;\n        &#125;\n    &#125;\n    return t;  //如果这个位置是空的, 则返回的是他应该存储的位置\n&#125;\n\nint n;\n\nint main() &#123;\n    cin &gt;&gt; n;\n\n    memset(h, 0x3f, sizeof h);  //规定空指针为 0x3f3f3f3f\n\n    while (n--) &#123;\n        string op;\n        int x;\n        cin &gt;&gt; op &gt;&gt; x;\n        if (op == &quot;I&quot;) &#123;\n            h[find(x)] = x;//妙啊\n        &#125; else &#123;\n            if (h[find(x)] == null) &#123;\n                puts(&quot;No&quot;);\n            &#125; else &#123;\n                puts(&quot;Yes&quot;);\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n杜鹃哈希😎感觉：拆东墙补西墙，但是很牛逼\n优点：只要两个表中间有元素，一定可以通过哈希函数在顺序表中直接找到不用探测，非常高效\n原因：所有索引位置都是哈希函数得到\n失败时：\n没有足够空间，路径无限循环\n转移链表过长\n\n缺点：元素过多时候插入元素困难\n(101条消息) 杜鹃散列_EmberWn的博客-CSDN博客_杜鹃散列\n【散列】杜鹃散列详情与C++实现代码 - awst_lee - 博客园 (cnblogs.com)\nCuckoo hash算法分析 - 可酷可乐 - 博客园 (cnblogs.com)\nCuckoo hashing - Wikipedia（科学上网看）\n杜鹃哈希举例：\n坏消息：根本看不懂\n好消息：不用看了\n//为杜鹃散列生成泛型HashFamily接口,用来发出多簇散列函数到杜鹃散列表\ntemplate&lt;typename AnyType&gt;\nclass CuckooHashFamily &#123;\npublic:\n    size_t hash(const AnyType&amp; x, int which)const;\n    int getNumberOfFunctions();\n    void generateNewFunctions();\n&#125;;\n \n/**\n* 杜鹃散列法的非正式字符串散列\n*/\ntemplate&lt;int count&gt;\nclass StringHashFamily &#123;\nprivate:\n    std::vector&lt;int&gt; MULTIPLIERS;\n    UniformRandom r;\n \npublic:\n    StringHashFamily() :MULTIPLIERS(count) &#123;\n        generateNewFuntions();\n    &#125;\n    int getNumberOfFunctions()const &#123;\n        return count;\n    &#125;\n    void generateNewFuntions() &#123;\n        for (auto&amp; mult : MULTIPLIERS)\n            mult = r.nextInt();\n    &#125;\n \n    size_t hash(const string&amp; x, int which)const &#123;\n        const int multiplier = MULTIPLIERS[which];\n        size_t hashVal = 0;\n        for (auto ch : x)\n            hashVal = multiplier * hashVal + ch;\n        return hashVal;\n    &#125;\n&#125;;\n \n//杜鹃散列类接口，允许(由HashFamily模板参数类型指定)任意个数的散列函数\ntemplate&lt;typename AnyType, typename HashFamily&gt;\nclass HashTable &#123;\nprivate:\n    struct HashEntry &#123;\n        AnyType element;\n        bool isActive;\n \n        HashEntry(const AnyType&amp;e=AnyType(),bool a=false)\n            :element&#123;e&#125;,isActive&#123;a&#125;&#123;&#125;\n        HashEntry(AnyType&amp;&amp;e,bool a=false)\n            :element&#123;std::move(e)&#125;,isActive&#123;a&#125;&#123;&#125;\n    &#125;;\n \n    /**\n    * 杜鹃散列的插入例程使用不同的算法，\n    * 该算法随机选择要逐出的项，\n    * 但不再试图重新逐出最后的项。\n    * 如果存在太多的逐出项则散列表将尝试选取新的散列函数(再散列)，\n    * 而若有太多的再散列则散列表将扩张\n    */\n    bool insertHelper1(const AnyType&amp; xx) &#123;\n        const int COUNT_LIMIT = 100;\n        AnyType x = xx;\n \n        while (true) &#123;\n            int lastPos = -1;\n            int pos;\n \n            for (int count = 0; count &lt; COUNT_LIMIT; ++count) &#123;\n                for (int i = 0; i &lt; numHashFunctions; ++i)\n                    pos = myhash(x, i);\n                    \n                if (!isActive(pos)) &#123;\n                    array[pos] = std::move(HashEntry&#123; std::move(x),true &#125;);\n                    ++currentSize;\n                    return true;\n                &#125;\n            &#125;\n \n            //无可用位置，逐出一个随机项\n            int i = 0;\n            do &#123;\n                pos = myhash(x, r.nextInt(numHashFunctions));\n            &#125; while (pos == lastPos &amp;&amp; i++ &lt; 5);\n \n            lastPos = pos;\n            std::swap(x, array[pos].element);\n        &#125;\n \n        if (++rehashes &gt; ALLOWED_REHASHES) &#123;\n            expand();\t\t//使散列表扩大\n            rehashes = 0;\t//重置rehashes的计数\n        &#125;\n        else\n            rehash();\t\t//表大小相同，散列函数都是新的\n    &#125;\n    bool insertHelper1(AnyType&amp;&amp; x) &#123;\n        const int COUNT_LIMIT = 100;\n \n        while (true) &#123;\n            int lastPos = -1;\n            int pos;\n \n            for (int count = 0; count &lt; COUNT_LIMIT; ++count) &#123;\n                for (int i = 0; i &lt; numHashFunctions; ++i)\n                    pos = myhash(x, i);\n \n                if (!isActive(pos)) &#123;\n                    array[pos] = std::move(HashEntry&#123; std::move(x),true &#125;);\n                    ++currentSize;\n                    return true;\n                &#125;\n            &#125;\n \n            //无可用位置，逐出一个随机项\n            int i = 0;\n            do &#123;\n                pos = myhash(x, r.nextInt(numHashFunctions));\n            &#125; while (pos == lastPos &amp;&amp; i++ &lt; 5);\n \n            lastPos = pos;\n            std::swap(x, array[pos].element);\n        &#125;\n \n        if (++rehashes &gt; ALLOWED_REHASHES) &#123;\n            expand();\t\t//使散列表扩大\n            rehashes = 0;\t//重置rehashes的计数\n        &#125;\n        else\n            rehash();\t\t//表大小相同，散列函数都是新的\n    &#125;\n    bool isActive(int currentPos)const &#123;\n        return currentPos != -1 &amp;&amp; array[currentPos].isActive;\n    &#125;\n \n    /**\n    * 使用特定函数计算x的散列代码\n    * 选取适当的散列函数，然后把它换算成合法的数组下标\n    */\n    size_t myhash(const AnyType&amp; x, int which)const &#123;\n        return hashFunctions.hash(x, which) % array.size();\n    &#125;\n \n    /**\n    * 查找所有散列函数的位置\n    * 返回查阅所有的散列函数以返回包含项x的下标，若找不到则返回-1\n    */\n    int findPos(const AnyType&amp; x)const &#123;\n        for (int i = 0; i &lt; numHashFunctions; ++i) &#123;\n            int pos = myhash(x, i);\n \n            if (isActive(pos) &amp;&amp; array[pos].element == x)\n                return pos;\n        &#125;\n        return -1;\n    &#125;\n \n    /**\n    * 创建一个大数组但使用那些相同的散列函数\n    */\n    void expand() &#123;\n        rehash(static_cast&lt;int&gt;(array.size() / MAX_LOAD));\n    &#125;\n \n    /**\n    * 保留数组的大小不变，创建一个新的数组\n    * 该数组使用那些新选出的散列函数填充\n    */\n    void rehash() &#123;\n        hashFunctions.generateNewFuntions();\n        rehash(array.size());\n    &#125;\n \n    void rehash(int newSize) &#123;\n        std::vector&lt;HashEntry&gt; oldArray = array;\n \n        //创建新的双倍大小的空散列表\n        array.resize(nextPrime(newSize));\n        for (auto&amp; entry : array)\n            entry.isActive = false;\n \n        //复制整个表\n        currentSize = 0;\n        for (auto&amp; entry : oldArray)\n            if (entry.isActive)\n                insert(std::move(entry.element));\n    &#125;\n \n    constexpr static const double MAX_LOAD=0.4; //最大装填因子\n    static const int ALLOWED_REHASHES = 5; //最大散列次数\n \n    vector&lt;HashEntry&gt;array;\n    int currentSize;\n    int numHashFunctions;\n    int rehashes;\n    UniformRandom r;\n    HashFamily hashFunctions;\n \npublic:\n    explicit HashTable(int size = 101) :array(nextPrime(size)) &#123;\n        numHashFunctions = hashFunctions.getNumberOfFunctions();\n        rehashes = 0;\n        makeEmpty();\n    &#125;\n \n    //清空杜鹃散列表\n    void makeEmpty() &#123;\n        currentSize = 0;\n        for (auto&amp; entry : array)\n            entry.isActive = false;\n    &#125;\n \n    /**\n    * 搜索杜鹃散列表的例程\n    * 如果找到x则返回true\n    */\n    bool contains(const AnyType&amp; x)const &#123;\n        return findPos(x) != -1;\n    &#125;\n \n    /**\n    * 从散列表中删除x\n    * 若项x被找到且被删除则返回true\n    */\n    bool remove(const AnyType&amp; x) &#123;\n        int currentPos = findPos(x);\n        if (!isActive(currentPos))\n            return false;\n \n        array[currentPos].isActive = false;\n        --currentSize;\n        return true;\n    &#125;\n \n    //杜鹃散列表中公有插入方法\n    bool insert(const AnyType&amp; x) &#123;\n        if (contains(x))\n            return false;\n \n        if (currentSize &gt;= array.size() * MAX_LOAD)\n            expand(); \n \n        return insertHelper1(x);\n    &#125;\n    bool insert(AnyType&amp;&amp; x) &#123;\n        if (contains(x))\n            return false;\n \n        if (currentSize &gt;= array.size() * MAX_LOAD)\n            expand(); \n \n        return insertHelper1(std::move(x));\n    &#125;\n \n    int size() const\n    &#123;\n        return currentSize;\n    &#125;\n \n    int capacity() const\n    &#123;\n        return array.size();\n    &#125;\n&#125;;\n\n树最后通过看大神的代码才恍然大悟，二叉树的建立，需要按照一棵满二叉树来建立\n问题来了，我们的节点不够满二叉树的，这就是关键，空节点也需要补上！\n使用数组构造一棵二叉树也是同理！\n完全二叉树的构建（0作为空节点，会有空间浪费）#include&lt;iostream&gt;\nusing namespace std;\nconst int M=1010;//完全二叉树\nint tree[M]=&#123;0&#125;;//全部初始化成0方便判断\nint judge=1;//判断是否继续读入\nint real_depth(int n)\n&#123;\n    int ans=0;\n    while(n!=0)\n    &#123;\n        ans++;\n        n=n/2;\n    &#125;\n    return ans;\n&#125;\nvoid DLR(int i)//\n&#123;\n    if(tree[i]!=0)\n    &#123;\n        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;\n        DLR(i*2);\n        DLR(i*2+1);\n    &#125;\n&#125;\nvoid LDR(int i)//中序遍历\n&#123;\n    if(tree[i]!=0)\n    &#123;\n        \n        DLR(i*2);\n        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;\n        DLR(i*2+1);\n    &#125;\n&#125;\nvoid LRD(int i)//后序遍历\n&#123;\n    if(tree[i]!=0)\n    &#123;\n\n        DLR(i*2);\n        DLR(i*2+1);\n        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;\n    &#125;\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    int node_num=1;\n    for(int j=0;j&lt;n;j++ )//计数是第几组\n    &#123;\n\n        int node;\n        cin&gt;&gt;node;\n        tree[1]=node;\n        int i=1;\n        if(node==0||node==-1)continue;\n        while(judge==1)\n        &#123;\n            cin&gt;&gt; node;\n            //cout&lt;&lt;&quot;node:  &quot;&lt;&lt;node&lt;&lt;endl;\n            ++i;\n            //cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;endl;\n            if(node==-1)//实现了深度搞定，接下来是前序遍历\n            &#123;\n                cout&lt;&lt;real_depth(i-1) &lt;&lt;&quot; &quot;;\n                break;\n            &#125;\n            else\n            &#123;\n                if(tree[i/2]!=0)\n                &#123;\n                    tree[i]=node;\n                &#125;\n                if(tree[i/2]==0)\n                &#123;\n                    while(tree[i/2]==0)i=i/2;//回退到上层节点是有数字\n                    i=i/2;\n                    //cout&lt;&lt;&quot;back: &quot;&lt;&lt;i&lt;&lt;endl;\n                    while(tree[i*2])i=i*2;\n                    i=i*2;\n                    //cout&lt;&lt;&quot;go: &quot;&lt;&lt;i&lt;&lt;endl;\n                    tree[i]=node;\n                &#125;\n            &#125;\n            node_num=i;\n        &#125;\n        DLR(1);//完全二叉树记得要从节点1开始，也就是初始的节点\n       cout&lt;&lt;endl;\n       for(int i=1;i&lt;=node_num;i++)\n       &#123;\n           tree[i]=0;//清零\n       &#125;\n    &#125;\n&#125;\n\n树的恢复(105条消息) 先序遍历中序遍历还原二叉树_May Hacker的博客-CSDN博客_先序遍历中序遍历还原树\n由先序和中序恢复二叉树理论基础：\n105. 从前序与中序遍历序列构造二叉树 - 力扣（Leetcode）\n背也要背会的模板:[(105条消息) 根据先序中序还原二叉树_BugMaker-shen的博客-CSDN博客_由先序和中序恢复二叉树](https://blog.csdn.net/qq_42500831/article/details/105984986?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=先序 + 中序 恢复二叉树&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-0-105984986.142^v63^control,201^v3^control_1,213^v2^t3_control1&amp;spm&#x3D;1018.2226.3001.4187)\n原理：使用递归\n\n\n🙏🙏🙏🙏🙏🙏🙏🙏🙏感谢这位西电的朋友助我脱离苦海，感谢感谢\n可以直接用那种：😭😭😭😭（数据结构放假是机考！机考！机考！我giao！！！）\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nstruct Node&#123;\n    char data;\n    Node* left;\n    Node* right;\n    Node(char data)&#123;\n        this-&gt;data = data;\n        this-&gt;left = nullptr;\n        this-&gt;right = nullptr;\n    &#125;\n&#125;;\n\nvector&lt;char&gt; getCharArray(string str)&#123;\n    //这一步就是为了利用vector有现成的构造函数，能省很多步骤\n    vector&lt;char&gt; res;\n    for(char c : str)&#123;\n        //\n        /*\n        这里的for(char c:str)就是定义一个遍历字符c，让它分别等于字符串数组str里面的各个字符，然后执行下面的语句，当c被赋值为str里面所有字符各一次后，就会退出这个循环。\n\n这相当于JAVA的强for循环的语法结构。相当于C++的：\nfor( int i = 0; i &lt; s.length(); i++)\n&#123; s[i]…\n&#125;\n        */\n        res.push_back(c);\n    &#125;\n    return res;\n&#125;\n\nNode* getTree(vector&lt;char&gt;&amp; preOrder, vector&lt;char&gt;&amp; inOrder)&#123;\n    if(preOrder.empty())&#123;\n        return nullptr;\n    &#125;\n    Node* root = new Node(preOrder[0]);\n    //构造根结点，并且将root指针指向前序的第一个节点，即总根节点\n    vector&lt;char&gt;::iterator mid = find(inOrder.begin(), inOrder.end(), preOrder[0]);//遍历一次找到前序在\n    int left_nodes = mid - inOrder.begin();//接下来进行分区处理\n    vector&lt;char&gt; left_inOrder(inOrder.begin(), mid);//中序的左子树\n    //这里直接用了vector的构造，将inOrder赋值过去，最后一个mid不会复制\n    vector&lt;char&gt; right_inOrder(mid+1, inOrder.end());//中序的右子树\n    vector&lt;char&gt; left_preOrder(preOrder.begin()+1, preOrder.begin()+1+left_nodes);//前序的左子树，就省去根节点了\n    vector&lt;char&gt; right_preOrder(preOrder.begin()+1+left_nodes, preOrder.end());//前序右子树\n    root-&gt;left = getTree(left_preOrder, left_inOrder);//新树的左子树\n    root-&gt;right = getTree(right_preOrder, right_inOrder);//新树右子树\n    return root;//返回一个节点指针\n&#125;\n\nvoid postOrder(Node* root)&#123;//后续遍历\n    if(root == nullptr)&#123;\n        return ;\n    &#125;\n    postOrder(root-&gt;left);\n    postOrder(root-&gt;right);\n    cout&lt;&lt;root-&gt;data;\n&#125;\n\nint main()&#123;\n    string pre_str;\n    string in_str;\n    while(cin &gt;&gt; pre_str &gt;&gt; in_str)&#123;\n        vector&lt;char&gt; preOrder = getCharArray(pre_str);//string转换成vector向量形式\n        vector&lt;char&gt; inOrder = getCharArray(in_str);//\n        Node* root = getTree(preOrder, inOrder);\n        postOrder(root);\n        cout&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n\nLeetCode解法：\nclass Solution &#123;\nprivate:\n        TreeNode* traversal (vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd, vector&lt;int&gt;&amp; preorder, int preorderBegin, int preorderEnd) &#123;\n        if (preorderBegin == preorderEnd) return NULL;\n\n        int rootValue = preorder[preorderBegin]; // 注意用preorderBegin 不要用0\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (preorderEnd - preorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;\n            if (inorder[delimiterIndex] == rootValue) break;\n        &#125;\n        // 切割中序数组\n        // 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        // 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        // 切割前序数组\n        // 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)\n        int leftPreorderBegin =  preorderBegin + 1;\n        int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 终止位置是起始位置加上中序左区间的大小size\n        // 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)\n        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);\n        int rightPreorderEnd = preorderEnd;\n\n        cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;leftInorder :&quot;;\n        for (int i = leftInorderBegin; i &lt; leftInorderEnd; i++) &#123;\n            cout &lt;&lt; inorder[i] &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n\n        cout &lt;&lt; &quot;rightInorder :&quot;;\n        for (int i = rightInorderBegin; i &lt; rightInorderEnd; i++) &#123;\n            cout &lt;&lt; inorder[i] &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n\n        cout &lt;&lt; &quot;leftPreorder :&quot;;\n        for (int i = leftPreorderBegin; i &lt; leftPreorderEnd; i++) &#123;\n            cout &lt;&lt; preorder[i] &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n\n        cout &lt;&lt; &quot;rightPreorder :&quot;;\n        for (int i = rightPreorderBegin; i &lt; rightPreorderEnd; i++) &#123;\n            cout &lt;&lt; preorder[i] &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n\n\n        root-&gt;left = traversal(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);\n        root-&gt;right = traversal(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);\n\n        return root;\n    &#125;\n\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;\n        if (inorder.size() == 0 || preorder.size() == 0) return NULL;\n        return traversal(inorder, 0, inorder.size(), preorder, 0, preorder.size());\n\n    &#125;\n&#125;;\n\n并查集——面试涉及——竞赛频率也高😍面试官一般都习惯去问一些代码短但是思路精巧的（便于手写代码）\n提前学习知识：链表，线性表\n全名：归并查找集合，即判断两个元素是否属于同一个集合\n836. 合并集合 - AcWing题库\n可选方法：\n\n建两个哈希表分别找\n建两个跳表分别找\n\n在集合经常动态变化时候，查找方法效率并不高\n并查集应用：快速处理下列问题：\n\n将两个集合合并\n询问两个元素是否属于同一个集合中\n\n并查集能在近乎O（1）的时间复杂度之内快速支持以上两种操作\n正常：合并元素方式，至少需要对线性表&#x2F;链表整个进行一次遍历，耗时高\n基本原理：每一个集合使用一棵树来维护（不一定是二叉树，可能是三叉树，B+树等），每一个集合的编号就是根节点的编号，树中对于每一个点都存储其父节点（用p[x]表示x的父节点），在求某个元素是否属于某一个集合的时候，就在该元素向上遍历，知道到达根节点，最后判断根节点的编号是否是所需编号\n解决问题与流程：\n\n如何判断树根，\nif(p[x]==x)//对于树根编号等于自身\n\n\n如何求x的集合编号:\nwhile(p[x]!=x)x=p[x]//多么熟悉的链表的遍历操作，因此是链表实现\n    //这一步实际上的时间复杂度会高，因为还是会向上进行一个遍历，时间和树的高度有关，因此树最好高度越低越好\n\n\n如何合并两个集合：加一条边，将一个树插入到另一棵树身上就可以\n\n\n//假设p[x]是x集合编号，p[y]是y的集合编号，那么只需要\np[x]=y\n\n\n\n写法：int find(int x)//核心的函数\n    //加上路径压缩，会自动找到根节点\n&#123;\n    //if(p[x]!=x)x=p[x];\n    if(p[x]!=x)p[x]=find(p[x]);\n    //易错：p[x]=find(p[x])这里要更新的\n    //易错：这里是if不能是循环while\n    \n    \n    /*\n    上面两句分别是普通版本和加过路径优化的版本\n    第一个就是普通循环进行查找\n    第二局是调用递归，每一次在寻找的时候都会对当前的节点进行更新，初次执行会慢，之后速度会飞升\n    */\n    return p[x];//最后返回一个根节点\n&#125;\nvoid merge(int x,int y)\n&#123;\n        p[x]=y;//核心函数二：合并     \n&#125;\n\n全代码：\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nconst int N=100010;\nint p[N];//定义多个集合\n\nint find(int x)\n&#123;\n    if(p[x]!=x) p[x]=find(p[x]);\n    /*\n    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:\n    p[x]=x;\n    */\n    return p[x];\n    //找到了便返回祖宗节点的值\n&#125;\nvoid merge(int x ,int y)//这里是把x的头并到y了\n&#123;\n    p[find(x)]=find(y);//这里进行操作使用上一步的find函数\n&#125;\n\nint main()\n&#123;\n    int n,m;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;i++) p[i]=i;\n    while(m--)\n    &#123;\n        char op[2];\n        int a,b;\n        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);\n        if(*op==&#39;M&#39;) merge(a,b);//集合合并操作\n        else\n        if(find(a)==find(b))\n        //如果祖宗节点一样,就输出yes\n        printf(&quot;Yes\\n&quot;);\n        else\n        printf(&quot;No\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n\n并查集优化：路径压缩并查集最牛逼的优化方式，另一种优化基本写代码时候不会使用\n原理：一旦在向上走的时候找到了根节点，将该路径所有节点都指向根节点，即只需要搜索一次，之后的重复操作速度就会提高，可以视为O（1）优化\n优化：加权合并防止树越来越高\n记录每棵树元素的个数作为树的权重\n堆：完全二叉树的操作应用：\n\n构造优先队列\n\n（不用stl）手搓一个堆，堆的基本\n\n插入一个数\n求这个集合当中的最小值\n删除最小值\n删除任意一个元素（stl无法直接实现）\n修改任意一个元素（stl无法直接实现）\n\n堆的基本结构：堆属于一棵完全二叉树（指除了最后一排其他都是均匀分布，即所有节点都不是非空），最后一层节点从左到右依次排列\n小根堆的性质：每一个点都是小于等于左右儿子（即递归定义），则根节点就是最小值\n大根堆：相反\n凡是完全二叉树都是用一维数组存储的\n1号点是根节点\nx的左儿子下标：2x,\nx的右儿子下标：2x+1\nstl里面的堆就是优先队列\n特点：\n\n时间复杂度非常稳定，不依赖原始记录状态\t \n是一种不稳定的排序方法（记录比较与交换跳跃进行）\n\n基本函数：down(x)：如果某一个点的值变大，就将该值向下压\nup(x)：如果一个点的值变小，向上升\n两个函数的执行次数都和二叉树的深度成正比，也就是logn\n这里的x实际上是所处的位置\n由基本函数构成堆的几种操作：\n\n插入一个数\n\nheap[++size]=x;//这一步将堆数组的最后再一个换成需要的数\nup(size);\n\n\n求最小值\n\nheap[1];//是小根堆，则就最上面的就是最小的\n\n\n删除最小值(也就是最顶部的根节点的删除)\n\n思路：用堆底部的最后一个元素覆盖掉第一个元素，然后进行down（1)\n原理：存储结构是一个一维数组，删除尾部节点很容易（直接size–就行），但删除头部却很麻烦\n覆盖掉之后再使用向下函数down会让顶部元素下沉到正确位置\nheap[1]=heap[size];\nsize--;\ndown(1);\n\n\n删除任意一个元素,和删除头部不太一样在于不确定改变值之后是大还是小\n\n简单粗暴好使的办法：管他呢，down一次，up一次，因为up和down实际上只会执行一次\nheap[k]=heap[size];\nsize--;//\ndown(k);\nup(k);\n\n\n修改任意一个元素的值：同删除一个元素的操作\n\nheap[k]=x;\ndown(k);\nup(k);\n\n构建小细节：不同于其它的一般采用下标从0开始，对于树形结构，因为树的性质有左儿子&#x3D;根&#x2F;2，如果从0开始左儿子也是0，不方便，因此堆排序实际上是从1开始\n开始构建：构建堆可以用插入的方式操作，但每一次插入都是logn，实际上不好\n有时间复杂度为on的方式\nfor(int i=size/2,i&gt;0;i--)down(i);\n\n构建up妙啊（发出抱大佬大腿的声音）😍\nvoid up(int u)\n&#123;\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//不管u是左右儿子，都不重要，直接/2指向的双亲都是同一个\n    &#123;\n        swap(u, u / 2);\n        u &gt;&gt;= 1;//u变成原先的二分之一\n    &#125;\n&#125;\n\n构建downvoid down(int u)\n&#123;\n    int t=u;\n    if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小\n    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;=h[t])t=u*2+1;//判断右儿子和大小\n    //最后t存的就是根，左右儿子三者之中最小的值下标\n    if(u!=t)//不等，说明有可能还要继续递归进行对比\n    &#123;\n        swap(h[u],h[t]);\n        down(t);//递归向下继续弄\n    &#125;\n    \n&#125;\n\n模拟堆难点：支持随机的修改和删除,题中要求是第i个，但是i对应的下标会随着操作变化下标跟着变化，需要实时更新。因此映射也要交换好\n解法：使用映射,老牛逼了\n\n\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n// ph[k]存储第k个插入的点在堆中的位置\n// hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n//ph从左到右，hp从右到左、\n//交换数的时候，指针也要交换\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)//针对这一道题开发的映射关系转换\n&#123;\n    swap(ph[hp[a]],ph[hp[b]]);//指针交换\n    swap(hp[a], hp[b]);//逆指针交换\n    swap(h[a], h[b]);//数值交换\n&#125;\n\nvoid down(int u)\n&#123;\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)\n    &#123;\n        heap_swap(u, t);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int u)\n&#123;\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])\n    &#123;\n        heap_swap(u, u / 2);\n        u &gt;&gt;= 1;\n    &#125;\n&#125;\n\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);\n\n解题技巧：当题中有明确给出第i个操作数，要考虑如何通过更新操作数的下标\n\n\n堆排序：onlogn一般升序使用大顶堆，降序采用小顶堆\n举例：对数组进行从小到大排序，输出前m小的数\n思路：本题可以使用堆排序，构造小顶堆，然后输出堆顶，输出后把堆顶和堆尾交换。尾部边界缩小，重复执行m次即可。\n注意点：\n\n和完全二叉树一样下标从1开始\n\n代码：易错点：\n模拟堆（直接造小根堆）#include &lt;iostream&gt;\nusing namespace  std;\nconst int M=100100;\nint h[M];\nint size;\nvoid big_down(int u)//最后大的会向下走\n&#123;\n    int t=u;\n    if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小\n    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;=h[t])t=u*2+1;//判断右儿子和大小\n    //最后t存的就是根，左右儿子三者之中最小的值下标\n    if(u!=t)//不等，说明有可能还要继续递归进行对比\n    &#123;\n        swap(h[u],h[t]);\n        big_down(t);//递归向下继续弄\n    &#125;\n&#125;\nvoid small_down(int u)//最后小的会向下走\n&#123;\n    int t=u;\n    if(u*2&lt;=size&amp;&amp;h[u*2]&gt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小\n    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&gt;=h[t])t=u*2+1;//判断右儿子和大小\n    //最后t存的就是根，左右儿子三者之中最小的值下标\n    if(u!=t)//不等，说明有可能还要继续递归进行对比\n    &#123;\n        swap(h[u],h[t]);\n        small_down(t);//递归向下继续弄\n        注意这里向下的还是t\n    &#125;\n&#125;\nint main()\n&#123;\n\n    cin&gt;&gt;size;\n    for(int i=1;i&lt;=size;i++)//二叉树的读入范围\n    &#123;\n        cin&gt;&gt;h[i];\n    &#125;\n    for (int i = size / 2; i; i -- ) small_down(i);\n    for(int i=1;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;&#39; &#39;;\n    cout&lt;&lt;endl;\n    for (int i = size / 2; i; i -- ) big_down(i);\n    for(int i=1;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;&#39; &#39;;\n    cout&lt;&lt;endl;\n\n    return 0;\n&#125;\n\n堆排序（整体）#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint a[N];//保存数组\nint n, m;//n个点，求前m小\nint r ;//堆的右边界\nvoid down(int u)//调整函数\n&#123;\n    //t记录最小点的编号\n    int t = u;\n\n易错部分：这里前面都是u最后对比是t，修改大小也是修改u\n    if(2 * u &lt;= r &amp;&amp; a[2 * u] &lt; a[t]) t = 2 * u;\n\n    if(2 * u + 1 &lt;= r &amp;&amp; a[2 * u + 1] &lt; a[t]) t = 2 * u + 1;\n\n    //如果待调整点不是最小的\n    if(u != t)\n    &#123;\n        //和最小的交换\n        swap(a[u], a[t]);\n\n        //递归处理\n        down(t);\n    &#125;\n&#125;\n\n\n因为堆是一棵二叉树构建起来的，因此是从1\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    r = n;//开始时，右边界是数组边界\n\n    //读入数据\n    for (int i = 1; i &lt;= n; i ++ )\n    &#123;\n        int x;\n        cin &gt;&gt; a[i];\n    &#125;\n\n    //从第一个非叶节点开始，从右到左，从下到上处理每个节点\n   for(int i = n /2 ; i ; i--)//创建小根堆\n   &#123;\n       //注意问题在于它小得没有规律\n       down(i);//因为叶子节点没办法继续向下了，因此从叶子向上一层开始操作\n   &#125;\n\n    //输出m个最小值\n    while (m -- )\n    &#123;\n        //堆顶保存的最小值，输出堆顶\n        cout &lt;&lt; a[1] &lt;&lt; &quot; &quot;;\n\n        //将堆顶和右边界交换\n        swap(a[1], a[r]);\n\n        //右边界左移\n        r--;\n\n        //从新处理堆顶\n        down(1);\n    &#125;\n&#125;\n\n哈夫曼树下面这个关于编码的，很重要\n(108条消息) 【数据结构——哈夫曼树及其应用】_FEI..的博客-CSDN博客_哈夫曼树的parent怎么求\n哈夫曼编码:字母核心：无前缀编码，从根节点到叶子节点的路径代表编码，只要字母在叶子节点，对应编码就是无前缀\n贪心算法\n从底向上建立一棵无前缀编码树\n频次低的树在最下面\n\n自己写的代码(输入字符串进行编码并输出)：#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\ntypedef struct\n&#123;\n    int weight;//结点的权值\n    int parent, lchild, rchild;//双亲、左孩子、右孩子的下标\n&#125;HTnode,*HuffmanTree;\nvoid Select(HuffmanTree&amp; HT,int &amp;s1,int &amp;s2,int n)\n&#123;\n    s2=1,s1=2;//两个过大的数进行比对\n    for (int i = 1;i &lt;= n;++s1)//在1到n之间的点进行寻找\n    &#123;\n        if(HT[s1].parent==0&amp;&amp;HT[s2].parent==0)//当\n        &#123;\n            break;\n        &#125;\n        if(HT[s1].parent==0)//当\n        &#123;\n            s2=s1;\n        &#125;\n        if(s2==s1)++s1;\n    &#125;\n    for (int i = 1;i &lt;= n;++i)//在1到n之间的点进行寻找\n    &#123;\n        if(HT[i].weight&lt;=HT[s1].weight&amp;&amp;HT[i].parent==0)//当\n        &#123;\n            s1=i;//连着更新两次，s1是最小的，s2是次小的\n        &#125;\n    &#125;\n    for (int i = 1;i &lt;= n;++i)//在1到n之间的点进行寻找\n    &#123;\n        if(HT[i].weight&lt;=HT[s2].weight&amp;&amp;HT[i].parent==0&amp;&amp;i!=s1)//当\n        &#123;\n            s2=i;\n        &#125;\n    &#125;\n&#125;\nvoid CreateHuffmanTree(HuffmanTree&amp; HT, int n,int word[])//构造哈夫曼树，n为带权值的叶子结点个数\n&#123;\n    //使用了以获取的word数组存取已有的数量\n    /*初始化*/\n    int s1,s2;\n    if (n &lt;= 1)\n        return;\n    int m = 2 * n - 1;//m为哈夫曼树中总结点的个数\n    HT = new HTnode[m + 1];//0号单元未用，所以需要开辟m+1个单元，HT[m]表示根结点\n    for (int i = 1;i &lt;= m;++i)//将1-m号单元的双亲，左右孩子的下标都初始化为0\n    &#123;\n        HT[i].parent = 0;\n        HT[i].lchild = 0;\n        HT[i].rchild = 0;\n    &#125;\n    int word_select=0;\n    for (int i = 1;i &lt;= n;++i)\n    &#123;\n        for(;word[word_select]==0;word_select++);\n//        cout&lt;&lt;(char)word_select &lt;&lt;&quot; word=&quot;&lt;&lt;word[word_select]&lt;&lt;endl;\n        HT[i].weight=word[word_select];//输入前n个单元中叶子结点的权值\n//        cout&lt;&lt;i&lt;&lt;&quot;个单元叶子节点的权值： &quot;&lt;&lt;HT[i].weight&lt;&lt;endl;\n//这一句是输入测试，ok了\n        word_select++;//到下一个防止连续搞\n    &#125;//到这一步都没问题，叶子节点权值都录入了\n    /*初始化工作结束，下面开始创建哈夫曼树*/\n//    cout&lt;&lt;&quot;n=:&quot;&lt;&lt;n&lt;&lt;endl;\n    for (int i = n + 1;i &lt;= m;++i)\n    &#123;//通过n-1次的选择、删除、合并来创建哈夫曼树\n        Select(HT,  s1, s2,n);//选择两个其双亲域为0且权值最小的结点\n//        cout&lt;&lt;i-15&lt;&lt;&quot;次操作之后 &quot; &lt;&lt;&quot;s1 now=&quot;&lt;&lt;s1&lt;&lt;&quot; HT[s1].weight=&quot;&lt;&lt;HT[s1].weight;\n//        cout&lt;&lt;&quot;  s2 now =&quot;&lt;&lt;s2&lt;&lt;&quot; HT[s2].weight=&quot;&lt;&lt;HT[s2].weight&lt;&lt;endl;\n        HT[s1].parent = i;HT[s2].parent = i;//得到新结点i,将s1\\s2的双亲域由0改为i\n        HT[i].lchild = s1;HT[i].rchild = s2;//s1、s2分别作为i的左右孩子\n        HT[i].weight = HT[s1].weight + HT[s2].weight;//i的权值为左右孩子的权值之和\n//        cout&lt;&lt;&quot;  HT now =&quot;&lt;&lt;i&lt;&lt;&quot; HT[i].weight=&quot;&lt;&lt;HT[i].weight&lt;&lt;endl;\n    &#125;\n&#125;\ntypedef char** HuffmanCode;\n////动态分配数组存储哈夫曼编码表\nvoid CreatHuffmanCode(HuffmanTree HT, HuffmanCode&amp; HC, int n)//完全没有开始写的\n&#123;//从叶子到根逆向求每个字符的哈夫曼编码，储存在编码表HC中\n    HC = new char* [n + 1];//分配n个字符编码的头指针矢量\n     char *cd = new char[n];//分配临时存放编码的动态数组空间\n     int start;\n     int c;\n     int f;\n    cd[n - 1] = &#39;\\0&#39;;//编码结束符\n    for (int i = 1;i &lt;= n;++i)//逐个字符求哈夫曼编码\n    &#123;\n        start = n - 1;//start开始时指向最后，即编码结束符的位置\n        c = i;f = HT[i].parent;//f指向结点c的双亲结点\n        while (f != 0)//从叶子结点开始向上回溯，直到根结点\n        &#123;\n            --start;//回溯一次，start向前指一个位置\n            if (HT[f].lchild == c)\n                cd[start] = &#39;0&#39;;//结点c是f的左孩子，则生成代码0\n            else\n                cd[start] = &#39;1&#39;;//结点c是f的右孩子，则生成代码1\n            c = f;f = HT[f].parent;//继续向上回溯\n        &#125;//求出第i个字符的编码\n        HC[i] = new char[n - start];//为敌i个字符编码分配空间\n        strcpy(HC[i], &amp;cd[start]);//将求得的编码从临时空间cd复制到HC当前行中\n    &#125;\n    delete cd;//释放临时空间\n&#125;\nchar out[128]=&#123;&#39;\\0&#39;&#125;;\nint word[128]=&#123;0&#125;;//作为字母\nint main() &#123;\n    string ans=&quot;&quot;;\n    string temp;\n    while (getline(cin, temp)) &#123;\n        if (temp == &quot;0&quot;) &#123;\n            break;\n        &#125;\n        ans+=temp;\n    &#125;//读入阶段\n    int length=ans.size();\n    for(int i=0;i&lt;length;i++)\n    &#123;\n        int idx=(int)(ans[i]);\n        word[idx]++;\n    &#125;\n    int node_num=0;\n    for(int i=1;i&lt;=128;i++)\n    &#123;\n        if(word[i]!=0)\n        &#123;\n            ++node_num;\n            out[node_num]=(char)i;\n//            cout &lt;&lt;(char)i &lt;&lt; &quot;: &quot;&lt;&lt; word[i] &lt;&lt; endl;\n            //这里获得了对应的编码\n        &#125;\n    &#125;\n    HuffmanTree HT;\n    CreateHuffmanTree(HT,node_num,word);\n    HuffmanCode HC;\n    CreatHuffmanCode(HT,HC,node_num);\n    for(int i=1;i&lt;=node_num;i++)\n    &#123;\n        cout&lt;&lt;out[i]&lt;&lt;&quot;:&quot;&lt;&lt;HC[i]&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n代码：\n// C++ program for Huffman Coding\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nusing namespace std;\n\n// This constant can be avoided by explicitly\n// calculating height of Huffman Tree\n#define MAX_TREE_HT 100\n\n// A Huffman tree node\nstruct MinHeapNode &#123;\n\n    // One of the input characters\n    char data;\n\n    // Frequency of the character\n    unsigned freq;\n\n    // Left and right child of this node\n    struct MinHeapNode *left, *right;\n&#125;;\n\n// A Min Heap: Collection of\n// min-heap (or Huffman tree) nodes\nstruct MinHeap &#123;\n\n    // Current size of min heap\n    unsigned size;\n\n    // capacity of min heap\n    unsigned capacity;\n\n    // Array of minheap node pointers\n    struct MinHeapNode** array;\n&#125;;\n\n// A utility function allocate a new\n// min heap node with given character\n// and frequency of the character\nstruct MinHeapNode* newNode(char data, unsigned freq)\n&#123;\n    struct MinHeapNode* temp\n        = (struct MinHeapNode*)malloc\n(sizeof(struct MinHeapNode));\n\n    temp-&gt;left = temp-&gt;right = NULL;\n    temp-&gt;data = data;\n    temp-&gt;freq = freq;\n\n    return temp;\n&#125;\n\n// A utility function to create\n// a min heap of given capacity\nstruct MinHeap* createMinHeap(unsigned capacity)\n\n&#123;\n\n    struct MinHeap* minHeap\n        = (struct MinHeap*)malloc(sizeof(struct MinHeap));\n\n    // current size is 0\n    minHeap-&gt;size = 0;\n\n    minHeap-&gt;capacity = capacity;\n\n    minHeap-&gt;array\n        = (struct MinHeapNode**)malloc(minHeap-&gt;\ncapacity * sizeof(struct MinHeapNode*));\n    return minHeap;\n&#125;\n\n// A utility function to\n// swap two min heap nodes\nvoid swapMinHeapNode(struct MinHeapNode** a,\n                    struct MinHeapNode** b)\n\n&#123;\n\n    struct MinHeapNode* t = *a;\n    *a = *b;\n    *b = t;\n&#125;\n\n// The standard minHeapify function.\nvoid minHeapify(struct MinHeap* minHeap, int idx)\n\n&#123;\n\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n\n    if (left &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[left]-&gt;\nfreq &lt; minHeap-&gt;array[smallest]-&gt;freq)\n        smallest = left;\n\n    if (right &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[right]-&gt;\nfreq &lt; minHeap-&gt;array[smallest]-&gt;freq)\n        smallest = right;\n\n    if (smallest != idx) &#123;\n        swapMinHeapNode(&amp;minHeap-&gt;array[smallest],\n                        &amp;minHeap-&gt;array[idx]);\n        minHeapify(minHeap, smallest);\n    &#125;\n&#125;\n\n// A utility function to check\n// if size of heap is 1 or not\nint isSizeOne(struct MinHeap* minHeap)\n&#123;\n\n    return (minHeap-&gt;size == 1);\n&#125;\n\n// A standard function to extract\n// minimum value node from heap\nstruct MinHeapNode* extractMin(struct MinHeap* minHeap)\n\n&#123;\n\n    struct MinHeapNode* temp = minHeap-&gt;array[0];\n    minHeap-&gt;array[0]\n        = minHeap-&gt;array[minHeap-&gt;size - 1];\n\n    --minHeap-&gt;size;\n    minHeapify(minHeap, 0);\n\n    return temp;\n&#125;\n\n// A utility function to insert\n// a new node to Min Heap\nvoid insertMinHeap(struct MinHeap* minHeap,\n                struct MinHeapNode* minHeapNode)\n\n&#123;\n\n    ++minHeap-&gt;size;\n    int i = minHeap-&gt;size - 1;\n\n    while (i &amp;&amp; minHeapNode-&gt;freq &lt; minHeap-&gt;array[(i - 1) / 2]-&gt;freq) &#123;\n\n        minHeap-&gt;array[i] = minHeap-&gt;array[(i - 1) / 2];\n        i = (i - 1) / 2;\n    &#125;\n\n    minHeap-&gt;array[i] = minHeapNode;\n&#125;\n\n// A standard function to build min heap\nvoid buildMinHeap(struct MinHeap* minHeap)\n\n&#123;\n\n    int n = minHeap-&gt;size - 1;\n    int i;\n\n    for (i = (n - 1) / 2; i &gt;= 0; --i)\n        minHeapify(minHeap, i);\n&#125;\n\n// A utility function to print an array of size n\nvoid printArr(int arr[], int n)\n&#123;\n    int i;\n    for (i = 0; i &lt; n; ++i)\n        cout&lt;&lt; arr[i];\n\n    cout&lt;&lt;&quot;\\n&quot;;\n&#125;\n\n// Utility function to check if this node is leaf\nint isLeaf(struct MinHeapNode* root)\n\n&#123;\n\n    return !(root-&gt;left) &amp;&amp; !(root-&gt;right);\n&#125;\n\n// Creates a min heap of capacity\n// equal to size and inserts all character of\n// data[] in min heap. Initially size of\n// min heap is equal to capacity\nstruct MinHeap* createAndBuildMinHeap(char data[], int freq[], int size)\n\n&#123;\n\n    struct MinHeap* minHeap = createMinHeap(size);\n\n    for (int i = 0; i &lt; size; ++i)\n        minHeap-&gt;array[i] = newNode(data[i], freq[i]);\n\n    minHeap-&gt;size = size;\n    buildMinHeap(minHeap);\n\n    return minHeap;\n&#125;\n\n// The main function that builds Huffman tree\nstruct MinHeapNode* buildHuffmanTree(char data[], int freq[], int size)\n\n&#123;\n    struct MinHeapNode *left, *right, *top;\n\n    // Step 1: Create a min heap of capacity\n    // equal to size. Initially, there are\n    // modes equal to size.\n    struct MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);\n\n    // Iterate while size of heap doesn&#39;t become 1\n    while (!isSizeOne(minHeap)) &#123;\n\n        // Step 2: Extract the two minimum\n        // freq items from min heap\n        left = extractMin(minHeap);\n        right = extractMin(minHeap);\n\n        // Step 3: Create a new internal\n        // node with frequency equal to the\n        // sum of the two nodes frequencies.\n        // Make the two extracted node as\n        // left and right children of this new node.\n        // Add this node to the min heap\n        // &#39;$&#39; is a special value for internal nodes, not used\n        top = newNode(&#39;$&#39;, left-&gt;freq + right-&gt;freq);\n\n        top-&gt;left = left;\n        top-&gt;right = right;\n\n        insertMinHeap(minHeap, top);\n    &#125;\n\n    // Step 4: The remaining node is the\n    // root node and the tree is complete.\n    return extractMin(minHeap);\n&#125;\n\n// Prints huffman codes from the root of Huffman Tree.\n// It uses arr[] to store codes\nvoid printCodes(struct MinHeapNode* root, int arr[], int top)\n\n&#123;\n\n    // Assign 0 to left edge and recur\n    if (root-&gt;left) &#123;\n\n        arr[top] = 0;\n        printCodes(root-&gt;left, arr, top + 1);\n    &#125;\n\n    // Assign 1 to right edge and recur\n    if (root-&gt;right) &#123;\n\n        arr[top] = 1;\n        printCodes(root-&gt;right, arr, top + 1);\n    &#125;\n\n    // If this is a leaf node, then\n    // it contains one of the input\n    // characters, print the character\n    // and its code from arr[]\n    if (isLeaf(root)) &#123;\n\n        cout&lt;&lt; root-&gt;data &lt;&lt;&quot;: &quot;;\n        printArr(arr, top);\n    &#125;\n&#125;\n\n// The main function that builds a\n// Huffman Tree and print codes by traversing\n// the built Huffman Tree\nvoid HuffmanCodes(char data[], int freq[], int size)\n\n&#123;\n    // Construct Huffman Tree\n    struct MinHeapNode* root\n        = buildHuffmanTree(data, freq, size);\n\n    // Print Huffman codes using\n    // the Huffman tree built above\n    int arr[MAX_TREE_HT], top = 0;\n\n    printCodes(root, arr, top);\n&#125;\n\n// Driver code\nint main()\n&#123;\n\n    char arr[] = &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;\n    int freq[] = &#123; 5, 9, 12, 13, 16, 45 &#125;;\n\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    HuffmanCodes(arr, freq, size);\n\n    return 0;\n&#125;\n/*\n结果输出：\nf: 0\nc: 100\nd: 101\na: 1100\nb: 1101\ne: 111\n*/\n\nAVL树平衡二叉树：\n(110条消息) AVL树的详细实现(C++)_code_peak的博客-CSDN博客_c++实现avl树\navl树的各种延申应用：伸展树，B树，字典树\n","tags":["学习笔记"]}]