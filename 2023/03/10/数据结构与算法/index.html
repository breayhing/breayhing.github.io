<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="CS笔记 , 代码">
    <meta name="description" content="目前在更进的一个小网站">
    <meta name="author" content="breayhing / SIRI">
    
    <title>
        
            数据结构与算法 PART 1 |
        
        Breayhing的博客
    </title>
    
<link rel="stylesheet" href="../../../../css/style.css">

    <link rel="shortcut icon" href="../../../../images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/head.png","font_size":"18px","font_family":"STKaiti","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"Ubiquitous assimilation || 做一条咸鱼，但是没事扑腾两下","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsdian"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="../../../../images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               Breayhing的博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../index.html"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../archives"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               target="_blank" rel="noopener" href="http://sirohune.site/"
                            >
                                友情链接
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../index.html">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../archives">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       target="_blank" rel="noopener" href="http://sirohune.site/">友情链接</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">数据结构与算法 PART 1</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="../../../../images/head.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">breayhing / SIRI</span>
                            
                                <span class="author-label">Lv2</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-03-10 17:02:00</span>
        <span class="mobile">2023-03-10 17:02</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-03-10 17:05:19</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="../../../../tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>31.8k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>140 分钟</span>
        </span>
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="数据结构与算法：PART1"><a href="#数据结构与算法：PART1" class="headerlink" title="数据结构与算法：PART1"></a>数据结构与算法：PART1</h1><hr>
<h3 id="算法时间分析："><a href="#算法时间分析：" class="headerlink" title="算法时间分析："></a>算法时间分析：</h3><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF" >https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="理解idx"><a href="#理解idx" class="headerlink" title="理解idx:"></a>理解idx:</h3><p>我感觉idx相当于一个分配器，如果需要加入新的结点就用++idx分配出一个下标（最主要可以做到不重复地重新分配下标）</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5673/" >AcWing 835. 如何理解单(双)链表，Trie树和堆中的idx？ - AcWing<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<p><strong>所有数据结构 学习的同时一定要理解该种数据结构的使用范围，干什么的&#x2F;</strong></p>
<h6 id="科班学习顺序：（如何逐步提高写程序的性能）"><a href="#科班学习顺序：（如何逐步提高写程序的性能）" class="headerlink" title="科班学习顺序：（如何逐步提高写程序的性能）"></a>科班学习顺序：（如何逐步提高写程序的性能）</h6><p>基础程序设计-&gt;数据结构与算法-&gt;操作系统-&gt;编译器的优化（编译原理）</p>
<h6 id="提高程序性能办法："><a href="#提高程序性能办法：" class="headerlink" title="提高程序性能办法："></a>提高程序性能办法：</h6><p>好的算法：正确性，可读性，健壮性，效率</p>
<h6 id="程序运行时间因素"><a href="#程序运行时间因素" class="headerlink" title="程序运行时间因素"></a>程序运行时间因素</h6><ol>
<li>所用算法</li>
<li>问题的规模</li>
<li>书写程序所用语言-&gt;级别越高效率越低</li>
<li>编译程序所用的机器(mac比windows快)</li>
<li>机器执行所用的速度（涉及到硬件，比如老电脑和新电脑）</li>
</ol>
<p>算法时间度量：<strong>为了完成某一问题机器所做的操作执行次数</strong></p>
<p>统计方法：写代码前&#x2F;写代码后</p>
<pre><code class="c++">int i, sum=0, n=100;//执行1次
for(i=1;i&lt;=n;i++)//执行n+1次
&#123;
sum+=i;//执行n次
&#125;
cout&lt;&lt;sum;//执行n次
</code></pre>
<h6 id="冯诺依曼架构"><a href="#冯诺依曼架构" class="headerlink" title="冯诺依曼架构"></a>冯诺依曼架构</h6><p>I&#x2F;O&lt;-&gt;中央存储单元&lt;-&gt;</p>
<p>CPU:解析指令</p>
<p>内存：存储指令和数据</p>
<p>程序大小相对不重要，执行操作与数据重要</p>
<h6 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h6><p>通过计算算法所创建的空间大小。</p>
<h3 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h3><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><pre><code class="c++">求n的第k位数字: n &gt;&gt; k &amp; 1
返回n的最后一位1：lowbit(n) = n &amp; -n
</code></pre>
<h4 id="快排——》重要，面试常用型😍"><a href="#快排——》重要，面试常用型😍" class="headerlink" title="快排——》重要，面试常用型😍"></a>快排——》重要，面试常用型😍</h4><p>快排本质就是使用<strong>分治思想，递归实现</strong></p>
<p><strong>最快onlogn，最慢oN2</strong></p>
<p>步骤：</p>
<ol>
<li>确定分界点</li>
<li>调整范围<strong>（最麻烦部分）</strong></li>
<li>对左右两边进行操作</li>
</ol>
<h6 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h6><pre><code class="c++">void quick_sort(int q[], int l, int r)//记住开头不变，最后右边是j+1
&#123;
    if (l &gt;= r) return;//左右指针相遇时候返回

    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];//这里x暂时设定为左右边界的中间值，原因在于后边是do while指令，因此提前ij各往外移动一个位置
     //第一步：分成子问题
    while (i &lt; j)
    &#123;//注意这个顺序一定不能错
        do i ++ ; while (q[i] &lt; x);
        do j -- ; while (q[j] &gt; x);
        //容易错的点：要在这里打一个if
        if (i &lt; j) swap(q[i], q[j]);//swap函数自己补充，这里ij可以相等
    &#125;//这样操作过一轮之后x左边都是比它小的，右边都是比它大的
    //第二步：递归处理子问题
    
    
    
    quick_sort(q, l, j), quick_sort(q, j + 1, r);//这里一定一定是j，i会出问题
    
    
    
    //这里两步的顺序一定一定记住，不然可能无限划分
    //接着对它左右两端进行同样一次的操作，递归到最后就是全部完成排序
    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
&#125;
</code></pre>
<p>使用说明：</p>
<pre><code class="c++">如原本为a[10]，数据为a[0]-a[9];
则排序为
    quick_sort(a, 0, 9);//注意这里很容易错误弄范围
</code></pre>
<h6 id="快排合理性分析：AcWing-785-快速排序算法的证明与边界分析-AcWing"><a href="#快排合理性分析：AcWing-785-快速排序算法的证明与边界分析-AcWing" class="headerlink" title="快排合理性分析：AcWing 785. 快速排序算法的证明与边界分析 - AcWing"></a>快排合理性分析：<a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/16777/" >AcWing 785. 快速排序算法的证明与边界分析 - AcWing<i class="fas fa-external-link-alt"></i></a></h6><p>由于使用do-while循环,所以i和j一定会!!!自增!!!,使得循环会继续下去,但是如果采用while循环(i和j的初始化做出对应的变更),<strong>i和j在特殊情况下不自增的话,循环就会卡死</strong></p>
<p>边界问题：</p>
<p>快排属于分治算法，<strong>最怕的就是 n分成0和n，或 n分成n和0,这会造成无限划分</strong></p>
<pre><code class="c++">while(q[i] &lt; x) i++;
  while(q[j] &gt; x) j--;
当q[i]和q[j]都为 x 时, i 和 j 都不会更新,导致 while 陷入死循环
</code></pre>
<h5 id="单向移动版本快排（实际使用快慢指针）"><a href="#单向移动版本快排（实际使用快慢指针）" class="headerlink" title="单向移动版本快排（实际使用快慢指针）"></a>单向移动版本快排（实际使用快慢指针）</h5><pre><code class="c++">int partition(int arr[], int low, int high)
 &#123;
    int pivot = arr[low]; // 待比较的基准元素
    int i = low;
    for (int j = low + 1; j &lt;= high; j++) 
    &#123; if (arr[j] &lt; pivot) 
        &#123; i++; 		//最终i停留的位置是要交换的位置
             swap(arr[i], arr[j]);
        &#125;
    &#125; 
    swap(arr[i], arr[low]); 
    return i;
&#125;
void quickSort(int arr[], int low, int high) &#123;
    if (low &lt; high) &#123; 
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1); 
        quickSort(arr, pi + 1, high);
        &#125;
&#125;

/*
这种排序实际上将数组分成了三个部分：比pivot小，pivot，比pivot大，因此分治部分只需要对于pi-1和pi+1进行操作就行
*/
</code></pre>
<p>运行逻辑：指针j运行快，i运行慢，j只会在遇到比基准元素大的时候跳过</p>
<p>正常流程：如果j指向的都是比pivot小的元素，ji同步运动，指针一直向右走</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-02%20124330.png"
                      alt="屏幕截图 2022-11-02 124330"
                ></p>
<p>如果j右边是比pivot大的元素，即i右边紧挨着就是更大的元素，j跳过，i停留不移动</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-02%20124554.png"
                      alt="屏幕截图 2022-11-02 124554"
                ></p>
<p>然后让i++，刚好就到了大的元素，进行交换</p>
<p>结束情况：j遍历完成，i最后右移一次，停止</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-02%20124702.png"
                      alt="屏幕截图 2022-11-02 124702"
                ></p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>接着就是分治了</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><pre><code class="c++">void insertionSort(int arr[], int n) &#123;

int i, key, j; 
    for (i = 1; i &lt; n; i++) 
    &#123;
        key = arr[i];
        j = i - 1;
// 如果大于key需要向后移动一位
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key)
        &#123;//直接插入是一直插入到对比结束
            arr[j + 1] = arr[j]; j = j - 1;
        &#125; 
        arr[j + 1] = key;
&#125;
&#125;
</code></pre>
<h4 id="plus-折半插入排序（插入-二分）——》稳定又好使"><a href="#plus-折半插入排序（插入-二分）——》稳定又好使" class="headerlink" title="plus:折半插入排序（插入+二分）——》稳定又好使"></a>plus:折半插入排序（插入+二分）——》稳定又好使</h4><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><pre><code class="c++">int binarySearch(int a[], int item, int low, int high) 
&#123; 
    if (high &lt;= low) &#123; return (item &gt; a[low]) ? (low + 1) : low;&#125; 
     int mid = (low + high) / 2; 
    if (item == a[mid]) &#123; return mid + 1;&#125;
    if (item &gt; a[mid]) &#123; return binarySearch(a, item, mid + 1, high);&#125;
    return binarySearch(a, item, low, mid - 1);

&#125;//二分搜索部分
//注意二分一定有解，但是答案不一定有解
void insertionSort(int a[], int n) 
&#123;
    int i, loc, j, k, selected; 
    for (i = 1; i &lt; n; ++i) 
    &#123;
         j = i - 1;
        selected = a[i];
        // 寻找应该插入的位置
        loc = binarySearch(a, selected, 0, j);
        //这里直接找到，后面的while循环就不需要再考虑对比，直接上就行
        // 移动后面所有的数据
        while (j &gt;= loc) 
        &#123; 
            a[j + 1] = a[j];
             j--;
        &#125;
        a[j + 1] = selected;
    &#125;

&#125;
</code></pre>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h6 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h6><pre><code class="c++">int shellSort(int arr[], int n) &#123;
// 从大gap开始，逐步减少gap
for (int gap = n / 2; gap &gt; 0; gap /= 2) 
    &#123; 
        for (int i = gap; i &lt; n; i += 1) 
        &#123;
// i 是直接插入排序算法中待插入的元素int temp = arr[i];
// 向前查找，并同时移位
            int j;
            for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) 
            &#123; 
                arr[j] = arr[j - gap];
            &#125;
// 把i元素放入合适的位置
            arr[j] = temp;
        &#125;
    &#125; 
    return 0;
&#125;
</code></pre>
<h4 id="归并排序（另一个重要排序，也背下来）😃"><a href="#归并排序（另一个重要排序，也背下来）😃" class="headerlink" title="归并排序（另一个重要排序，也背下来）😃"></a>归并排序（另一个重要排序，也背下来）😃</h4><p><strong>不太好的点：归并排容易爆内存</strong></p>
<h6 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h6><pre><code class="c++">void merge_sort(int q[], int l, int r)
&#123;
    if (l &gt;= r) return;//最后拆分成单元素的时候就返回
    int mid = l + r &gt;&gt; 1;//二分
    
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
//以上先疯狂二分，将整个数组全部拆分成最小部分，然后下面部分开始递归合并
    int k = 0, i = l, j = mid + 1;
       分别作用：
        k用于tmp数组，因此从0开始
        i从最左，j从中间开始向右
    
    
    while (i &lt;= mid &amp;&amp; j &lt;= r)//这里由于递归，每一个小数组都归并好了，归并最后的大数组
        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//归并，结果合并到tmp，
        else tmp[k ++ ] = q[j ++ ];

    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//赋值剩下的i
    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//赋值剩下的j

    for (i = l, k = 0; i &lt;= r; i ++, k ++ ) q[i] = tmp[k];
    k代表临时数组的值
      
    
    //赋值回去，使得q同步变得有序，用于小数组递归回去用
    //憋想着省去这一步，不然小数组无法被弄成有序，最后归并会失败
&#125;
</code></pre>
<p>使用举例：</p>
<p>几个注意点：</p>
<ul>
<li>tmp一开始就声明（不然爆内存）</li>
<li>merge里面j&#x3D;mid+1（这里弄错之后排序都不对劲）</li>
<li>merge函数中i与j的范围记得别被错</li>
</ul>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
const int N=1e5+10;
int array[N];
int tmp[N];
void merge(int l,int r)
&#123;
    int mid=(l+r)/2;
    int k=0,i=l,j=mid+1;//j的赋值容易不对劲
    while(i&lt;=mid&amp;&amp;j&lt;=r)
    &#123;
        if(array[i]&lt;=array[j])tmp[k++]=array[i++];//这里判断的时候还是加‘=’
        else tmp[k++]=array[j++];
    &#125;
    while(i&lt;=mid)&#123;tmp[k++]=array[i++];&#125;
    while(j&lt;=r)&#123;tmp[k++]=array[j++];&#125;
    for(i=l,j=0;i&lt;=r;i++,j++)//这里的范围也容易搞混
    &#123;//注意归并排序中所有都是&lt;=
        array[i]=tmp[j];
    &#125;
&#125;
void mergesort(int l,int r)
&#123;
    if(l&gt;=r)return;
    int i=l-1;
    int j=r+1;
    int mid=(i+j)/2;//这里有一个特别狠的二分
    
    mergesort(l,mid);
    mergesort(mid+1,r);//这里需要+1
    merge(l,r);
&#125;
int main()
&#123;
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    &#123;
        cin&gt;&gt;array[i];
    &#125;
    mergesort(0,n-1);
    for(int i=0;i&lt;n;i++)
    &#123;
        cout&lt;&lt;array[i]&lt;&lt;&#39; &#39;;
    &#125;
    return 0;
&#125;
</code></pre>
<h6 id="有趣应用：逆序对"><a href="#有趣应用：逆序对" class="headerlink" title="有趣应用：逆序对"></a>有趣应用：逆序对</h6><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/790/" >788. 逆序对的数量 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="timsort（优化后归并）"><a href="#timsort（优化后归并）" class="headerlink" title="timsort（优化后归并）"></a>timsort（优化后归并）</h4><p>这个就看苏老师的ppt课件</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35678407/article/details/82974174?ops_request_misc=%7B%22request_id%22:%22166806089616782425695863%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166806089616782425695863&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82974174-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev2%5Et3_control1&utm_term=timsort&spm=1018.2226.3001.4187" >(105条消息) Timsort——自适应、稳定、高效排序算法_码到sucess的博客-CSDN博客_timsort<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="核心：提取降序数组升级为升序"><a href="#核心：提取降序数组升级为升序" class="headerlink" title="核心：提取降序数组升级为升序"></a>核心：提取降序数组升级为升序</h6><p>数组本质都是部分有序的,</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-09%20152030.png"
                      alt="屏幕截图 2022-11-09 152030"
                ></p>
<p>因此第一步：将所有部分降序数组全部翻转（这里直接逆序就好）</p>
<p>这一步模板：</p>
<pre><code class="c++">void reverse(int q[],int l,int r)
&#123;
    for(int i=l,j=r;i&lt;=j;i++,j--)swap(q[i],q[j]);
&#125;
void array_reverse(int q[],int N)
&#123;
    if(N==1&amp;&amp;N==0)return;
    int i=1,l=0,tmp=0,stage_judge;
    if(q[0]&lt;=q[1])stage_judge=1;//升序标记
    else  stage_judge=0;
    while(i&lt;N)
    &#123;
        if(q[i]&gt;q[i+1])
        &#123;
            if(stage_judge==1)stage_judge=0;
            ++i;
        &#125;
        else if(q[i]&lt;=q[i+1])
        &#123;
            if(stage_judge==0)
            &#123;
                if(tmp!=l-1)++l;
                reverse(q,l,i);
                tmp=i;
                stage_judge=1;
            &#125;
            ++i;//前进一个
            l=i;//l=前进一位之后的i
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="核心：栈处理归并"><a href="#核心：栈处理归并" class="headerlink" title="核心：栈处理归并"></a>核心：栈处理归并</h6><p>先将所有已知的升序排列的压入总栈，</p>
<p>这一步：</p>
<pre><code class="c++">void stack_check(int N)//对栈进行检验,并且要的是归并两个连续短区间
&#123;
    int stack_pos1,stack_pos2,stack_pos3;
    int stack_length1,stack_length2,stack_length3;//1最顶，3最底层
    pop(stack_pos1,stack_length1);
    pop(stack_pos2,stack_length2);
    pop(stack_pos3,stack_length3);
    if(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)//x&gt;y或者x+y&gt;z
    &#123;
        if(stack_length1&gt;stack_length3)
        &#123;
                push(stack_pos1,stack_length1);
                merge(stack_pos3, stack_length3,stack_pos2, stack_length2 );//对yz进行归并

        &#125;
            else
        &#123;
                    push(stack_pos3,stack_length3);
                    merge(stack_pos2,stack_length2,stack_pos1,stack_length1);//对xy进行归并
        &#125;
           // cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;
        for(int i=0;i&lt;N;i++)
        &#123;
            cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;
        &#125;
        cout&lt;&lt;endl;
        if(stack_idx&gt;=2)stack_check(N);//递归检测
    &#125;
    else//按照原先顺序再压进去
    &#123;
        push(stack_pos3,stack_length3);
        push(stack_pos2,stack_length2);
        push(stack_pos1,stack_length1);
        cout&lt;&lt;endl&lt;&lt;endl;
    &#125;
    return;
&#125;
</code></pre>
<h6 id="核心：最小分区长度在排序之前预先计算"><a href="#核心：最小分区长度在排序之前预先计算" class="headerlink" title="核心：最小分区长度在排序之前预先计算"></a>核心：最小分区长度在排序之前预先计算</h6><p>➢ 归并过程低效的主要原因是大分区和小分区合并</p>
<pre><code class="c++">while(stack_idx&gt;=1)//输出阶段,这里就是检测是否正确归并入栈，没有归并
   &#123;
        pop(stack_pos1,stack_length1);
        pop(stack_pos2,stack_length2);
       if(stack_pos1&gt;stack_pos2)merge(stack_pos2,stack_length2,stack_pos1,stack_length1);
       else merge(stack_pos1,stack_length1,stack_pos2,stack_length2);
       for(int i=0;i&lt;N;i++)
       &#123;
           cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;
       &#125;
</code></pre>
<h6 id="timsort模板（自己写的！）"><a href="#timsort模板（自己写的！）" class="headerlink" title="timsort模板（自己写的！）"></a>timsort模板（自己写的！）</h6><pre><code class="c++">#include&lt;iostream&gt;
using namespace  std;
const int M =10010;
int q[M];
int tmp[M];
int pos_stack[M];//存储下标
int length_stack[M];//存储长度
int stack_idx=-1;
void push(int pos,int length )
&#123;
    pos_stack[++stack_idx]=pos;
    length_stack[stack_idx]=length;
&#125;
void pop(int &amp;tmp_pos,int &amp;tmp_length)//给两个数赋值然后弄出去
&#123;
    tmp_pos= pos_stack[stack_idx];
    tmp_length= length_stack[stack_idx];
    --stack_idx;
    return;
&#125;
void reverse(int q[],int l,int r)
&#123;
    for(int i=l,j=r;i&lt;=j;i++,j--)swap(q[i],q[j]);
&#125;
void array_reverse(int q[],int N)
&#123;
    if(N==1&amp;&amp;N==0)return;
    int i=1,l=0,tmp=0,tem_l=0,stage_judge;
    if(q[0]&lt;=q[1])stage_judge=1;//升序标记
    else  stage_judge=0;
    while(i&lt;N)
    &#123;
        if(q[i]&gt;q[i+1])
        &#123;
            if(stage_judge==1)
            &#123;
                stage_judge=0;//之前是升序这里突然降序了
            &#125;
            ++i;
        &#125;
        else if(q[i]&lt;=q[i+1])
        &#123;
            if(stage_judge==0)
            &#123;
                if(tmp!=l-1)++l;
                reverse(q,l,i);
                tmp=i;
                stage_judge=1;
            &#125;
            ++i;//前进一个
            l=i;//l=前进一位之后的i
        &#125;
    &#125;
&#125;
void merge(int pos1,int length1,int pos2,int length2)
&#123;
    int r=pos2+length2-1;//最右端
    int l=pos1;//最左端
    //归并部分
    int mid=pos1+length1-1;
    int k = 0, i = l, j = pos2 ;
    while (i &lt;= mid &amp;&amp; j &lt;= r)//这里由于递归，每一个小数组都归并好了，归并最后的大数组
        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//归并，结果合并到tmp，
        else tmp[k ++ ] = q[j ++ ];
    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//赋值剩下的i
    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//赋值剩下的j
    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
    push(pos1,length1+length2);//合并完之后进行压栈
&#125;
void stack_check(int N)//对栈进行检验,并且要的是归并两个连续短区间
&#123;
    int stack_pos1,stack_pos2,stack_pos3;
    int stack_length1,stack_length2,stack_length3;//1最顶，3最底层
    pop(stack_pos1,stack_length1);
    pop(stack_pos2,stack_length2);
    pop(stack_pos3,stack_length3);
    if(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)//x&gt;y或者x+y&gt;z
    &#123;
        if(stack_length1&gt;stack_length3)
        &#123;
                push(stack_pos1,stack_length1);
                merge(stack_pos3, stack_length3,stack_pos2, stack_length2 );//对yz进行归并

        &#125;
            else
        &#123;
                    push(stack_pos3,stack_length3);
                    merge(stack_pos2,stack_length2,stack_pos1,stack_length1);//对xy进行归并
        &#125;
           // cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;
        for(int i=0;i&lt;N;i++)
        &#123;
            cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;
        &#125;
        cout&lt;&lt;endl;
        if(stack_idx&gt;=2)stack_check(N);//递归检测
    &#125;
    else//按照原先顺序再压进去
    &#123;
        push(stack_pos3,stack_length3);
        push(stack_pos2,stack_length2);
        push(stack_pos1,stack_length1);
        cout&lt;&lt;endl&lt;&lt;endl;
    &#125;
    return;
&#125;
//归并搞定
int main() &#123;
    int N;
    cin &gt;&gt; N;
    int stack_pos1,stack_pos2,stack_pos3;
    int stack_length1,stack_length2,stack_length3;
    for (int i = 0; i &lt; N; i++) &#123;
        cin &gt;&gt; q[i];
    &#125;
    array_reverse(q, N - 1);//没问题了,别动！
    int l=0;
    for(int i = 0; i &lt; N; i++) &#123;
        if(q[i]&gt;q[i+1])
        &#123;
            push(l,i-l+1);

            l=i+1;
        &#125;
    &#125;//这里完成将栈压入
    //接下来就是找最大的，然后合并
    cout&lt;&lt;endl&lt;&lt;endl;
    for(int i=0;i&lt;N;i++)
    &#123;
        cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;
    &#125;
    cout&lt;&lt;endl;
    if(stack_idx&gt;=2)stack_check(N);
    while(stack_idx&gt;=1)//输出阶段,这里就是检测是否正确归并入栈，没有归并
   &#123;
        pop(stack_pos1,stack_length1);
        pop(stack_pos2,stack_length2);
       if(stack_pos1&gt;stack_pos2)merge(stack_pos2,stack_length2,stack_pos1,stack_length1);
       else merge(stack_pos1,stack_length1,stack_pos2,stack_length2);
       for(int i=0;i&lt;N;i++)
       &#123;
           cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;
       &#125;
   &#125;
    return 0;
&#125;//23         2 4 7 8 23 19 16 14 13 12 10 20 18 17 15 11 0 5 6 1 3 21 22
</code></pre>
<h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>二分本质并不是单调性：有单调性一定可以二分解，可以二分解的题目不一定满足单调性，本质：可以将原本区间分成两个部分</p>
<p><em><strong>二分一定有解（自己的二分的性质是一定有边界的），但题目可能会无解</strong></em>（看例题）</p>
<p><strong>整数二分比实数二分蛋疼很多</strong>：整数有边界问题很恶心</p>
<p><strong>当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了</strong></p>
<h6 id="整数模板（两种）"><a href="#整数模板（两种）" class="headerlink" title="整数模板（两种）"></a>整数模板（两种）</h6><p>应用：</p>
<p>1：找大于等于数的第一个位置 （满足某个条件的第一个数）<br>2：找小于等于数的最后一个数 （满足某个条件的最后一个数）<br>3.查找最大值 （满足该边界的右边界）、<br>4.查找最小值 (满足该边界的左边界)</p>
<p>然后每次使用这这两个模板的时候，<strong>先想是找这个区间的左端点还是还是右端点，然后选择用模板，最后再去写判断条件</strong>。</p>
<p>设置红绿交界点是要求的位置</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-09%20210347.png"
                      alt="屏幕截图 2022-10-09 210347"
                ></p>
<ol>
<li>最后收敛到<strong>整个数组中满足条件的最右边的点</strong></li>
<li>最后收敛到数组中满足条件的<strong>最左边的点</strong></li>
</ol>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-09%20211416.png"
                      alt="屏幕截图 2022-10-09 211416"
                ></p>
<p>记忆方式：<em><strong>有减必有加</strong></em></p>
<pre><code class="c++">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质

//核心在于判断l=mid还是r=mid

//收敛到最右边的点
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：情况1
int SR(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        int mid = l + r + 1 &gt;&gt; 1;//需要补上l+r+1，防止死循环
        if (check(mid)) l = mid;
        else r = mid - 1;//有减，前面必定有加
    &#125;
    return l;
&#125;


//收敛到最左边的点
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：情况2
int SL(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;//这里是（l+2）/2
        if (check(mid)) r = mid;    // check()判断mid是否满足性质：
        else l = mid + 1;
    &#125;
    //
    return l;//这里最终l和r相等，不需要考虑别的
&#125;
</code></pre>
<h6 id="整数经典例题：789-数的范围-AcWing题库"><a href="#整数经典例题：789-数的范围-AcWing题库" class="headerlink" title="整数经典例题：789. 数的范围 - AcWing题库"></a>整数经典例题：<a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/791/" >789. 数的范围 - AcWing题库<i class="fas fa-external-link-alt"></i></a></h6><p>经典：二分模板最终一定有解，题目不一定有解（最后的判断不满足题目）</p>
<p>解答：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ-WNt-WNtw==,size_20,color_FFFFFF,t_70,g_se,x_16"
                      alt="在这里插入图片描述"
                ></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
const int N = 1e5 + 10;
int q[N];

int SL(int l, int r, int x) &#123;//最终结果是最左边满足条件的
  while (l &lt; r) &#123;
    int mid = l + r &gt;&gt; 1;
    if (q[mid] &gt;= x) r = mid;
    else l = mid + 1 ;
  &#125;
  return l;
&#125;

int SR (int l, int r, int x) &#123;
  while (l &lt; r) &#123;
    int mid = l + r + 1 &gt;&gt; 1;//有+
    if(q[mid] &lt;= x) l = mid;
    else r = mid - 1;//有-
  &#125;
  return r;
&#125;

int main() &#123; int n,m;
    scanf (&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;++i) scanf (&quot;%d&quot;,&amp;q[i]);
    while ( m-- ) &#123;
        int x;
        scanf (&quot;%d&quot;,&amp;x);
        int l = SL(0, n - 1, x);//查找左边界 并返回下标l
        //这里最后的L就是最左边第一个满足&gt;x的数字，也就是满足二分得到的结果（最接近x且&gt;=x）
        //因此下一步可以直接判断是否直接=x
        if (q[l]!=x) cout &lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;//如果找不到  返回-1 -1
        else &#123;
            cout &lt;&lt; l &lt;&lt; &#39; &#39;; //如果找到了  输出左下标
            cout &lt;&lt; SR(0, n - 1, x) &lt;&lt; endl; //输出右下标
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>同样的例题：（爷跟你拼了）</p>
<h6 id="519-跳石头-AcWing题库"><a href="#519-跳石头-AcWing题库" class="headerlink" title="519. 跳石头 - AcWing题库"></a><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/521/" >519. 跳石头 - AcWing题库<i class="fas fa-external-link-alt"></i></a></h6><p>照样使用二分（虽然是比较复杂的二分）：<strong>二分,贪心</strong>O(NlogL)</p>
<p><em><strong>思路：</strong></em>使得选手们在比赛过程中的最短跳跃距离尽可能长，<strong>当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了</strong>。验证答案具有单调性：<strong>拿走的石头越多，最短跳跃距离越大</strong>，这就叫答案的单调性</p>
<p>核心原理：</p>
<ul>
<li><strong>二分答案</strong><br>二分答案就是把一组数据每次分成两部分，就是把大问题转化成小问题。例如猜数游戏，猜1-100的一个数，就先猜50，若小了，就猜75，若大了，就猜25，就这样一直猜下去，最终找到答案。<strong>而我们每一次猜的这个答案就是所求范围内的数据的中间数据，这就是二分答案。这个二分的中间数据就是指要求的内容</strong>。</li>
<li><strong>如果长度 LenLen 可以满足，那么当长度小于 LenLen 时也可以满足，所以我们可以二分出最大的 LenLen。</strong>也就是在所有可满足的Len中寻找最右端的答案（这里指从0到最大），因此使用模板SR（再看上一道题实际上一个原理）</li>
<li>剩下的问题是如何判断给定 LenLen 的情况下，能否最多拿走 M块石头，使得所有相邻两块石头之间的距离不小于 LenLen。<strong>这一步可以贪心来做。从前往后扫描，<em>并记一下上一块石头的位置</em></strong>。</li>
<li><strong>如果当前石头和上一块石头的距离小于 LenLen，则将当前石头拿走</strong></li>
<li><strong>如果当前石头和上一块石头的距离大于等于 LenLen，则将上一块石头更新成当前这块。</strong>（和上一条是贪心时候的两种解法）</li>
<li>这里给出贪心证明：如果某个最优解中是拿走了上一块石头，那么我们可以改成留下上一块石头，拿走当前这块石头，这样总共拿走的石头数量不变，所以当前选法也是一组最优解。</li>
<li>check函数：<strong>我们遍历一遍每一块石头，累计出有多少块石头之间的间隔&lt;&#x3D;mid,如果超过m个，就不合法，如果小于等于m，就合法。</strong>(累计间隔小也就是需要搬走多少个石头)</li>
<li>扫描结束后判断拿走的石头数量是否小于等于 M。（<strong>判断这个答案能不能执行，能说明答案mid还能猜测更大，更新l，不能说明mid猜测过大了，更新r</strong>）</li>
</ul>
<p>时间复杂度分析<br>总共二分 O(logL)O(logL) 次，每次贪心的计算是 O(N)O(N)，因此总时间复杂度是 O(NlogL)O(NlogL)。</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 50005;
int a[N];
int n,m,s;

bool check(int x) //check函数判断这个最短跳跃距离x是否合法
&#123;
    int cnt=0,last=0; //last表示的是上一块石头的位置,cnt用来计数
    for(int i=1;i&lt;=n;i++)   //枚举每一块石头 
    &#123;
        //不移动走石头，就实时更新上一块石头位置，如果移动，就不更新
        if(a[i]-last&lt;x) cnt++;//如果这一块石头和上一块石头的距离比x小,计数+1。而且如果石头移走，last还是上一块石头的位置。
        else last=a[i]; //否则这块石头就不必移走，last=这块石头的位置。
    &#125;
    if(cnt&gt;m) return false; //cnt如果超过m个，就不合法。
    else return true;
&#125;

int main()
&#123;
    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    a[n+1]=s;//将终点的距离也算进去

    n=n+1;//注意这里的n需要加一，check函数需要用

    int l=1,r=s; //注意l和r都是最短跳跃距离的边界，而不是石头的边界。 
    while(l&lt;r)
    &#123;
        int mid=l+r+1&gt;&gt;1;
        if(check(mid)) l=mid;//答案猜小了
        else r=mid-1;//答案猜大了
    &#125;
    cout&lt;&lt;l&lt;&lt;endl;
&#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/21312/" >https://www.acwing.com/blog/content/21312/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/118815/" >https://www.acwing.com/solution/content/118815/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/59bjss/" >https://leetcode.cn/leetbook/read/illustration-of-algorithm/59bjss/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/120802/" >https://www.acwing.com/solution/content/120802/<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="浮点模板"><a href="#浮点模板" class="headerlink" title="浮点模板"></a>浮点模板</h6><p>浮点好处在于不用考虑整数二分中的边界问题，因此直接用</p>
<pre><code class="c++">bool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质

double bsearch_3(double l, double r)
&#123;
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    &#123;
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;//这里就不用多考虑
    &#125;
    return l;
&#125;
</code></pre>
<p>例题：<a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/792/" >790. 数的三次方根 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<pre><code class="c++">#include &lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
double x;
int main () &#123;
    cin &gt;&gt; x;
    double l = -1000,r = 1000;//这里一开始范围设定大，直接从0开始
    while (r - l &gt;= 1e-7) &#123;
        double mid = (l + r) / 2;
        if (mid * mid * mid &lt;= x) l = mid;  //如果是小于等于的话，就可以说明答案会更大
        //比较重要的一步，c++里面几次方就直接弄，别用mid^3,配合c++primer食用
        else r = mid;
    &#125;
    printf (&quot;%.6lf&quot;,l);
    return 0;
&#125;
</code></pre>
<h5 id="二分改进："><a href="#二分改进：" class="headerlink" title="二分改进："></a>二分改进：</h5><h6 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h6><p>应用范围：<strong>表长较大，关键字分布均匀</strong></p>
<h6 id="关键不同："><a href="#关键不同：" class="headerlink" title="关键不同："></a>关键不同：</h6><p>二分mid固定为0.5，插值查找mid参数动态变化</p>
<pre><code class="c++">mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;
</code></pre>
<h6 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h6><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46359697/article/details/121952936?ops_request_misc=%7B%22request_id%22:%22166770338816782388045113%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166770338816782388045113&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-121952936-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE&spm=1018.2226.3001.4187" >(104条消息) 七大查找之斐波那契查找_非常规自我实现的博客-CSDN博客_fibonacci查找<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="前缀和（应用广泛）"><a href="#前缀和（应用广泛）" class="headerlink" title="前缀和（应用广泛）"></a>前缀和（应用广泛）</h4><p>数据结构应用：字符串哈希表kmp，自动机kmp，</p>
<h5 id="前缀和-哈希表-x3D-LZW压缩-gt-文本压缩"><a href="#前缀和-哈希表-x3D-LZW压缩-gt-文本压缩" class="headerlink" title="前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩"></a>前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩</h5><h6 id="压缩部分："><a href="#压缩部分：" class="headerlink" title="压缩部分："></a>压缩部分：</h6><h6 id="解压缩部分："><a href="#解压缩部分：" class="headerlink" title="解压缩部分："></a>解压缩部分：</h6><h4 id="离散化：整数离散化"><a href="#离散化：整数离散化" class="headerlink" title="离散化：整数离散化"></a>离散化：整数离散化</h4><p>如果使用哈希，会有额外的空间开销</p>
<p>特点：值域范围大，但是个数少（比如要访问到数组的10^9的位置，但个数只有10^5）也就是对于一个函数a-&gt;b，实际上只需要映射a，不需要操作b（<strong>当然高级玩家也可以继续弄b</strong>）。一般有两个问题：</p>
<ol>
<li>a数组里面可能有重复元素，因此需要<em><strong>去重</strong></em>，（去重是最重要的）</li>
<li>如何算出a[i]离散化后的值，<strong>保序离散化</strong>（a数组本身下标有序的），映射后一定也要是有序的，a[i].由于a有序，可以使用<strong>二分</strong></li>
</ol>
<p>需要使用的知识点：</p>
<ul>
<li>vector</li>
<li>pair</li>
</ul>
<h6 id="离散化模板：-c-版本"><a href="#离散化模板：-c-版本" class="headerlink" title="离散化模板：(c++版本)"></a>离散化模板：(c++版本)</h6><pre><code class="c++">//alls存储的是最开始的下标
vector&lt;int&gt; alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
&#123;
    int l = 0, r = alls.size() - 1;
    while (l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        if (alls[mid] &gt;= x) r = mid;
        else l = mid + 1;
    &#125;
    return r + 1; // 映射到1, 2, ...n
    //前缀和从1开始相对方便
&#125;
</code></pre>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/2321/" >AcWing 802. 区间和 - AcWing<i class="fas fa-external-link-alt"></i></a></p>
<p>分析：</p>
<p>使用离散化原因：</p>
<ol>
<li>存储下标过大，不能开这么大的下标</li>
<li>使用数轴，会存在负值，不能使用下标</li>
<li><strong>哈希表不能像离散化缩小数组的空间，可能导致遍历-e9~1e9</strong>。此处的含义就是假如我们需要计算1e-9和1e9区间内的值，那我们需要从前到后枚举，无论该值是否存在。<strong>因为哈希表不能排序</strong>，因此不能提前知道哪些数周上的点不存在，会枚举多次（如最后query的时候，从1到1e9，使用哈希表就要遍历才知道是否有点，时间开销太大），</li>
</ol>
<p>离散化本质：<strong>映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量</strong>，也就是<strong>如何能够将不连续的点映射到连续的数组的下标。</strong></p>
<p>本题解法：(离散化) O((n+2∗m)log(n+2∗m))</p>
<ol>
<li>开辟额外数组存放原来 的下标标志</li>
<li>对原来的数轴下标进行排序再去重，原因：考虑前缀和思想，我们需要求出的区间内的和的两端断点不一定有元素，提前加如需要求前缀和的两个端点，有利于我们进行二分搜索，其实二分搜索里面我们一般假定有解的，如果没解的话需要特判，所以提前加入了这些元素，从而导致可能出现重复元素</li>
<li>最多使用n+2m次操作，最多使用的下标跨度为3*10^5,</li>
</ol>
<p>首先用而二分写好映射后对应的数组下标，复杂度log(n + 2 * m)</p>
<pre><code class="c++">int find(int x)
&#123;
    int l = 0, r = alls.size() - 1;
    while(l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        if(alls[mid] &gt;= x) r = mid;
        else l = mid + 1;
    &#125;
    return r + 1;
&#125;
</code></pre>
<p>全解：</p>
<p>关于unique和erease可以看</p>
<p>[(100条消息) C++ 之vector元素去重unique()_sandalphon4869的博客-CSDN博客_unique vector](<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/sandalphon4869/article/details/98209093?ops_request_misc=%7B%22request_id%22:%22166674706816800184111752%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166674706816800184111752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-98209093-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=vector" >https://blog.csdn.net/sandalphon4869/article/details/98209093?ops_request_misc=%7B%22request%5Fid%22%3A%22166674706816800184111752%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166674706816800184111752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-98209093-null-null.142^v59^pc_rank_34_1,201^v3^control_1,213^v1^t3_control1&amp;utm_term=vector<i class="fas fa-external-link-alt"></i></a> unique&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>auto:<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/lwgkzl/article/details/82110068?ops_request_misc=%7B%22request_id%22:%22166674813816782412534322%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166674813816782412534322&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-82110068-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=auto&spm=1018.2226.3001.4187" >(100条消息) c++ auto基本用法_lwgkzl的博客-CSDN博客_auto用法<i class="fas fa-external-link-alt"></i></a></p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef pair&lt;int, int&gt; PII;//pair可以同时存储两个数据，可以理解成半封装的结构体
const int N = 300010;//最多涉及的下标长度
int a[N], s[N];
int n, m;

vector&lt;int&gt; alls;//存储下标值
vector&lt;PII&gt; add, query;//分别存储询问和加

int find(int x)
&#123;
    int l = 0, r = alls.size() - 1;
    while(l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        if(alls[mid] &gt;= x) r = mid;
        else l = mid + 1;
    &#125;
    return r + 1;//为了最终的映射从1开始
&#125;
vector&lt;int&gt;:: iterator unique(vector&lt;int&gt; &amp;a)
&#123;//这里是手动实现unique，非c++语言需要手动
    //作用为自动去重
    int j = 0;
    for(int i = 0; i &lt; a.size(); i ++)
        if(!i || a[i] != a[i - 1])
            a[j ++ ] = a[i];
    return a.begin() + j;
&#125;

int main()
&#123;

    cin &gt;&gt; n &gt;&gt; m;

    for(int i = 0; i &lt; n; i ++ )
    &#123;
        int x, c;//x是下标
        cin &gt;&gt; x &gt;&gt; c;
        add.push_back(&#123;x, c&#125;);
        alls.push_back(x);
    &#125;

    for(int i = 0; i &lt; m; i ++ )
    &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        query.push_back(&#123;l, r&#125;);
        alls.push_back(l);
        alls.push_back(r);
        //全部存储后alls组成为x,x,x,x,x,l1,r1,l2,r2等等
    &#125;

//直接unique(a)不加其它参数就是默认直接从头到尾，
    sort(alls.begin(), alls.end());//对原来的数组下标进行从小到大
    vector&lt;int&gt;::iterator pos = unique(alls);
     //pos是去重以后vector中没有重复元素的下一个位置的迭代器
    //从容器的开始到返回的迭代器位置的元素是不重复的元素，而从返回的迭代器位置到vector.end()的元素都是没有意义的（这东西就是原来排序后的东西，没变过）。
    //比如1 2 3 3 4 4 5 5unique后为1 2 3 4 5   5 5 5（别管这三个什么，没意义）

    alls.erase(pos, alls.end());//删除重复元素

    for(auto item : add)//add是一个vector&lt;PII&gt; add，为方便初始化这么用
    &#123;
        int x = find(item.first);//第一个值是要加的数的下标
        a[x] += item.second;//对应的数组位置加该数
    &#125;

    for(int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];
    //这里用前缀和方法求所有的前缀

    for(auto item : query)
    &#123;
        int l = find(item.first), 
        r = find(item.second);//两个都是
        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;
        //这里最后就是对应过来的减去后的值，
    &#125;

    return 0;
&#125;
//这些数据是验算用的
3 3//m。n
1 2
3 6
7 5
1 3
4 6
7 8
</code></pre>
<p>补充auto：</p>
<pre><code class="c++">int main()&#123;
    vector&lt;int&gt;v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    for(auto i : v)&#123;//这一步就是迭代器从begin走到end
        cout&lt;&lt;i&lt;&lt;&quot; &quot;;
    &#125;
    cout&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<h4 id="区间合并：不同于离散化"><a href="#区间合并：不同于离散化" class="headerlink" title="区间合并：不同于离散化"></a>区间合并：不同于离散化</h4><p>应用：很多区间，如果有交集就合并成一个更长的区间</p>
<p>区间合并算法：快速地进行多个区间的合并,当然可以进行一些特殊处理，比如对于端点就进行统一归并</p>
<h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li>按区间左端点进行排序</li>
<li>扫描过程中，对于所有有交集的区间进行合并。</li>
</ol>
<p>左边端点设置成start，右边设置成end，可能有的关系：</p>
<img  
                     lazyload
                     alt="image"
                     data-src="D:\me\配图\image-20221203210856611.png"
                      alt="image-20221203210856611" style="zoom:33%;" 
                >

<ol>
<li><strong>左右都在内部：原本区间不变</strong></li>
<li>仅一部分在内部：新的ed会边长（<strong>左端点不会更新，因为是按照左端点从小到大的顺序进行区间的扫描的</strong>）</li>
<li><strong>都不在内部：不用管就完事了</strong></li>
</ol>
<h6 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h6><pre><code class="c++">#include&lt;algorithm&gt;


void merge(vector&lt;PII&gt; &amp;segs)
&#123;
    vector&lt;PII&gt; res;

    sort(segs.begin(), segs.end());//这里是因为pair是默认按照左端点排序的

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed &lt; seg.first)//情况3：两个区间无法合并
        &#123;
            if (st != -2e9) res.push_back(&#123;st, ed&#125;);//区间1放进去res数组
            st = seg.first, ed = seg.second;//维护区间2
        &#125;
        else ed = max(ed, seg.second);//情况12，可以合并，进行更新

     //考虑循环结束时的st,ed变量，此时的st,ed变量不需要继续维护，只需要放进res数组即可。
    //因为这是最后的一个序列，所以不可能继续进行合并。
    if (st != -2e9) res.push_back(&#123;st, ed&#125;);//说的就是你，最后一个序列，if就是防一下空序列

    segs = res;//这样回复的就是答案segs
&#125;

//最大原因：排过序了，不用担心复用
//排过序之后，不可能有区间2包含区间1，只能是1包含后面的
//本质，遍历，每一次如果两个区间没有相交的部分（无法合并），那么就将一个区间推入作为答案，同时更新左右端点
</code></pre>
<p>y总：</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;

using namespace std;

typedef pair&lt;int,int&gt; PII;
vector&lt;PII&gt; segs;

void merge(vector&lt;PII&gt;&amp;segs)
&#123;
    vector&lt;PII&gt; res;
    sort(segs.begin(),segs.end());//先对于全部区间进行排序
    int l = -2e9,r = -2e9;//小就完事了
    for(auto item:segs)//定义了一个迭代器，这里是一个遍历的过程
    &#123;//! 第一段区间一定是  ed&lt; item.first
        if(r &lt; item.first)//当前区间右端点严格小于枚举区间的左边
        &#123;//情况1：两个区间无法合并
            if(l != -2e9) res.push_back(&#123;l,r&#125;);//! 第一次在这里初始化
            //区间1放进去res数组
            l = item.first;//! 第一段区间从这里开始即seg[0].first
            //维护区间2
            r = item.second;//第一段区间的。seg[0].second
        &#125;//todo 这个循环结束之后还会剩下一个区间
        else r = max(r,item.second);//第二种情况，说明有交集，右端点更新成维护的区间的右端点以及最大值
    &#125;//! 如果不是空的  那我们就加上一段
    if(l != -2e9) res.push_back(&#123;l,r&#125;);//最后一个区间判断一下，防止空区间
    segs = res;//区间更新变成res
&#125;
int main()
&#123;
    int n;
    cin &gt;&gt; n;

    while(n--)
    &#123;
        int l,r;
        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
        segs.push_back(&#123;l,r&#125;);
    &#125;
    merge(segs);
    cout &lt;&lt; segs.size() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p> 有限性：数据元素个数有穷</p>
<p>相同性：数据元素的类型是同一的</p>
<p>顺序性：相邻的数据元素之间存在序偶关系</p>
<h6 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h6><ul>
<li><p>链表当中利用结构体制造链表的速度都是非常慢的，会消耗很多的时间，而正常面试中需要使用到链表时候大小都是有限制的，一般是十万或者百万的级别，而单单是new这些节点就会导致超时，<strong>在笔试题中最好不要用结构体指针</strong>，可以优化比如提前构建好多个节点，但已经类似于数组模拟链表了.<strong>算法题中绝对绝对不要考虑内存泄漏的问题</strong></p>
</li>
<li><p>使用结构体去构建链表的另一个问题在于键入指令会很麻烦</p>
<pre><code class="c++">//数组版本
int next[N],prev[N],valu[N]
void delete(int k)
&#123;
    next[prev[k]]=next[k];//向右跳过中间
    prev[next[k]]=prev[k];//向左跳过中间
&#125;
//结构体版本
struct Node
&#123;
    int valu,next,prev;
&#125;nodes[N];
void delete(int k)
&#123;
    nodes[nodes[k].prev].next=nodes[k].next;
    nodes[nodes[k].next].prev=nodes[k].prev;
&#125;
//两种类型相比第二种整体结构易于理解但是在使用过程中语句特别长而且不太容易理解
</code></pre>
</li>
</ul>
<p>ps:算法题中大部分操作都是头插法</p>
<h6 id="链表制造方式"><a href="#链表制造方式" class="headerlink" title="链表制造方式"></a>链表制造方式</h6><ol>
<li>结构体+指针（c++需要使用new，费时间）</li>
<li>数组模拟（这里是静态数组，用空间换时间）</li>
</ol>
<p>小tips：邻接表<strong>本质就是n个单链表拼起来</strong>，正常一个head对应一条链表，这个就是开了一个组，head[i]对应第i条链表</p>
<p>数组模拟链表</p>
<ol>
<li>单链表：邻接表（实际上n个链表），主要应用在于存储图和树</li>
<li>双链表：优化某些问题</li>
</ol>
<h6 id="单链表制作"><a href="#单链表制作" class="headerlink" title="单链表制作"></a>单链表制作</h6><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/828/" >826. 单链表 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<pre><code class="c++">//通用版本的静态链表  
//e[n]:某个点的值，ne[n]:某个点的指针，使用下标关联起来
const int n =1000010;

//e[i]节点i
//ne[i]节点i的next指针指向的值
//idx存储已经用过哪一个点
int head,e[n],ne[n],idx;
/*
这个的灵魂在于idx,有了idx可以保证无论新插的节点是头插还是尾插都没区别，都会用来计数，然后在对第k个进行操作的时候直接就定位到了idx
*/
void initial()
&#123;
    head=-1;//让head指向一个空的位置
    idx=0//idx数量实际上就是链表当中总共节点的数量
&#125;
void add_to_tail(int x)//尾插
&#123;
    e[idx]=x;
    if(head==-1//当是第一次插入时特殊处理
    &#123;
        ne[idx]=head;
        head=idx;
        idx++;
        return;
    &#125;
    int i=head;
    if(head!=-1)while(ne[i]!=-1)i=ne[i];//最后ne[i]=-1
    ne[idx]=-1;
    ne[i]=idx;
    idx++;
&#125;
void add_to_head(int x)//头插
&#123;
    e[idx]=x;//保存x的值到一个新的位置
    ne[idx]=head;//更新指向，新元素指向原先head的位置，也就是-1（第一次跑）
    head=idx;//head头节点更新位置，更新到新元素的下标
    idx++;//下一个新的元素
&#125;
void add(int k,int x)//注意和头插的区别在于位置变换的是ne[k]
&#123;
    k=k-1；//千万注意注意这里要改一下
        //否则会出范围的
        
        
    e[idx]=x;//先保存
    ne[idx]=ne[k];//指向原先k的位置
    ne[k]=idx;
    idx++;//说明加
&#125;
void delete(int k)//tm惊为天人的简洁版本
&#123;//这里是删除第k个添加的，并不是按照值来删除
    k=k-1；//千万注意注意这里要改一下
        //同样会出范围
        
        
    ne[k]=ne[ne[k]];//我tm直接更新ne[k]指向的位置，中间数直接损失指引
&#125;
void dele(int a)//这个是删除某一个特定值
       &#123;//一个问题是如果只有一个元素需要特判
           if(e[head]==a)head=ne[head];//直接清空就行
           else for(int i=head;ne[i]!=-1;i=ne[i])//多个元素时候的删除操作
           &#123;
               if(e[ne[i]]==a)//这里关系是跳过中间
               &#123;
                   ne[i]=ne[ne[i]];
               &#125;
          &#125;
       &#125;
void print()
&#123;
    for(int i=head;i!=-1;i=ne[i])//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）
    &#123;
        cout&lt;&lt;e[i]&lt;&lt;&#39; &#39;;
        cout&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<h6 id="双链表制作"><a href="#双链表制作" class="headerlink" title="双链表制作"></a>双链表制作</h6><pre><code class="c++">#include&lt;iostream&lt;
using namespace std;
const int M=20010;
int r[M],prev[M],e[M],index;
void initial()
&#123;
   //双链表相对单链表的初始化不同
   r[0]=1;//最左端指向最右端
   l[1]=0;//最右端指向最左端
   index=2;//另一个好处就是非常直白，双数肯定是向右的，单数向左的
&#125;
void add_to_right(int x,int k)//第k个的右边插入
&#123;
    e[idx]=x;
    r[idx]=r[k];
    l[idx]=k;
    //新节点的延申部位都搞定了，开始双向连接
    l[r[k]]=idx;
    r[k]=idx//
    idx++;
&#125;
//向右插就是
  add_to_right( x, k+1)//k+1因为index从2开始计数
//聪明的方法，在左边插入直接调用add_to_right(x,l[k]),也就是在k的左边节点调用向右插，结果就是第k个节点左边插入
add_to_right( x, l[k+1])//同理
//如果是最左端或者最右端更简单
//最左端
 add_to_right( x, 0)
 //右端
add_to_right( x, l[1])      
void dele(int k)
&#123;
    r[l[k]]=r[k];
    l[r[k]]=l[k];
&#125;
void print()
&#123;
    for(int i=r[0];i!=1;i=r[i])//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）
    &#123;
        cout&lt;&lt;e[i]&lt;&lt;&#39; &#39;;
        cout&lt;&lt;endl;
    &#125;
&#125;


//使用的时候的api：
    add_to_right( x, k+1)
    add_to_left(x,k+1)
    dele(k+1)
     第k个插入的数左边插入：add_to_right(x,l[k+1])
     第k个插入的数右边插入：add_to_right(x,k+1)
</code></pre>
<pre><code class="c++">//双向链表制作
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
struct Node&#123;
    char data;
    struct Node* next;
    struct Node* pre; 
&#125;;
struct Node*p;
struct Node*head;
struct Node*tail;
void Home()
&#123;
    p=head;
&#125;

void End()
&#123;
    p=tail-&gt;pre;
&#125;

void Left()
&#123;
    if(p==head) return;
    p=p-&gt;pre;
&#125;

void Right()
&#123;
    if(p-&gt;next==tail) return;
    p=tail-&gt;pre;
&#125;

void Back()
&#123;   
    if(p==head) return;
    struct Node*tmp=(struct Node*)malloc(sizeof(struct Node));
    tmp=p;
    tmp-&gt;pre-&gt;next=tmp-&gt;next;
    tmp-&gt;next-&gt;pre=tmp-&gt;pre;
    free(tmp);
&#125;
    

int main()&#123;
    char s[50010];
    int i;
    struct Node*head=(struct Node*)malloc(sizeof(struct Node));
    struct Node*tail=(struct Node*)malloc(sizeof(struct Node));
    struct Node*p=head;
    head-&gt;next=tail;
    tail-&gt;pre=head;
    tail-&gt;next=NULL;
    head-&gt;pre=NULL; 
    
    
    scanf(&quot;%s&quot;,s);
    
    
    for(i=0;s[i]!=&#39;\0&#39;;i++)
    &#123;
            
        if(s[i]==&#39;&#123;&#39;) Home();
        else if(s[i]==&#39;&#125;&#39;) End();
        else if(s[i]==&#39;&lt;&#39;) Left();
        else if(s[i]==&#39;&gt;&#39;) Right();
        else if(s[i]==&#39;#&#39;) Back();
        else
            &#123;
            struct Node*q=(struct Node*)malloc(sizeof(struct Node));
            q-&gt;data=s[i];
            q-&gt;pre=p;
            q-&gt;next=p-&gt;next;
            p-&gt;next-&gt;pre=q;
            p-&gt;next=q;
            p=p-&gt;next;
            &#125;	
            
    &#125;
    
    
    for(p=head-&gt;next;p!=tail;p=p-&gt;next)
    &#123;
        printf(&quot;%c&quot;,p-&gt;data);
    &#125;	

&#125;
</code></pre>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
const int M=100090;
int nex[M];
int pre[M];
int valu[M];
int idx;
void initial(void)
&#123;
   //双链表相对单链表的初始化不同
   nex[0]=1;//最左端指向最右端
   pre[1]=0;//最右端指向最左端
   idx=2;//另一个好处就是非常直白，双数肯定是向右的，单数向左的
&#125;
void add_to_right(int x,int k)
&#123;
    valu[idx]=x;
    nex[idx]=nex[k];
    pre[idx]=k;
    //新节点的延申部位都搞定了，开始双向连接
    pre[nex[k]]=idx;
    nex[k]=idx;//
    idx++;
&#125;
//更聪明的方法，在左边插入直接调用add_to_right(x,prev[k]),也就是在k的左边节点调用向右插

void dele(int k)
&#123;
    nex[pre[k]]=nex[k];
    pre[nex[k]]=pre[k];
&#125;
int main()
&#123;
    int tem;
    int index;
    int n;
    cin&gt;&gt;n;
    initial();
    for(int i=0;i&lt;n;i++)
    &#123;
        string a;
        cin&gt;&gt;a;
        if(a==&quot;D&quot;)
        &#123;
            cin&gt;&gt;index;
            dele(index+1);
        &#125;
        if(a==&quot;L&quot;)
        &#123;
            cin&gt;&gt;tem;
            add_to_right(tem,0);
        &#125;
        if(a==&quot;R&quot;)
        &#123;
            cin&gt;&gt;tem;
            add_to_right(tem,pre[1]);
        &#125;
        if(a==&quot;IL&quot; )
        &#123;
            cin&gt;&gt;index&gt;&gt;tem;
            add_to_right(tem,pre[index+1]);
        &#125;
        if(a==&quot;IR&quot; )
        &#123;
            cin&gt;&gt;index&gt;&gt;tem;
            add_to_right(tem,index+1);
        &#125;
    &#125;
    for(int i=nex[0];i!=1;i=nex[i])
    &#123;
        cout&lt;&lt;valu[i] &lt;&lt;&quot; &quot;;
    &#125;
    return 0;
&#125;

</code></pre>
<h6 id="链表递归与双指针"><a href="#链表递归与双指针" class="headerlink" title="链表递归与双指针"></a>链表递归与双指针</h6><p>应用：力扣19题</p>
<p>方法：未知链表长度情况下通过递归获取长度</p>
<p><strong>注意这种递归本质上是逆序进行扫描，从null扫描到head（不是空节点头，而是存放第一个值的头）</strong></p>
<p>读取顺序讲解：</p>
<p>以1234，2示例如有a,b,c,d四个节点，分别存放1，2，3，4（a是头4是尾，4-&gt;next&#x3D;NULL）</p>
<p>那么调用函数length时候会先一直向下扫描（因为未满足条件之前不会进行return），扫描到d的下一个节点null这时返回1-&gt;到达节点d，（<strong>因为有pos&#x3D;length(node-&gt;next,n)+1,+1导致从节点null返回d时候pos变成1</strong>）返回2（到达节点c），返回3（到达节点b），注意<strong>这时候满足倒序扫描到第三个了，也就是要删除的节点再向上回溯了1位</strong>,因此删除节点c,即node-&gt;next&#x3D;node-&gt;next-&gt;next**(b指向c变成b指向d)**</p>
<p>好处：时间少（只用扫描一次），空间少（没有额外开辟指针）</p>
<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public://尝试递归解决

    int length(ListNode *node,int n)//这一段千万千万注意是倒序，倒叙进行读取！！！
    &#123;
        if(node==NULL)return 0;//递归停止
        int pos=length(node-&gt;next,n)+1;
        if(pos==n+1)//进行判断了，说明在第几层递归
            node-&gt;next=node-&gt;next-&gt;next;
        return pos;//递归层层回溯
    &#125;
    
    
    
    
    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
        int pos =length(head,n);
        if(pos==n)return head-&gt;next;//链表总长度刚好等于倒退长度，即处理头节点情况
        return head;//
    &#125;
&#125;;
</code></pre>
<p>参考网址：<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/" >【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="同样利用递归实现链表逆序：（有那么一点点费脑子）"><a href="#同样利用递归实现链表逆序：（有那么一点点费脑子）" class="headerlink" title="同样利用递归实现链表逆序：（有那么一点点费脑子）"></a>同样利用递归实现链表逆序：（有那么一点点费脑子）</h6><h6 id="-1"><a href="#-1" class="headerlink" title=""></a><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif"
                      alt="img"
                ></h6><p>原理：链表自身带有递归属性（一个大问题可以拆解成小问题）</p>
<p>将链表拆分成头节点和剩余节点，同理继续拆解，一直拆解到最后的尾节点和前面的一堆“头”节点,<strong>最后一个节点不需要进行翻转</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457324-INLSje-image.png"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457360-ZminDz-image.png"
                      alt="image.png"
                ></p>
<p>这里就是对于子问题，将子链表进行翻转，就可以得到整个链表的反转，也就是递归的第一步</p>
<pre><code class="c++">public ListNode reverseList(ListNode head) &#123;
    // 调用递推公式反转当前结点之后的所有节点
    // 返回的结果是反转后的链表的头结点
    ListNode newHead = reverseList(head.next);
&#125;
</code></pre>
<p>这里假设后续子链表已经全部完成翻转，那么只需要对“头节点”完成翻转</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457400-xIhTwQ-image.png"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457409-hQkmzj-image.png"
                      alt="image.png"
                ></p>
<p>也就是</p>
<pre><code class="c++">head-&gt;next-&gt;neat=head;
head-&gt;next=NULL;
</code></pre>
<p>完善之后就是有</p>
<pre><code class="c++">public ListNode reverseList(ListNode head) &#123;
    // 调用递推公式反转当前结点之后的所有节点
    // 返回的结果是反转后的链表的头结点
    ListNode newHead = reverseList(head.next);
    //到这里已经是假设后面的链表部分已经全部反转完成，也就是只需要处理头节点和剩余部分的关系
    head.next.next = head;
    head.next = null;
    return newHead;//注意哦，这里返回的是newhead，因为newhead是反转之后的链表的头节点，即最尾部的节点
&#125;
</code></pre>
<p>再加上约束条件（递归终止条件）</p>
<pre><code class="c++">/*
if (head == NULL || head-&gt;next == NULL) &#123;//返回条件/结束递归条件
            return head;
        &#125;
   */

class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        if (head == NULL || head-&gt;next == NULL) &#123;//返回条件/结束递归条件
            return head;
        &#125;
        ListNode* ret = reverseList(head-&gt;next);//这里递归，ret会在走到链表末端开始翻转
        head-&gt;next-&gt;next = head;
        head-&gt;next = NULL;
        return ret;//
    &#125;
&#125;;
/*执行起来大概是这么一个既视感
</code></pre>
<h6 id="双指针实现逆序"><a href="#双指针实现逆序" class="headerlink" title="双指针实现逆序"></a>双指针实现逆序</h6><p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif"
                      alt="img"
                ></p>
<pre><code class="c++">class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* cur = NULL, *pre = head;
        while (pre != NULL) &#123;//终止条件，最后的指针pre走到末尾停止
            ListNode* temp = pre-&gt;next;
            pre-&gt;next = cur;//开始反置指针指向
            //cur和pre整体向前移动一个位置
            cur = pre;
            pre = temp;
        &#125;
        return cur;
    &#125;
&#125;;
</code></pre>
<p>原理：一开始创建两个指针pre和cur，pre指向head，cur指向null，tem有点类似指针交换数值中的tem，指向正常链表顺序的下一个节点（这里就是head-&gt;next），</p>
<hr>
<h6 id="有序链表的拼接（又是递归-x2F-bushi）"><a href="#有序链表的拼接（又是递归-x2F-bushi）" class="headerlink" title="有序链表的拼接（又是递归&#x2F;bushi）"></a><strong>有序链表的拼接（又是递归&#x2F;bushi）</strong></h6><p>时间复杂度：O(m+n)</p>
<pre><code class="c++">class Solution &#123;
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;
        if (l1 == NULL) &#123;//终止条件：l1走到末尾了
            return l2;
        &#125;
        if (l2 == NULL) &#123;//终止条件：l2走到末尾了
            return l1;//剩下的都弄上去就是
        &#125;
        
        //分割线
        if (l1-&gt;val &lt;= l2-&gt;val) &#123;
            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);//对l1的剩余部分进行一个递归操作
            //重点部分mergeTwoLists(l1-&gt;next, l2)，对l1后面的元素处理
        
            return l1;//因为L1的这个元素小，因此把它拎出来
        &#125;
        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);//对l2的剩余部分进行递归操作，l2-&gt;next同理
      
        return l2;//同理
    &#125;
&#125;;
</code></pre>
<pre><code class="c++">解释的一个部分

关于return L1的个人理解: 递归的核心在于,我只关注我这一层要干什么,返回什么,至于我的下一层(规模减1),我不管,我就是甩手掌柜.

好,现在我要merge L1,L2.我要怎么做?

- 显然,如果L1空或L2空,我直接返回L2或L1就行,这很好理解.//上方的两个NULL情况
- //如果L1第一个元素小于L2的? 那我得把L1的这个元素放到最前面,至于后面的那串长啥样 ,我不管. 我只要接过下级员工干完活后给我的包裹, 然后把我干的活附上去(令L1-&gt;next = 这个包裹)就行
- 这个包裹是下级员工干的活,即merge(L1-&gt;next, L2)

我该返回啥?

- 现在不管我的下一层干了什么,又返回了什么给我, 我只要知道,假设我的工具人们都完成了任务, 那我的任务也就完成了,可以返回最终结果了
- 最终结果就是我一开始接手的L1头结点+下级员工给我的大包裹,要一并交上去, 这样我的boss才能根据我给它的L1头节点往下找,检查我完成的工作
</code></pre>
<h6 id="回文链表判断：（映射，递归，翻转）"><a href="#回文链表判断：（映射，递归，翻转）" class="headerlink" title="回文链表判断：（映射，递归，翻转）"></a>回文链表判断：（映射，递归，翻转）</h6><p><strong>映射到数组上再对数组进行操作</strong></p>
<pre><code class="c++">class Solution &#123;
public:
    bool isPalindrome(ListNode* head) &#123;
        vector&lt;int&gt; vals;
        while (head != nullptr) &#123;
            vals.emplace_back(head-&gt;val);//使用迭代器更加节省时间一些，如果是数组会报错
            head = head-&gt;next;
        &#125;
        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;
            if (vals[i] != vals[j]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;
</code></pre>
<p><strong>优雅递归</strong></p>
<p>遍历节点的方式<strong>可是我看不懂</strong></p>
<pre><code class="c++">class Solution &#123;
    ListNode* frontPointer;//这个是前指针
public:
    bool recursivelyCheck(ListNode* currentNode) &#123;
        if (currentNode != nullptr) &#123;
            if (!recursivelyCheck(currentNode-&gt;next)) &#123;
                return false;
            &#125;
            if (currentNode-&gt;val != frontPointer-&gt;val) &#123;
                return false;
            &#125;
            frontPointer = frontPointer-&gt;next;
        &#125;
        return true;
    &#125;

    bool isPalindrome(ListNode* head) &#123;
        frontPointer = head;
        return recursivelyCheck(head);
    &#125;
&#125;;
</code></pre>
<p>解释：currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val !&#x3D; frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。<br>空间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。我们要理解计算机如何运行递归函数，在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 nn 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时空间复杂度要考虑堆栈的使用情况。<br>这种方法不仅使用了 O(n)O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。</p>
<p><strong>快慢指针</strong></p>
<p>很优雅**<del>但是我照样看不懂</del>***<strong>没想到吧老子看懂了哈哈哈哈哈哈哈</strong></p>
<pre><code class="c++">class Solution &#123;
public:
    bool isPalindrome(ListNode* head) &#123;
        if (head == nullptr) &#123;
            return true;
        &#125;

        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode* firstHalfEnd = endOfFirstHalf(head);//返回慢的那一半
        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);//对中间开始往右的第一个开始翻转

        // 判断是否回文
        ListNode* p1 = head;
        ListNode* p2 = secondHalfStart;
        bool result = true;
        while (result &amp;&amp; p2 != nullptr) &#123;
            if (p1-&gt;val != p2-&gt;val) &#123;
                result = false;
            &#125;
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        &#125;        

        // 还原链表并返回结果
        firstHalfEnd-&gt;next = reverseList(secondHalfStart);//为了保证链表本身不变，实际上可以省略（大概）
        return result;
    &#125;

    ListNode* reverseList(ListNode* head) &#123;//是你最爱的双指针翻转法
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) &#123;
            ListNode* nextTemp = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = nextTemp;
        &#125;
        return prev;
    &#125;

    ListNode* endOfFirstHalf(ListNode* head) &#123;//快慢指针，快的走俩，慢的走1，在中点停止
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123;
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
        &#125;
        return slow;
    &#125;
&#125;;
</code></pre>
<h4 id="zhan（栈）不是B站那个"><a href="#zhan（栈）不是B站那个" class="headerlink" title="zhan（栈）不是B站那个"></a>zhan（栈）不是B站那个</h4><h6 id="前言：-1"><a href="#前言：-1" class="headerlink" title="前言："></a>前言：</h6><p>栈属于一种FILO数据结构，类似阉割版本的顺序表，在计算机中有非常广泛的应用</p>
<p>例：使用递归时，编译器自身对于递归指令的使用就是一种栈，或者计算中缀表达式（通过将中缀表达式转换为后缀表达式，再对后缀表达式进行栈运算就可以得出结果）-&gt;全部利用栈的FILO结构</p>
<h6 id="栈制造方式"><a href="#栈制造方式" class="headerlink" title="栈制造方式"></a>栈制造方式</h6><ul>
<li>数组栈-&gt;非常非常easy</li>
<li>链表栈-&gt;参考链表，但是阉割</li>
</ul>
<h6 id="栈做非降路径问题"><a href="#栈做非降路径问题" class="headerlink" title="栈做非降路径问题"></a>栈做非降路径问题</h6><p>离散数学组合数学里面的东西，如果对一个栈仅允许出栈入栈操作，对输入固定长度字母求所有的输出模式，其实本质就是一个非降路径，只需要计算从(0,0)到(n,n)的不经过y&#x3D;x+1的所有路径</p>
<h6 id="中缀表达式转换后缀表达式"><a href="#中缀表达式转换后缀表达式" class="headerlink" title="中缀表达式转换后缀表达式"></a>中缀表达式转换后缀表达式</h6><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/wujing1_1/article/details/107774753?ops_request_misc=%7B%22request_id%22:%22166755340216782425667308%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166755340216782425667308&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-107774753-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80&spm=1018.2226.3001.4187" >(104条消息) 中缀表达式转后缀表达式的方法_說詤榢的博客-CSDN博客_中缀表达式转后缀表达式<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="正则表达式分析"><a href="#正则表达式分析" class="headerlink" title="正则表达式分析"></a>正则表达式分析</h6><p>分析：</p>
<ul>
<li><strong>使用栈来求：</strong>中缀表达式可以拆分成一棵中缀树，后缀类似拆分成后缀树，如（1+1）<em>（2+2），中缀中根节点是</em>，叶节点是+，叶子是1 1 2 2，如果用树的思想去做应该使用树的中序遍历，但是问题在于不好处理运算符的优先级问题，而改造成后缀表达式就会方便很多，如同上例子换成后缀表达式变成了1 1 + 2 2 + *，然后使用栈来进行运算，数字压栈，运算符出栈两个进行运算后再次压栈，这样就可以避开运算符优先级的处理问题（<del><strong>相对更好理解一些而且不需要搭建树，可以使用栈来搞</strong></del>）</li>
<li><strong>使用递归来求：</strong>已知将该表达式抽象成为一棵树，那么对每个子树使用递归求值可以不断削减树的层数，最后获得根树的值（**<del>很牛逼但是很麻烦，要提前接触到树</del>**）</li>
</ul>
<p>这里使用栈来进行一个中缀表达式的计算</p>
<p>先看下只有 + 和 * 的。</p>
<p>输入长度为n的字符串，例如：1+2+3<em>4</em>5</p>
<p>输出表达式的值，即：63</p>
<p>应该用什么数据结构？</p>
<p>栈。</p>
<p>应该先计算哪一步？</p>
<p>实际应该先计算1+2。</p>
<p>“表达式求值”问题，两个核心关键点：</p>
<p>（1）双栈，一个操作数栈，一个运算符栈；</p>
<p>（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：</p>
<p>如果栈顶的运算符优先级低，新运算符直接入栈</p>
<p>如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈</p>
<p>仍以1+2+3<em>4</em>5举例，看是如何利用上述两个关键点实施计算的。</p>
<p>首先，这个例子只有+和*两个运算符，所以它的运算符表是：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_095276ee89-00.webp.jpg"
                      alt="00.webp.jpg"
                ></p>
<p>这里的含义是：</p>
<p>（1）如果栈顶是+，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；</p>
<p>（2）如果栈顶是+，即将入栈的是*，栈顶优先级低，直接入栈；</p>
<p>（3）如果栈顶是*，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；</p>
<p>（4）如果栈顶是<em>， 即将入栈的是</em>，栈顶优先级高，需要先计算，再入栈；</p>
<p>有了运算符表，一切就好办了。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_0d357dc289-01.webp.jpg"
                      alt="01.webp.jpg"
                ></p>
<p>一开始，初始化好输入的字符串，以及操作数栈，运算符栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_10cc705789-02.webp.jpg"
                      alt="02.webp.jpg"
                ></p>
<p>一步步，扫描字符串，操作数一个个入栈，运算符也入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_14359ecb89-3.png"
                      alt="3.png"
                ></p>
<p>下一个操作符要入栈时，需要先比较优先级。</p>
<p>栈内的优先级高，必须先计算，才能入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_17b96fe289-4.webp.jpg"
                      alt="4.webp.jpg"
                ></p>
<p>计算的过程为：</p>
<p>（1）操作数出栈，作为num2；</p>
<p>（2）操作数出栈，作为num1；</p>
<p>（3）运算符出栈，作为op；</p>
<p>（4）计算出结果；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_1b6cac1c89-5.webp.jpg"
                      alt="5.webp.jpg"
                ></p>
<p>（5）结果入操作数栈；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_1ed49bd989-6.png"
                      alt="6.png"
                ></p>
<p>接下来，运算符和操作数才能继续入栈。下一个操作符要入栈时，继续比较与栈顶的优先级。</p>
<p>栈内的优先级低，可以直接入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_21bfcd8989-7.png"
                      alt="7.png"
                ></p>
<p>字符串继续移动。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_26237d8e89-8.png"
                      alt="8.png"
                ></p>
<p>又要比较优先级了。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_28e8139389-9.webp.jpg"
                      alt="9.webp.jpg"
                ></p>
<p>栈内的优先级高，还是先计算（3*4&#x3D;12），再入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_2c8291c589-10.png"
                      alt="10.png"
                ></p>
<p>不断入栈，直到字符串扫描完毕。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_2e61c67089-11.webp.jpg"
                      alt="11.webp.jpg"
                ></p>
<p>不断出栈，直到得到最终结果3+60&#x3D;63，算法完成。</p>
<p>总结</p>
<p>“表达式求值”问题，两个核心关键点：</p>
<p>（1）双栈，一个操作数栈，一个运算符栈；</p>
<p>（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：<br>如果栈顶的运算符优先级低，新运算符直接入栈</p>
<p>如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈</p>
<p>这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。</p>
<p>运算符有+-<em>&#x2F;()~^&amp;都没问题，如果共有n个运算符，会有一个n</em>n的优先级表。</p>
<h6 id="正则表达式代码"><a href="#正则表达式代码" class="headerlink" title="正则表达式代码"></a>正则表达式代码</h6><p>代码：</p>
<p><strong>上       代        码</strong></p>
<p><del>虽然但是接下来这个代码是中缀计算的</del></p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;stack&gt;//stl库中使用栈
#include &lt;string&gt;//
#include &lt;unordered_map&gt;//一个目前不太懂的头文件，回头看primer自己理解吧
using namespace std;

stack&lt;int&gt; num;//存储数字的栈
stack&lt;char&gt; op;//存储运算符的栈

//优先级表
unordered_map&lt;char, int&gt; h&#123; &#123;&#39;+&#39;, 1&#125;, &#123;&#39;-&#39;, 1&#125;, &#123;&#39;*&#39;,2&#125;, &#123;&#39;/&#39;, 2&#125; &#125;;


void eval()//求值
&#123;
    int a = num.top();//第二个操作数
    num.pop();

    int b = num.top();//第一个操作数
    num.pop();

    char p = op.top();//运算符
    op.pop();

    int r = 0;//结果 

    //计算结果
    if (p == &#39;+&#39;) r = b + a;
    if (p == &#39;-&#39;) r = b - a;
    if (p == &#39;*&#39;) r = b * a;
    if (p == &#39;/&#39;) r = b / a;

    num.push(r);//结果入栈到num中
&#125;

int main()
&#123;
    string s;//读入表达式
    cin &gt;&gt; s;

    for (int i = 0; i &lt; s.size(); i++)//调用了string的函数s.size()
    &#123;
        if (isdigit(s[i]))//判断数字入栈
        &#123;
            int x = 0, j = i;//计算数字
            while (j &lt; s.size() &amp;&amp; isdigit(s[j]))
            &#123;
                x = x * 10 + s[j] - &#39;0&#39;;//将string型的数字转换为int？
                j++;
            &#125;
            num.push(x);//数字入栈
            i = j - 1;
        &#125;
        //左括号无优先级，直接入栈
        else if (s[i] == &#39;(&#39;)//左括号入栈
        &#123;
            op.push(s[i]);
        &#125;
        //括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的
        else if (s[i] == &#39;)&#39;)//右括号
        &#123;
            while(op.top() != &#39;(&#39;)//一直计算到左括号
                eval();
            op.pop();//左括号出栈
        &#125;
        else
        &#123;
            while (op.size() &amp;&amp; h[op.top()] &gt;= h[s[i]])//待入栈运算符优先级低，则先计算
                eval();
            op.push(s[i]);//操作符入栈
        &#125;
    &#125;
    while (op.size()) eval();//剩余的进行计算
    cout &lt;&lt; num.top() &lt;&lt; endl;//输出结果
    return 0;
&#125;
</code></pre>
<h6 id="单调栈（瞳孔地震型题解）😢"><a href="#单调栈（瞳孔地震型题解）😢" class="headerlink" title="单调栈（瞳孔地震型题解）😢"></a>单调栈（瞳孔地震型题解）😢</h6><p>使用单调递增栈</p>
<p>麻烦地方：超时</p>
<p>考虑方式有些类似双指针</p>
<p>思路：<strong>暴力</strong>-&gt;优化暴力</p>
<p>队列里面是否有元素没用</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/20201211221031165.gif"
                      alt="在这里插入图片描述"
                ></p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
const int N=10010;
int n;
int stk[N],tt;
int main()
&#123;
    cin&gt;&gt;n;//总共要输入几次数
    for(int i=0;i&lt;n;i++)
    &#123;
        int x;
        cin&gt;&gt;x;
        while(tt&amp;&amp;stk[tt]&gt;=x)tt--;//如果栈内元素只要比待进入元素小就弹出
        if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;//弹出后输出第一个栈顶元素
        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;//栈空后输出-1
        stk[++tt]=x;//一轮走下来以后新的元素入栈
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>FIFO构造</p>
<h6 id="队列构造方式："><a href="#队列构造方式：" class="headerlink" title="队列构造方式："></a>队列构造方式：</h6><p>数组构造（也是hin简单就是了）😒</p>
<pre><code class="c++">//模板用栈直接改都可以
const int M=200600;

int bottom=0;//队列底部，弹出时候bottom+1
int line[M]=&#123;0&#125;;
int top=0;//队列头部，增加时候top+1
void insert(int x)//入队
&#123;
    
    line[top]=x;
    ++top;
&#125;
void pop(void)
&#123;
    bottom++;//底部上移
&#125;
void query(void)
&#123;
   cout&lt;&lt;line[bottom]&lt;&lt;endl;
   return;
&#125;
void empty(void)
&#123;
    if(top==bottom)cout&lt;&lt;&quot;YES\n&quot;;
    else cout&lt;&lt;&quot;NO\n&quot;;
    return;
&#125;
</code></pre>
<h6 id="循环队列："><a href="#循环队列：" class="headerlink" title="循环队列："></a>循环队列：</h6><p>模板：</p>
<pre><code class="c++">// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;//如果到达某一特定值那么就重置变成队头

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)//不为空
&#123;

&#125;
</code></pre>
<h6 id="单调队列-～￣▽￣-～滑动窗口经典（配合单调栈食用）"><a href="#单调队列-～￣▽￣-～滑动窗口经典（配合单调栈食用）" class="headerlink" title="单调队列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）"></a>单调<del>队</del>列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）</h6><p>😶‍🌫️准备好开始头疼</p>
<p>思路同单调栈：从暴力解决入手接着开始优化</p>
<p>可以使用队列对窗口进行维护（标准的入列和出列）</p>
<p>优化：<strong>队列中是否有没用的元素，对没用的元素进行删除看能否得到单调性</strong>，如3，-1，-3，在-3入列的时候就有3&gt;-3，则最小值一定不会是3而且-3存在时间更久，因此使用单调栈的同样原理可以求出单调最小，并且是一个单调递增的最小</p>
<p>可以使用STL标准库来写或者说使用栈和队列数组模拟去写，而相对而言使用数组有很大的好处在于数组速度快，在比赛或者笔试时候会慢一些，在IDE中可能会有O2或者O3优化</p>
<p>再看一遍单调栈</p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
const int N=10010;
int n;
int stk[N],tt;
int main()
&#123;
    cin&gt;&gt;n;//总共要输入几次数
    for(int i=0;i&lt;n;i++)
    &#123;
        int x;
        cin&gt;&gt;x;
        while(tt&amp;&amp;stk[tt]&gt;=x)tt--;//如果栈内元素只要比待进入元素大就弹出
        if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;//弹出后输出第一个栈顶元素
        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;//栈空后输出-1
        stk[++tt]=x;//一轮走下来以后新的元素入栈
    &#125;
    return 0;
&#125;
</code></pre>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/20201211221031165.gif"
                      alt="在这里插入图片描述"
                ></p>
<p>解题思路（以最大值为例）：</p>
<p>由于我们需要求出的是滑动窗口的最大值。</p>
<p>如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i&lt;j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：</p>
<p>当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。</p>
<p>因此，<strong>由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。</strong></p>
<p>因此我们可以使用一个队列存储<strong>所有还没有被移除的下标，这里是q</strong>。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。</p>
<p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。</p>
<p>为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，<strong>那么队尾的元素就可以被永久地移除</strong>，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p>
<p>由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。</p>
<p>窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。</p>
<p>每一个窗口的最大值</p>
<pre><code class="c++">hh = 0; tt = -1;          //头在左尾在右                         // 重置！
    for (int i = 0; i &lt; n; ++ i)
        //注意这个栈可以想成朝着右边（tt，正常栈操作），但是底部可以操作（hh，向右缩）
    &#123;
        //窗口终点是i，那么起点就是i-k+1
        if (i - k + 1 &gt; q[hh]) ++ hh;//窗口左边向右移动一个
        
        //这里操作下来要是从大到小的排列
        
        while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;//右边已经有更大的了，之前的小的a[q[tt]]可以不用考虑了，就操作tt
        q[++ tt] = i;//窗口右边向右移动一个
        //i+1&gt;=k这里就是一个特判，因为一开始窗口没有值，只有窗口全部充满之后才有后面的操作
        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);//这里知道栈的底部（也就是q[hh]）对应的下标是该窗口中没有删除而且是最大的
    &#125;
</code></pre>
<p>判断最小</p>
<pre><code class="c++">int a[N]=&#123;0&#125;;
int q[N]=&#123;0&#125;;
int hh=0;
int tt = -1;//尾部是1
int n, k;//hh是头，tt是尾，
//

//头在左尾在右



    cin &gt;&gt; n &gt;&gt; k;//k是窗口大小
    for (int i = 0; i &lt; n; ++ i)
    &#123;
        //这里是关于窗口的维护
        scanf(&quot;%d&quot;, &amp;a[i]);//数组a存放了所有的数字
        if (i - k + 1 &gt; q[hh]) ++ hh;       
        //数组q存放的是下标
        // 若队首出窗口，hh加1，即整体向前移动一格
        
        //这里开始跟单调栈的原理相同
        /*
        hh&lt;=tt是队列不为空
        a[i] &lt;= a[q[tt]]这里就是单调栈的如果新来的a[i]不是栈里面最大的就弹栈，--tt
        */
        while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1
        q[++ tt] = i;                                  // 下标加到队尾，新元素入栈，上面入的是元素本身这里入的是元素下标
        
        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);       // 这里确定过栈中的都是最小的元素了因此直接输出
        //输出结果
    &#125;
    cout &lt;&lt; endl;//换行
</code></pre>
<p>全部代码！</p>
<pre><code class="c++"># include &lt;iostream&gt;
using namespace std;
const int N = 1000010;
int a[N], q[N], tail = -1;
int head=0;
//a存储正常原数组的值
//注意注意q存储的是a的“下标”，“下标”而不是“值”
int main()
&#123;
    int n, k;//hh是头，tt是尾
    cin &gt;&gt; n &gt;&gt; k;
    for (int i = 0; i &lt; n; ++ i)//输出最小，每一次循环里面q[head]的值也就是a[q[head]]总是窗口中最小的
    &#123;
        //i-k+1就是窗口头部位置
        scanf(&quot;%d&quot;, &amp;a[i]);
        if (i - k + 1 &gt; q[head]) ++ head;                  // 若队首出窗口，head加1
        while (head &lt;= tail &amp;&amp; a[i] &lt;= a[q[tail]]) -- tail;    // 若队尾不单调，tail持续减1
        q[++ tail] = i;                                  // 下标加到队尾,尾部进入窗口
        if (i-k + 1 &gt;= 0) printf(&quot;%d &quot;, a[q[head]]);       // 输出结果(只有窗口形成之后才会输出)
    &#125;
    cout &lt;&lt; endl;
    head = 0; tail = -1;                                   // 重置！
    for (int i = 0; i &lt; n; ++ i)
    &#123;
        if (i - k + 1 &gt; q[head]) ++ head;				//判断头部是否出窗口
        while (head &lt;= tail &amp;&amp; a[i] &gt;= a[q[tail]]) -- tail;
        q[++ tail] = i;
        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[head]]);
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><h5 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>K<del>M</del>P</h5><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46007276/article/details/104372119?ops_request_misc=%7B%22request_id%22:%22166616507616781432932798%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166616507616781432932798&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104372119-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1&utm_term=kmp%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187" >(100条消息) 数据结构KMP算法配图详解（超详细）_哈顿之光的博客-CSDN博客_kmp算法难吗是什么级别<i class="fas fa-external-link-alt"></i></a>（<strong>好好看好好学</strong>）</p>
<h6 id="模板y总"><a href="#模板y总" class="headerlink" title="模板y总"></a>模板y总</h6><p><strong>注意kmp算法的下标要从1开始弄！</strong></p>
<pre><code class="c++">for(int i=1;i&lt;=n;i++)//一开始就是1开始弄的
&#123;
    cin&gt;&gt;p[i];
&#125;

或者邪教读取法:cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1

// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i &lt;= m; i ++ )//与匹配部分基本一样一样
&#123;//一点细节，这里是子串p
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];//也是回溯
    if (p[i] == p[j + 1]) j ++ ;//匹配成功子串向前走
    ne[i] = j;//欸，这里不一样了，
    //ne数组其实也是一样样的，i=2是因为实际上1是肯定是0（前面都没字符自然是0），ne数组也是从1开始
&#125;

// kmp匹配
for (int i = 1, j = 0; i &lt;= n; i ++ )//
&#123;//一点细节，下面是长串s
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];//不相等的时候递归回退，与代码随想录是一种方法
    if (s[i] == p[j + 1]) j ++ ;//如果匹配成功，子串也向前一位走
    if (j == m)
    &#123;
        j = ne[j];//回溯到前一次
        // 匹配成功后的逻辑
    &#125;
&#125;

</code></pre>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
const int N=100010,M=1000010;
char p[N],s[M];
int ne[N];
int n,m;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;
    for(int i=2,j=0;i&lt;=n;i++)
    &#123;
        while(j&amp;&amp;p[i]!=p[j+1])j=ne[j];
        if(p[i]==p[j+1])j++;
        ne[i]=j;
    &#125;
    for(int i=1,j=0;i&lt;=m;i++)
    &#123;
        while(j&amp;&amp;s[i]!=p[j+1])j=ne[j];
        if(s[i]==p[j+1])j++;
        if(j==n)
        &#123;
            cout&lt;&lt;i-n&lt;&lt;&#39; &#39;;//就是输出下标
            j=ne[j];
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>关键：<strong>特殊数组next的构造</strong>，<strong>前缀表</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221019194121.gif"
                      alt="微信图片_20221019194121"
                ></p>
<p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了</strong></p>
<h6 id="前缀表：字符串的最长"><a href="#前缀表：字符串的最长" class="headerlink" title="前缀表：字符串的最长"></a>前缀表：字符串的最长</h6><p>前缀：不包含尾字符的所有子串</p>
<p>后缀：相较于前缀，不包含首字母的所有子串</p>
<p>因此如果仅有单个字符则其前缀为0</p>
<p>特性：</p>
<p>目前讲解的构造方法</p>
<p>例：子串aabaabaaf，前缀表010120(aabaaf)</p>
<ul>
<li>前缀形式：010120</li>
<li>全部后移方式：-1 0 10120</li>
<li>整体减一方式：-1 0 -1 0 1 -1</li>
</ul>
<p>共同点：最后都应当保持封闭，虽然理解有出入但本质相同</p>
<h6 id="代码随想录方法：前缀不减形式"><a href="#代码随想录方法：前缀不减形式" class="headerlink" title="代码随想录方法：前缀不减形式"></a>代码随想录方法：前缀不减形式</h6><p>prev,latter;</p>
<p>prev:<strong>前缀末尾位置</strong>，同时代表<em><strong>prev包括prev之前子串最长相等前后缀的长度，也表示前缀末尾</strong></em></p>
<p>latter:<strong>后缀末尾位置</strong></p>
<p>初始化</p>
<pre><code class="c++">prev=0;
latter=1;
next[0]=0;
//初始化latter
</code></pre>
<p>开始处理前后缀不同情况</p>
<pre><code class="c++">
//prev和latter一直不相等
for(latter=1;latter&lt;slength;latter++)//后缀指针只管往前走就完事
&#123;
    //这里if是出错的根源
    while(s[prev]!=s[latter]&amp;&amp;prev&gt;0)//注意这里因为有-1存在所以一定小心越界，
    &#123;
        prev=next[prev-1];//prev冲突时候是一个连续回退的过程，如果使用if就错了，使用while循环回退
    &#125;
    //只要s[latter]!=s[prev]时候prev应该向前回退
    //原因：使用前缀表在进行kmp对比的时候如果遇到冲突，也是看冲突位置前一位的表进行跳转
    
    分界线：前后缀相同的情况
        if(s[prev]==s[latter])
        &#123;
            prev++;//代表prev之前最长相等前缀可以更新
           
           //latter因为有for循环，因此自然向前有++操作
        &#125;
         next[latter]=prev;//更新next数组的值
    
    
&#125;
</code></pre>
<p>这里则是全部操作的部分</p>
<pre><code class="c++">    void getNext(int* next, const string&amp; s) &#123;
        int j = 0;
        next[0] = 0;
        for(int i = 1; i &lt; s.size(); i++) &#123;
            while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123;
                j = next[j - 1];
            &#125;
            if (s[i] == s[j]) &#123;
                j++;
            &#125;
            next[i] = j;
        &#125;
    &#125;
//这里是返回第一个找到的下标
    int strStr(string haystack, string needle) &#123;
        if (needle.size() == 0) &#123;
            return 0;
        &#125;
        int next[needle.size()];
        getNext(next, needle);//获取next数组
        int j = 0;
        for (int i = 0; i &lt; haystack.size(); i++) &#123;
            while(j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;
                j = next[j - 1];//一样进行回溯
            &#125;
            if (haystack[i] == needle[j]) &#123;
                j++;
            &#125;//使用循环，直接对prev进行+就行
            if (j == needle.size() ) &#123;
                return (i - needle.size() + 1);
            &#125;
        &#125;
        return -1;
    &#125;
</code></pre>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221019194410.gif"
                      alt="微信图片_20221019194410"
                ></p>
<p>注意这里是文本串和模式串不匹配时候的操作（这里next数组采用正常前缀表）</p>
<h6 id="数据结构作业出错原因"><a href="#数据结构作业出错原因" class="headerlink" title="数据结构作业出错原因"></a>数据结构作业出错原因</h6><p>要求每一个都求出来</p>
<p>问题在于：当每一次<strong>满足条件后进行清零操作</strong>，<em><strong>本质上同一次两者不等时候的回溯操作（prev到上一位最接近的前缀位置）</strong></em>,如果使用prev&#x3D;0就会出现可能错过</p>
<pre><code class="c++">例：
    ababa  aba 001
    //正确解
    if(prev==sublength)
        &#123;
            cout&lt;&lt;endl&lt;&lt;latter-sublength+1&lt;&lt;endl;
            prev=next[prev-1];//回溯
        &#125;
    //在第一次解的时候prev=3;latter=2(因为latter在一次循环之后才会有增操作)
    /*
    使用回溯prev=1,sub[prev]=b那么就接着从latter=3.T[latter]=b无缝开始向前对比
    */

/错误
    if(prev==sublength)
        &#123;
            cout&lt;&lt;endl&lt;&lt;latter-sublength+1&lt;&lt;endl;
            prev=0;//这样就会是错误结果
        &#125;
</code></pre>
<h5 id="automata-有限状态自动机"><a href="#automata-有限状态自动机" class="headerlink" title="automata~有限状态自动机"></a>automata~有限状态自动机</h5><p>参考：</p>
<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/tyler_download/article/details/52549315?ops_request_misc=%7B%22request_id%22:%22166619414916782414994917%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166619414916782414994917&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-52549315-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1&utm_term=%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA&spm=1018.2226.3001.4187" >(100条消息) 字符串匹配算法之：有限状态自动机_tyler_download的博客-CSDN博客_有限自动机算法<i class="fas fa-external-link-alt"></i></a></li>
<li>苏老师坚果云ppt状态机代码部分</li>
</ul>
<h6 id="代码（构建自动机状态表）"><a href="#代码（构建自动机状态表）" class="headerlink" title="代码（构建自动机状态表）"></a>代码（构建自动机状态表）</h6><pre><code class="c++">dfa[0][P[0]] = 1; //初始化第一行
// dfa[状态][下一个字符] for(int X = 0, j = 1; j &lt; plen; j++) &#123;

// 计算 dfa[j][]

for(int c = 0; c &lt; R; c++) &#123; // R 为字符种类数量

dfa[j][c] = dfa[X][c];

&#125; dfa[j][P[j]] = j + 1; X = dfa[X][P[j]]

&#125;
</code></pre>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-20%20194911.png"
                      alt="屏幕截图 2022-10-20 194911"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-20%20195102.png"
                      alt="屏幕截图 2022-10-20 195102"
                ></p>
<h6 id="聪明版本自动机"><a href="#聪明版本自动机" class="headerlink" title="聪明版本自动机"></a>聪明版本自动机</h6><p>已知ascii码总共就128个，直接开一个大表就行</p>
<pre><code class="c++">int dfa[256][256]=0;//这样直接省略后续一系列初始化，使用int转换字符串传入就行，非常省心
</code></pre>
<h5 id="TRIE树（有些类似哈夫曼树编码）"><a href="#TRIE树（有些类似哈夫曼树编码）" class="headerlink" title="TRIE树（有些类似哈夫曼树编码）"></a>TRIE树（有些类似哈夫曼树编码）</h5><p>类似但和哈夫曼树没有关系</p>
<p>又称字典树、单词查找树</p>
<p>应用：快速存储和查找字符串集合的数据结构</p>
<h6 id="如何存储：构建串树"><a href="#如何存储：构建串树" class="headerlink" title="如何存储：构建串树"></a>如何存储：构建串树</h6><p>从根节点开始存储每一个字符，开始逐个向下进行创建，在单词的末尾打上一个标记表示该单词走到结尾了</p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-24%20202126.png"
                      alt="屏幕截图 2022-11-24 202126" style="zoom:33%;" 
                >

<p><strong>TRIE树本质是一颗N叉树，有多少种字符一个节点就最多有多少条边</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/31041_aed49a42ad-Trie2.PNG"
                      alt="Trie2.PNG"
                ></p>
<h6 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h6><p>从单词的首字母开始向下走，走到标记表示到头了</p>
<h6 id="构建TRIE树"><a href="#构建TRIE树" class="headerlink" title="构建TRIE树"></a>构建TRIE树</h6><p>这里使用了数组模拟树的知识</p>
<pre><code class="c++">#include &lt;iostream&gt;

using namespace std;

const int N = 100010;

int son[N][26];
//这里是26因为只有小写字母
//二维是可以有多少个分支，一维的意义是来自哪一个双亲节点
int cnt[N], idx;//idx是下标为0的点，是根节点和空节点，表示当前要插入的节点是第几个,每创建一个节点值+1
   // cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）
char str[N];//存储要插入/查询的单词

void insert(char *str)
&#123;
    int p = 0; //类似指针，指向当前节点
    for (int i = 0; str[i]; i ++ )
    &#123;
        int u = str[i] - &#39;a&#39;;//u表示是具体哪一个字母
        //p表示的是第几个结点，u表示的是哪个字母，如果s[p][u]不为空就证明有以这个字母为值的子结点
        //它代表的值就是指向了该子结点，即说明了第几个结点是它的子结点
         //如s[2][1]=3，表示结点2有一个值为b（第二个数字代表的是a～z）的子结点，是结点3
        if (!son[p][u]) son[p][u] = ++ idx;//不存在就创建节点
        //令p指向子结点
        p = son[p][u];
    &#125;
    //不管是未存在过的新插入还是已有字典再增加一个，都是以这个结点为末尾的字符串次数加1
    cnt[p] ++ ;//结束时的标记，也是记录以此节点结束的字符串个数
    //这一步重要！
    
    
&#125;

int query(char *str)
&#123;
    int p = 0;
    for (int i = 0; str[i]; i ++ )//走到该单词为0
    &#123;
        int u = str[i] - &#39;a&#39;;//获得对应子节点的编号
        if (!son[p][u]) return 0;
        p = son[p][u];
    &#125;
    return cnt[p];//返回以p为结尾的单词数量
&#125;

int main()//这里有I是插入字符串，其它是查找该字符串
&#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    while (n -- )
    &#123;
        char op[2];
        scanf(&quot;%s%s&quot;, op, str);//前一次输入被覆盖
        if (*op == &#39;I&#39;) insert(str);
        else printf(&quot;%d\n&quot;, query(str));
    &#125;

    return 0;
&#125;
</code></pre>
<h5 id="TRIE树的其它应用"><a href="#TRIE树的其它应用" class="headerlink" title="TRIE树的其它应用"></a>TRIE树的其它应用</h5><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF" >https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF<i class="fas fa-external-link-alt"></i></a></p>
<p>启示：<strong>字典树不单单可以高效存储和查找字符串集合，还可以存储二进制数字</strong></p>
<h6 id="思路：利用二叉树"><a href="#思路：利用二叉树" class="headerlink" title="思路：利用二叉树"></a>思路：利用二叉树</h6><p><strong>对所有的aiaj建立一个串数组，对于每一个固定的ai，每一次尽量与和当前不同的分支向下走，走到底这样一定就可以得到最优解</strong></p>
<p>即顺序：所有值的二进制表示建立树-&gt;遍历一次，每一个ai进行寻找对应的最大的值，最后遍历一次之后获得答案</p>
<h6 id="算法复杂度："><a href="#算法复杂度：" class="headerlink" title="算法复杂度："></a>算法复杂度：</h6><p>（建立树）+n（每一个ai只需要在已经建立好的树再从头到尾走一次就好）</p>
<h6 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h6><p>insert函数改：</p>
<p>每个数看作一个31位长度的二进制数，最高位是0往0走，最高位1往1走，然后和类似TRIE的操作，但是构建的是一颗二叉树（一定概率变成斜树）</p>
<pre><code class="c++">void insert(int x)
&#123;
    int p=0;  //根节点
    for(int i=30;i&gt;=0;i--)//从最大位开始建立
    &#123;
        int u=x&gt;&gt;i&amp;1;   /////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)
        if(!son[p][u]) son[p][u]=++idx; ///如果插入中发现没有该子节点,开出这条路
        p=son[p][u]; //指针指向下一层
    &#125;//与上面不一样这里就不需要标记
&#125;
</code></pre>
<pre><code class="c++">int search(int x)
&#123;
    int p=0;int res=0;
    for(int i=30;i&gt;=0;i--)
    &#123;                               ///从最大位开始找
        int u=x&gt;&gt;i&amp;1;
        if(son[p][!u]) ////如果当前层有对应的不相同的数
        &#123;   ///p指针就指到不同数的地址

          p=son[p][!u];
          res=res*2+1;//右移，因为树右儿子是1
             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001
        &#125;                                                   ///       010 
        else////   ---&gt;011                                                                           
            //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1
        &#123;
            p=son[p][u];
            res=res*2+0;//左移，因为树左儿子是1
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int const N=100010,M=31*N;//M表示树的节点个数，每个数最多有31个长度，因此建立
int n;
int a[N];
int son[M][2],idx;
//M代表一个数字串二进制可以到多长

void insert(int x)
&#123;
    int p=0;  //根节点
    for(int i=30;i&gt;=0;i--)//这里相等i&gt;=0
    &#123;
        int u=x&gt;&gt;i&amp;1;   /////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)
        if(!son[p][u]) son[p][u]=++idx; ///如果插入中发现没有该子节点,开出这条路
        p=son[p][u]; //指针指向下一层
    &#125;
&#125;
int search(int x)
&#123;
    int p=0;int res=0;
    for(int i=30;i&gt;=0;i--)
    &#123;                               ///从最大位开始找
        int u=x&gt;&gt;i&amp;1;
        if(son[p][!u]) ////如果当前层有对应的不相同的数
        &#123;   ///p指针就指到不同数的地址

          p=son[p][!u];
          res=res*2+1;
             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001
        &#125;                                                       ///       010 
        else                                            ////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1
        &#123;
            p=son[p][u];
            res=res*2+0;
        &#125;
    &#125;
    return res;//最后返回是十进制形态的答案
&#125;
int main(void)
&#123;
    cin&gt;&gt;n;
    idx=0;
    for(int i=0;i&lt;n;i++)
    &#123;
        cin&gt;&gt;a[i];
        insert(a[i]);
    &#125;
    int res=0;
    for(int i=0;i&lt;n;i++)
    &#123;   
        res=max(res,search(a[i]));  ///search(a[i])查找的是a[i]值的最大与或值
    &#125;
    cout&lt;&lt;res&lt;&lt;endl;
&#125;
</code></pre>
<h4 id="跳表——同样面试——但是不用手搓"><a href="#跳表——同样面试——但是不用手搓" class="headerlink" title="跳表——同样面试——但是不用手搓"></a>跳表——同样面试——但是不用手搓</h4><h6 id="一些参考的博客："><a href="#一些参考的博客：" class="headerlink" title="一些参考的博客："></a>一些参考的博客：</h6><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/yjw123456/article/details/105159817?ops_request_misc=%7B%22request_id%22:%22166720710116782395320448%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166720710116782395320448&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105159817-null-null.142%5Ev62%5Epc_search_tree,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=%E8%B7%B3%E8%A1%A8&spm=1018.2226.3001.4187" >(101条消息) 十分钟弄懂什么是跳表，不懂可以来打我_愤怒的可乐的博客-CSDN博客_跳表<i class="fas fa-external-link-alt"></i></a></p>
<p>优点：<strong>将链表查找的时间复杂度改造成log</strong>，<strong>据说可以取代红黑树</strong></p>
<p>跳表属于对<strong>链表</strong>的改进</p>
<p>有点相似kmp？通过一些手段加快跳跃的速度</p>
<p>想法：链表中增加一些“超级链接”</p>
<h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><ul>
<li>跳表结合了链表和二分查找的思想</li>
<li>由原始链表和一些通过“跳跃”生成的链表组成</li>
<li><strong>第0层是原始链表，越上层“跳跃”的越高，元素越少</strong></li>
<li>上层链表是下层链表的子序列</li>
<li>查找时从顶层向下，不断缩小搜索范围</li>
<li><strong>每一层增长哪一个节点实际上是随机生长的</strong></li>
</ul>
<h6 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h6><ul>
<li>跳表节点中用数组存储不同层级的下一个节点</li>
<li>随即生长</li>
<li>空间使用率最高的跳表</li>
</ul>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="构建过程："><a href="#构建过程：" class="headerlink" title="构建过程："></a>构建过程：</h6><p>初始化和单链表一样，仅有一个空节点，</p>
<pre><code class="c++">private class Node &#123;
    //保存值
    E data;
    //保存了每一层上的节点信息，可能为null
    List&lt;Node&gt; forwards;

    Node(E data) &#123;
        this.data = data;
        forwards = new ArrayList&lt;&gt;();
        //事先把每一层都置为null，虽然空间利用率没那么高，但是简化了实现
        //也可以通过自定义列表(比如B树实现中用到的Vector)来实现，就可以不用下面的操作
        for (int i = 0; i &lt;= maxLevel; i++) &#123;
            forwards.add(null);
        &#125;
    &#125;

    @Override
    public String toString() &#123;
        return data == null ? &quot; &quot; : &quot;&quot; + data;
    &#125;

    /**
     * 得到当前节点level层上的下一个(右边一个)节点
     *
     * @param level
     * @return
     */
    Node next(int level) &#123;
        return this.forwards.get(level);
    &#125;

&#125;
</code></pre>
<h6 id="TRIE树的其它"><a href="#TRIE树的其它" class="headerlink" title="TRIE树的其它"></a>TRIE树的其它</h6><h4 id="散列表——哈希表-面试很重要"><a href="#散列表——哈希表-面试很重要" class="headerlink" title="散列表——哈希表-面试很重要"></a>散列表——哈希表-面试很重要</h4><p>特点：查找与删除，查找全部在常数时间内完成</p>
<p>应用：</p>
<ul>
<li>操作系统</li>
<li>数据库</li>
<li>编译器</li>
<li>计网</li>
<li>图像检索（最初始用于人脸识别等）</li>
</ul>
<h6 id="线性表总结："><a href="#线性表总结：" class="headerlink" title="线性表总结："></a>线性表总结：</h6><p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-24%20163929.png"
                      alt="屏幕截图 2022-10-24 163929"
                ></p>
<h6 id="哈希定义，应用"><a href="#哈希定义，应用" class="headerlink" title="哈希定义，应用"></a>哈希定义，应用</h6><p>本质：给定一个输入给出一个唯一的序列号输出，<strong>将一个比较大的空间映射到一个比较小的空间，将一个复杂的数据结构映射到一个小的</strong></p>
<p>应用举例： </p>
<ul>
<li>输入n个数10^5，数的范围+-10^9,选择一些数字插入，选择另外一些数字查询</li>
<li>文本压缩和解压缩</li>
</ul>
<p>定位的过程：元素通过哈希函数转换成唯一的整数（<strong>必须快速计算</strong>）<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-24%20164952.png"
                      alt="屏幕截图 2022-10-24 164952"
                ></p>
<p>第一步：将一个元素映射成一个整数</p>
<h6 id="哈希模板（正常-字符串版本）"><a href="#哈希模板（正常-字符串版本）" class="headerlink" title="哈希模板（正常+字符串版本）"></a>哈希模板（正常+字符串版本）</h6><pre><code class="c++">(1) 拉链法
    int h[N], e[N], ne[N], idx;
    const int  N=1e5+3;
    // 向哈希表中插入一个数
    void insert(int x)//这么理解：就是正常的数组模拟链表，但是加入哈希函数
    &#123;
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];//就是把head换成了h[k],因为原先是单链，现在多链
        h[k] = idx ++ ;
    &#125;

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    &#123;
        int k = (x % N + N) % N;//首先哈希
        for (int i = h[k]; i != -1; i = ne[i])
            &#123;if (e[i] == x)
                return true;&#125;

        return false;
    &#125;

(2) 开放寻址法
    const int N=2e5+3;//开放寻址的大小要放大的
    int h[N];
    const int null=0x3f3f3f3f;
    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    &#123;
        int t = (x % N + N) % N;
        while (h[t] != null &amp;&amp; h[t] != x)//这里易错，是&amp;&amp;
        &#123;
            t ++ ;
            if (t == N) t = 0;
        &#125;
        return t;
    &#125;
</code></pre>
<pre><code class="c++">核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i &lt;= n; i ++ )
&#123;
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
&#125;

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
&#123;
    return h[r] - h[l - 1] * p[r - l + 1];
&#125;
</code></pre>
<h6 id="分配索引值"><a href="#分配索引值" class="headerlink" title="分配索引值"></a>分配索引值</h6><p>这里对字符进行处理，每一种字符都视为一种对应的数字，不同的位数有不同的加权值</p>
<pre><code class="c++">unsigned int hash(char *key)
&#123; unsigned int hash_val = 0;
 while(*key != &#39;\0&#39;) 
 &#123; hash_val = (hash_val &lt;&lt; 5) + *key++;
//这里使用&lt;&lt;实际上就是直接×2^5
  //每一次移动5位（这样子硬件便于实现，参考计组）
&#125; return hash_val;

&#125;
</code></pre>
<p>缺点：虽然时间非常高效，但是空间浪费非常大（毕竟不能载满）</p>
<h6 id="减少索引值："><a href="#减少索引值：" class="headerlink" title="减少索引值："></a>减少索引值：</h6><p>方法1：忽略一部分元素，将另一部分直接视为索引值</p>
<p>好处：快，坏处：难于分配索引值</p>
<p>方法2：折叠，使用不同方式将原数据拆分，再合并在一起</p>
<p>方法3：余数运算，可以元素值除以某一特殊数字，余数用作索引值，</p>
<pre><code class="c++">unsigned int hash(char *key, unsigned int H_SIZE) 
&#123; unsigned int hash_val = 0; while(*key != &#39;\0&#39;) &#123; hash_val = (hash_val &lt;&lt; 5) + *key++;

&#125; return hash_val % H_SIZE;//这里缩了一下

&#125;
</code></pre>
<h5 id="字符串哈希——-gt-字符串前缀哈希法"><a href="#字符串哈希——-gt-字符串前缀哈希法" class="headerlink" title="字符串哈希——&gt;字符串前缀哈希法"></a>字符串哈希——&gt;字符串前缀哈希法</h5><p>作用有些类似kmp，字符串也可以用哈希表做-&gt;一个集合到另一个集合的映射</p>
<p>实际上是<strong>字符串的前缀哈希法</strong>，对前缀进行哈希</p>
<p>问题：</p>
<ul>
<li>如何定义某一个前缀的哈希值，可以将字符串视为p进制的一个数，每一位上的字母（acscii）视为对应的数字，<strong>但是不能映射成0</strong>-&gt;相同的字符串映射结果会相同-&gt;AA等等</li>
<li>哈希字符串<strong>假定人品足够不存在碰撞</strong>，没有考虑冲突情况，经验值：p取<strong>131或13331</strong>时候，q取2^64，几乎99%情况不会出现冲突</li>
</ul>
<p>好处：<em><strong>可以利用最前的哈希计算出所有子串的哈希</strong></em>，</p>
<p>已知h[r],h[l],</p>
<p>h[r]中r为第0位，h[l-1]中l-2为第0位</p>
<p>操作</p>
<ol>
<li>h[l-1]与h[r]对齐，即向后移动多少位</li>
<li>h[r]-h[l-1]就能求出来了</li>
</ol>
<p>小技巧：<strong>使用unsigned long long 存储所有h，相当于对所有数取模了</strong>(因为溢出就相当于取模)</p>
<p>总结：左移高位对齐</p>
<p>之后对前缀全部处理完之后，就能用o1时间计算任意子串哈希值</p>
<p>预处理：h[i]&#x3D;h[i-1]*p+str[i] (第i位字母)</p>
<p>牛逼的地方：比kmp牛逼：<strong>可以快速判断，快过o(n)</strong>,<strong>是处理字符串的利器</strong></p>
<p>代码核心部分：</p>
<pre><code class="c++">typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i &lt;= n; i ++ )
&#123;
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
&#125;

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
&#123;
    return h[r] - h[l - 1] * p[r - l + 1];
&#125;
</code></pre>
<p>完整代码：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/843/" >841. 字符串哈希 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/24738/" >AcWing 841. 字符串哈希 【公式助理解】 - AcWing<i class="fas fa-external-link-alt"></i></a></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="C:\Users\胡锡睿\Pictures\Screenshots\屏幕截图_20221025_085505.png"
                      alt="屏幕截图_20221025_085505"
                ></p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
using namespace std;
typedef unsigned long long ULL;//也就是取模2^64，
const int N = 1e5+5,P = 131;//131 13331
ULL h[N],p[N];

// h[i]前i个字符的hash值
// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突
// 使用场景： 两个字符串的子串是否相同
ULL query(int l,int r)&#123;
    return h[r] - h[l-1]*p[r-l+1];
    //为求l到r的哈希值
    //已知h[r],h[l-1]，也就是1到l-1，1到r的哈希值
    //因为字符串视为一个p进制的数，因此越左边权重越高，为高位，右边是低位
    //h[r]中r是第0位，h[1]为r-1位
    //h[l-1]l-1是第0位，h[1]为l-2位
    //两者相差r-1-l+2=r-l+1位
    //本质就是高位对齐，h[r]与h[l-1]对齐，
&#125;
int main()&#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    string x;
    cin&gt;&gt;x;

    //字符串从1开始编号，h[1]为前一个字符的哈希值
    p[0] = 1;
    h[0] = 0;
    //以上是初始化，第0位实际上不加入计算
    for(int i=0;i&lt;n;i++)&#123;
        p[i+1] = p[i]*P;            
        h[i+1] = h[i]*P +x[i];      //前缀和求整个字符串的哈希值
        //这里x也是从第一位开始，也就是0
    &#125;

    while(m--)&#123;
        int l1,r1,l2,r2;
        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;
        if(query(l1,r1) == query(l2,r2)) printf(&quot;Yes\n&quot;);
        else printf(&quot;No\n&quot;);

    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="哈希碰撞处理（面试高频）😍😍😍😍😍"><a href="#哈希碰撞处理（面试高频）😍😍😍😍😍" class="headerlink" title="哈希碰撞处理（面试高频）😍😍😍😍😍"></a>哈希碰撞处理（面试高频）😍😍😍😍😍</h4><p><strong>可以把离散化看成一种特殊的哈希方式</strong></p>
<p><strong>哈希表属于期望算法</strong>，可以将哈希表的链长视为一个常数，</p>
<p>碰撞：两个相同的索引放在相同的索引位置</p>
<p>碰撞可能性很大-&gt;定义域很大值域比较小</p>
<h6 id="拉链法（Open-Hashing）"><a href="#拉链法（Open-Hashing）" class="headerlink" title="拉链法（Open Hashing）"></a>拉链法（Open Hashing）</h6><p>原理：如果多个索引值最终哈希值相同，使用链表的形式另外存储相同的值</p>
<p>添加，直接添加链</p>
<p>查找：对应位置在链表遍历一下</p>
<p>删除：算法题中一般不会进行删除节点，而是会开 一个数组打一个标记（如bool标记）</p>
<p><strong>数学上取质数，而且举例2的幂尽可能远冲突概率最小</strong></p>
<pre><code class="c++">#include &lt;cstring&gt;
#include &lt;iostream&gt;

using namespace std;

const int N = 1e5 + 3;  // 取大于1e5的第一个质数，而且要离2的整次幂尽可能远， 取质数冲突的概率最小

//* 开一个槽 h
//图论中存点的方式和数组的链法一样，都是一个数组一个链
int h[N], //哈希表
//经典数组实现链表
e[N], 
ne[N], 
idx;  //邻接表

void insert(int x) &#123;
    // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数
    int k = (x % N + N) % N;//k就是对应的哈希值，这一步实现了映射。接下来是写入
    //(x%N+N)这一步为了最后一定是一个正数，如果是负数数组无法写入
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
&#125;

bool find(int x) &#123;
    //用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i]) &#123;//这里是遍历对应到的链表
        //同时由于初始化是-1，开始哈希数组也要初始化为-1
        if (e[i] == x) &#123;
            return true;
        &#125;
    &#125;
    return false;
&#125;

int n;

int main() &#123;
    cin &gt;&gt; n;

    memset(h, -1, sizeof h);  //将槽先清空 空指针一般用 -1 来表示
    //

    while (n--) &#123;
        string op;//字符串的话编译器会自动忽略空格，换行符等，不容易出错
        //有些脏数据会增加额外空格
        int x;
        cin &gt;&gt; op &gt;&gt; x;
        if (op == &quot;I&quot;) &#123;
            insert(x);
        &#125; else &#123;
            if (find(x)) &#123;
                puts(&quot;Yes&quot;);
            &#125; else &#123;
                puts(&quot;No&quot;);
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>缺点：消耗空间</p>
<h6 id="开放地址法-Open-Addressing"><a href="#开放地址法-Open-Addressing" class="headerlink" title="开放地址法 Open Addressing"></a>开放地址法 Open Addressing</h6><p>思路：只用一个一维数组来模拟哈希表，因此形式会相对简洁，但是一般来说一维数组的长度应该是需要的数组大小的2~3倍，</p>
<p>类似数组模拟链表的方式，将数据存储在空余空间中，<strong>想象上厕所，一个坑位完了就下一个</strong></p>
<p>探测方法：</p>
<ul>
<li>线性探测</li>
</ul>
<p>缺点：费时间，元素容易聚集，分布不均匀，聚集越多性能越差</p>
<ul>
<li>平方探测</li>
</ul>
<p>避免了元素的聚集，如果顺序表长度为指数，顺序表空位多于一半，平方探测总能插入新元素</p>
<ul>
<li>伪随机探测</li>
</ul>
<p>代码</p>
<pre><code class="c++">#include &lt;cstring&gt;
#include &lt;iostream&gt;

using namespace std;

//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了
const int N = 2e5 + 3;        //大于数据范围的第一个质数
const int null = 0x3f3f3f3f;  //规定空指针为 null 0x3f3f3f3f
//这个数只要不在原本数据范围内就行

int h[N];

int find(int x) &#123;//这一个函数同时实现查找和插入功能
    int t = (x % N + N) % N;
    while (h[t] != null &amp;&amp; h[t] != x) &#123;
        t++;//这一步是线性探测，可以使用平方或者伪随机优化
        if (t == N) &#123;//如果到头了，就返回从头找
            t = 0;
        &#125;
    &#125;
    return t;  //如果这个位置是空的, 则返回的是他应该存储的位置
&#125;

int n;

int main() &#123;
    cin &gt;&gt; n;

    memset(h, 0x3f, sizeof h);  //规定空指针为 0x3f3f3f3f

    while (n--) &#123;
        string op;
        int x;
        cin &gt;&gt; op &gt;&gt; x;
        if (op == &quot;I&quot;) &#123;
            h[find(x)] = x;//妙啊
        &#125; else &#123;
            if (h[find(x)] == null) &#123;
                puts(&quot;No&quot;);
            &#125; else &#123;
                puts(&quot;Yes&quot;);
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="杜鹃哈希😎"><a href="#杜鹃哈希😎" class="headerlink" title="杜鹃哈希😎"></a>杜鹃哈希😎</h4><p>感觉：拆东墙补西墙，但是很牛逼</p>
<p>优点：只要两个表中间有元素，一定可以通过哈希函数在顺序表中直接找到不用探测，非常高效</p>
<p>原因：所有索引位置都是哈希函数得到</p>
<h6 id="失败时："><a href="#失败时：" class="headerlink" title="失败时："></a>失败时：</h6><ul>
<li>没有足够空间，路径无限循环</li>
<li>转移链表过长</li>
</ul>
<p>缺点：元素过多时候插入元素困难</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/blubluhao/article/details/74912393?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%9D%9C%E9%B9%83%E5%93%88%E5%B8%8C&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-74912393.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1&spm=1018.2226.3001.4187" >(101条消息) 杜鹃散列_EmberWn的博客-CSDN博客_杜鹃散列<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/awst-lee/p/16801380.html" >【散列】杜鹃散列详情与C++实现代码 - awst_lee - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/kekukele/p/3812780.html" >Cuckoo hash算法分析 - 可酷可乐 - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cuckoo_hashing" >Cuckoo hashing - Wikipedia<i class="fas fa-external-link-alt"></i></a>（科学上网看）</p>
<p>杜鹃哈希举例：</p>
<p><strong>坏消息：根本看不懂</strong></p>
<p><strong>好消息：不用看了</strong></p>
<pre><code class="c++">//为杜鹃散列生成泛型HashFamily接口,用来发出多簇散列函数到杜鹃散列表
template&lt;typename AnyType&gt;
class CuckooHashFamily &#123;
public:
    size_t hash(const AnyType&amp; x, int which)const;
    int getNumberOfFunctions();
    void generateNewFunctions();
&#125;;
 
/**
* 杜鹃散列法的非正式字符串散列
*/
template&lt;int count&gt;
class StringHashFamily &#123;
private:
    std::vector&lt;int&gt; MULTIPLIERS;
    UniformRandom r;
 
public:
    StringHashFamily() :MULTIPLIERS(count) &#123;
        generateNewFuntions();
    &#125;
    int getNumberOfFunctions()const &#123;
        return count;
    &#125;
    void generateNewFuntions() &#123;
        for (auto&amp; mult : MULTIPLIERS)
            mult = r.nextInt();
    &#125;
 
    size_t hash(const string&amp; x, int which)const &#123;
        const int multiplier = MULTIPLIERS[which];
        size_t hashVal = 0;
        for (auto ch : x)
            hashVal = multiplier * hashVal + ch;
        return hashVal;
    &#125;
&#125;;
 
//杜鹃散列类接口，允许(由HashFamily模板参数类型指定)任意个数的散列函数
template&lt;typename AnyType, typename HashFamily&gt;
class HashTable &#123;
private:
    struct HashEntry &#123;
        AnyType element;
        bool isActive;
 
        HashEntry(const AnyType&amp;e=AnyType(),bool a=false)
            :element&#123;e&#125;,isActive&#123;a&#125;&#123;&#125;
        HashEntry(AnyType&amp;&amp;e,bool a=false)
            :element&#123;std::move(e)&#125;,isActive&#123;a&#125;&#123;&#125;
    &#125;;
 
    /**
    * 杜鹃散列的插入例程使用不同的算法，
    * 该算法随机选择要逐出的项，
    * 但不再试图重新逐出最后的项。
    * 如果存在太多的逐出项则散列表将尝试选取新的散列函数(再散列)，
    * 而若有太多的再散列则散列表将扩张
    */
    bool insertHelper1(const AnyType&amp; xx) &#123;
        const int COUNT_LIMIT = 100;
        AnyType x = xx;
 
        while (true) &#123;
            int lastPos = -1;
            int pos;
 
            for (int count = 0; count &lt; COUNT_LIMIT; ++count) &#123;
                for (int i = 0; i &lt; numHashFunctions; ++i)
                    pos = myhash(x, i);
                    
                if (!isActive(pos)) &#123;
                    array[pos] = std::move(HashEntry&#123; std::move(x),true &#125;);
                    ++currentSize;
                    return true;
                &#125;
            &#125;
 
            //无可用位置，逐出一个随机项
            int i = 0;
            do &#123;
                pos = myhash(x, r.nextInt(numHashFunctions));
            &#125; while (pos == lastPos &amp;&amp; i++ &lt; 5);
 
            lastPos = pos;
            std::swap(x, array[pos].element);
        &#125;
 
        if (++rehashes &gt; ALLOWED_REHASHES) &#123;
            expand();		//使散列表扩大
            rehashes = 0;	//重置rehashes的计数
        &#125;
        else
            rehash();		//表大小相同，散列函数都是新的
    &#125;
    bool insertHelper1(AnyType&amp;&amp; x) &#123;
        const int COUNT_LIMIT = 100;
 
        while (true) &#123;
            int lastPos = -1;
            int pos;
 
            for (int count = 0; count &lt; COUNT_LIMIT; ++count) &#123;
                for (int i = 0; i &lt; numHashFunctions; ++i)
                    pos = myhash(x, i);
 
                if (!isActive(pos)) &#123;
                    array[pos] = std::move(HashEntry&#123; std::move(x),true &#125;);
                    ++currentSize;
                    return true;
                &#125;
            &#125;
 
            //无可用位置，逐出一个随机项
            int i = 0;
            do &#123;
                pos = myhash(x, r.nextInt(numHashFunctions));
            &#125; while (pos == lastPos &amp;&amp; i++ &lt; 5);
 
            lastPos = pos;
            std::swap(x, array[pos].element);
        &#125;
 
        if (++rehashes &gt; ALLOWED_REHASHES) &#123;
            expand();		//使散列表扩大
            rehashes = 0;	//重置rehashes的计数
        &#125;
        else
            rehash();		//表大小相同，散列函数都是新的
    &#125;
    bool isActive(int currentPos)const &#123;
        return currentPos != -1 &amp;&amp; array[currentPos].isActive;
    &#125;
 
    /**
    * 使用特定函数计算x的散列代码
    * 选取适当的散列函数，然后把它换算成合法的数组下标
    */
    size_t myhash(const AnyType&amp; x, int which)const &#123;
        return hashFunctions.hash(x, which) % array.size();
    &#125;
 
    /**
    * 查找所有散列函数的位置
    * 返回查阅所有的散列函数以返回包含项x的下标，若找不到则返回-1
    */
    int findPos(const AnyType&amp; x)const &#123;
        for (int i = 0; i &lt; numHashFunctions; ++i) &#123;
            int pos = myhash(x, i);
 
            if (isActive(pos) &amp;&amp; array[pos].element == x)
                return pos;
        &#125;
        return -1;
    &#125;
 
    /**
    * 创建一个大数组但使用那些相同的散列函数
    */
    void expand() &#123;
        rehash(static_cast&lt;int&gt;(array.size() / MAX_LOAD));
    &#125;
 
    /**
    * 保留数组的大小不变，创建一个新的数组
    * 该数组使用那些新选出的散列函数填充
    */
    void rehash() &#123;
        hashFunctions.generateNewFuntions();
        rehash(array.size());
    &#125;
 
    void rehash(int newSize) &#123;
        std::vector&lt;HashEntry&gt; oldArray = array;
 
        //创建新的双倍大小的空散列表
        array.resize(nextPrime(newSize));
        for (auto&amp; entry : array)
            entry.isActive = false;
 
        //复制整个表
        currentSize = 0;
        for (auto&amp; entry : oldArray)
            if (entry.isActive)
                insert(std::move(entry.element));
    &#125;
 
    constexpr static const double MAX_LOAD=0.4; //最大装填因子
    static const int ALLOWED_REHASHES = 5; //最大散列次数
 
    vector&lt;HashEntry&gt;array;
    int currentSize;
    int numHashFunctions;
    int rehashes;
    UniformRandom r;
    HashFamily hashFunctions;
 
public:
    explicit HashTable(int size = 101) :array(nextPrime(size)) &#123;
        numHashFunctions = hashFunctions.getNumberOfFunctions();
        rehashes = 0;
        makeEmpty();
    &#125;
 
    //清空杜鹃散列表
    void makeEmpty() &#123;
        currentSize = 0;
        for (auto&amp; entry : array)
            entry.isActive = false;
    &#125;
 
    /**
    * 搜索杜鹃散列表的例程
    * 如果找到x则返回true
    */
    bool contains(const AnyType&amp; x)const &#123;
        return findPos(x) != -1;
    &#125;
 
    /**
    * 从散列表中删除x
    * 若项x被找到且被删除则返回true
    */
    bool remove(const AnyType&amp; x) &#123;
        int currentPos = findPos(x);
        if (!isActive(currentPos))
            return false;
 
        array[currentPos].isActive = false;
        --currentSize;
        return true;
    &#125;
 
    //杜鹃散列表中公有插入方法
    bool insert(const AnyType&amp; x) &#123;
        if (contains(x))
            return false;
 
        if (currentSize &gt;= array.size() * MAX_LOAD)
            expand(); 
 
        return insertHelper1(x);
    &#125;
    bool insert(AnyType&amp;&amp; x) &#123;
        if (contains(x))
            return false;
 
        if (currentSize &gt;= array.size() * MAX_LOAD)
            expand(); 
 
        return insertHelper1(std::move(x));
    &#125;
 
    int size() const
    &#123;
        return currentSize;
    &#125;
 
    int capacity() const
    &#123;
        return array.size();
    &#125;
&#125;;
</code></pre>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>最后通过看大神的代码才恍然大悟，二叉树的建立，需要按照一棵满二叉树来建立</p>
<p>问题来了，我们的节点不够满二叉树的，这就是关键，空节点也需要补上！</p>
<p>使用数组构造一棵二叉树也是同理！</p>
<h6 id="完全二叉树的构建（0作为空节点，会有空间浪费）"><a href="#完全二叉树的构建（0作为空节点，会有空间浪费）" class="headerlink" title="完全二叉树的构建（0作为空节点，会有空间浪费）"></a>完全二叉树的构建（0作为空节点，会有空间浪费）</h6><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
const int M=1010;//完全二叉树
int tree[M]=&#123;0&#125;;//全部初始化成0方便判断
int judge=1;//判断是否继续读入
int real_depth(int n)
&#123;
    int ans=0;
    while(n!=0)
    &#123;
        ans++;
        n=n/2;
    &#125;
    return ans;
&#125;
void DLR(int i)//
&#123;
    if(tree[i]!=0)
    &#123;
        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;
        DLR(i*2);
        DLR(i*2+1);
    &#125;
&#125;
void LDR(int i)//中序遍历
&#123;
    if(tree[i]!=0)
    &#123;
        
        DLR(i*2);
        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;
        DLR(i*2+1);
    &#125;
&#125;
void LRD(int i)//后序遍历
&#123;
    if(tree[i]!=0)
    &#123;

        DLR(i*2);
        DLR(i*2+1);
        cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;
    &#125;
&#125;
int main()
&#123;
    int n;
    cin&gt;&gt;n;
    int node_num=1;
    for(int j=0;j&lt;n;j++ )//计数是第几组
    &#123;

        int node;
        cin&gt;&gt;node;
        tree[1]=node;
        int i=1;
        if(node==0||node==-1)continue;
        while(judge==1)
        &#123;
            cin&gt;&gt; node;
            //cout&lt;&lt;&quot;node:  &quot;&lt;&lt;node&lt;&lt;endl;
            ++i;
            //cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;endl;
            if(node==-1)//实现了深度搞定，接下来是前序遍历
            &#123;
                cout&lt;&lt;real_depth(i-1) &lt;&lt;&quot; &quot;;
                break;
            &#125;
            else
            &#123;
                if(tree[i/2]!=0)
                &#123;
                    tree[i]=node;
                &#125;
                if(tree[i/2]==0)
                &#123;
                    while(tree[i/2]==0)i=i/2;//回退到上层节点是有数字
                    i=i/2;
                    //cout&lt;&lt;&quot;back: &quot;&lt;&lt;i&lt;&lt;endl;
                    while(tree[i*2])i=i*2;
                    i=i*2;
                    //cout&lt;&lt;&quot;go: &quot;&lt;&lt;i&lt;&lt;endl;
                    tree[i]=node;
                &#125;
            &#125;
            node_num=i;
        &#125;
        DLR(1);//完全二叉树记得要从节点1开始，也就是初始的节点
       cout&lt;&lt;endl;
       for(int i=1;i&lt;=node_num;i++)
       &#123;
           tree[i]=0;//清零
       &#125;
    &#125;
&#125;
</code></pre>
<h4 id="树的恢复"><a href="#树的恢复" class="headerlink" title="树的恢复"></a>树的恢复</h4><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43889841/article/details/96907208" >(105条消息) 先序遍历中序遍历还原二叉树_May Hacker的博客-CSDN博客_先序遍历中序遍历还原树<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="由先序和中序恢复二叉树"><a href="#由先序和中序恢复二叉树" class="headerlink" title="由先序和中序恢复二叉树"></a>由先序和中序恢复二叉树</h5><p>理论基础：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/" >105. 从前序与中序遍历序列构造二叉树 - 力扣（Leetcode）<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="背也要背会的模板"><a href="#背也要背会的模板" class="headerlink" title="背也要背会的模板:"></a>背也要背会的模板:</h6><p>[(105条消息) 根据先序中序还原二叉树_BugMaker-shen的博客-CSDN博客_由先序和中序恢复二叉树](<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42500831/article/details/105984986?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%85%88%E5%BA%8F" >https://blog.csdn.net/qq_42500831/article/details/105984986?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=先序<i class="fas fa-external-link-alt"></i></a> + 中序 恢复二叉树&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-105984986.142^v63^control,201^v3^control_1,213^v2^t3_control1&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>原理：使用递归</p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-17%20155014.png"
                      alt="屏幕截图 2022-11-17 155014" style="zoom:50%;" 
                >

<p>🙏🙏🙏🙏🙏🙏🙏🙏🙏感谢这位西电的朋友助我脱离苦海，感谢感谢</p>
<p>可以直接用那种：😭😭😭😭（<strong>数据结构放假是机考！机考！机考！我giao！！！</strong>）</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;

struct Node&#123;
    char data;
    Node* left;
    Node* right;
    Node(char data)&#123;
        this-&gt;data = data;
        this-&gt;left = nullptr;
        this-&gt;right = nullptr;
    &#125;
&#125;;

vector&lt;char&gt; getCharArray(string str)&#123;
    //这一步就是为了利用vector有现成的构造函数，能省很多步骤
    vector&lt;char&gt; res;
    for(char c : str)&#123;
        //
        /*
        这里的for(char c:str)就是定义一个遍历字符c，让它分别等于字符串数组str里面的各个字符，然后执行下面的语句，当c被赋值为str里面所有字符各一次后，就会退出这个循环。

这相当于JAVA的强for循环的语法结构。相当于C++的：
for( int i = 0; i &lt; s.length(); i++)
&#123; s[i]…
&#125;
        */
        res.push_back(c);
    &#125;
    return res;
&#125;

Node* getTree(vector&lt;char&gt;&amp; preOrder, vector&lt;char&gt;&amp; inOrder)&#123;
    if(preOrder.empty())&#123;
        return nullptr;
    &#125;
    Node* root = new Node(preOrder[0]);
    //构造根结点，并且将root指针指向前序的第一个节点，即总根节点
    vector&lt;char&gt;::iterator mid = find(inOrder.begin(), inOrder.end(), preOrder[0]);//遍历一次找到前序在
    int left_nodes = mid - inOrder.begin();//接下来进行分区处理
    vector&lt;char&gt; left_inOrder(inOrder.begin(), mid);//中序的左子树
    //这里直接用了vector的构造，将inOrder赋值过去，最后一个mid不会复制
    vector&lt;char&gt; right_inOrder(mid+1, inOrder.end());//中序的右子树
    vector&lt;char&gt; left_preOrder(preOrder.begin()+1, preOrder.begin()+1+left_nodes);//前序的左子树，就省去根节点了
    vector&lt;char&gt; right_preOrder(preOrder.begin()+1+left_nodes, preOrder.end());//前序右子树
    root-&gt;left = getTree(left_preOrder, left_inOrder);//新树的左子树
    root-&gt;right = getTree(right_preOrder, right_inOrder);//新树右子树
    return root;//返回一个节点指针
&#125;

void postOrder(Node* root)&#123;//后续遍历
    if(root == nullptr)&#123;
        return ;
    &#125;
    postOrder(root-&gt;left);
    postOrder(root-&gt;right);
    cout&lt;&lt;root-&gt;data;
&#125;

int main()&#123;
    string pre_str;
    string in_str;
    while(cin &gt;&gt; pre_str &gt;&gt; in_str)&#123;
        vector&lt;char&gt; preOrder = getCharArray(pre_str);//string转换成vector向量形式
        vector&lt;char&gt; inOrder = getCharArray(in_str);//
        Node* root = getTree(preOrder, inOrder);
        postOrder(root);
        cout&lt;&lt;endl;
    &#125;
    return 0;
&#125;

</code></pre>
<p>LeetCode解法：</p>
<pre><code class="c++">class Solution &#123;
private:
        TreeNode* traversal (vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd, vector&lt;int&gt;&amp; preorder, int preorderBegin, int preorderEnd) &#123;
        if (preorderBegin == preorderEnd) return NULL;

        int rootValue = preorder[preorderBegin]; // 注意用preorderBegin 不要用0
        TreeNode* root = new TreeNode(rootValue);

        if (preorderEnd - preorderBegin == 1) return root;

        int delimiterIndex;
        for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;
            if (inorder[delimiterIndex] == rootValue) break;
        &#125;
        // 切割中序数组
        // 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割前序数组
        // 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)
        int leftPreorderBegin =  preorderBegin + 1;
        int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 终止位置是起始位置加上中序左区间的大小size
        // 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)
        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);
        int rightPreorderEnd = preorderEnd;

        cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;leftInorder :&quot;;
        for (int i = leftInorderBegin; i &lt; leftInorderEnd; i++) &#123;
            cout &lt;&lt; inorder[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;

        cout &lt;&lt; &quot;rightInorder :&quot;;
        for (int i = rightInorderBegin; i &lt; rightInorderEnd; i++) &#123;
            cout &lt;&lt; inorder[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;

        cout &lt;&lt; &quot;leftPreorder :&quot;;
        for (int i = leftPreorderBegin; i &lt; leftPreorderEnd; i++) &#123;
            cout &lt;&lt; preorder[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;

        cout &lt;&lt; &quot;rightPreorder :&quot;;
        for (int i = rightPreorderBegin; i &lt; rightPreorderEnd; i++) &#123;
            cout &lt;&lt; preorder[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;


        root-&gt;left = traversal(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);
        root-&gt;right = traversal(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);

        return root;
    &#125;

public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
        if (inorder.size() == 0 || preorder.size() == 0) return NULL;
        return traversal(inorder, 0, inorder.size(), preorder, 0, preorder.size());

    &#125;
&#125;;
</code></pre>
<h4 id="并查集——面试涉及——竞赛频率也高😍"><a href="#并查集——面试涉及——竞赛频率也高😍" class="headerlink" title="并查集——面试涉及——竞赛频率也高😍"></a>并查集——面试涉及——竞赛频率也高😍</h4><p><strong>面试官一般都习惯去问一些代码短但是思路精巧的（便于手写代码）</strong></p>
<p>提前学习知识：链表，线性表</p>
<p>全名：归并查找集合，即判断两个元素是否属于同一个集合</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/838/" >836. 合并集合 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<p>可选方法：</p>
<ul>
<li>建两个哈希表分别找</li>
<li>建两个跳表分别找</li>
</ul>
<p>在集合经常动态变化时候，查找方法效率并不高</p>
<h6 id="并查集应用："><a href="#并查集应用：" class="headerlink" title="并查集应用："></a>并查集应用：</h6><p>快速处理下列问题：</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否属于同一个集合中</li>
</ol>
<p><strong>并查集能在近乎O（1）的时间复杂度之内快速支持以上两种操作</strong></p>
<p>正常：合并元素方式，至少需要对线性表&#x2F;链表整个进行一次遍历，耗时高</p>
<h6 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h6><p><strong>每一个集合使用一棵树来维护（不一定是二叉树，可能是三叉树，B+树等），每一个集合的编号就是根节点的编号</strong>，树中对于每一个点都存储其父节点（用p[x]表示x的父节点），在求某个元素是否属于某一个集合的时候，就在该元素向上遍历，知道到达根节点，最后判断根节点的编号是否是所需编号</p>
<p><strong>解决问题与流程：</strong></p>
<ol>
<li><p>如何判断树根，</p>
<pre><code class="c++">if(p[x]==x)//对于树根编号等于自身
</code></pre>
</li>
<li><p>如何求x的集合编号:</p>
<pre><code class="c++">while(p[x]!=x)x=p[x]//多么熟悉的链表的遍历操作，因此是链表实现
    //这一步实际上的时间复杂度会高，因为还是会向上进行一个遍历，时间和树的高度有关，因此树最好高度越低越好
</code></pre>
</li>
<li><p>如何合并两个集合：<strong>加一条边，将一个树插入到另一棵树身上就可以</strong></p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-17%20164329.png"
                      alt="屏幕截图 2022-11-17 164329" style="zoom:33%;" 
                >

<pre><code class="c++">//假设p[x]是x集合编号，p[y]是y的集合编号，那么只需要
p[x]=y
</code></pre>
</li>
</ol>
<h6 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h6><pre><code class="c++">int find(int x)//核心的函数
    //加上路径压缩，会自动找到根节点
&#123;
    //if(p[x]!=x)x=p[x];
    if(p[x]!=x)p[x]=find(p[x]);
    //易错：p[x]=find(p[x])这里要更新的
    //易错：这里是if不能是循环while
    
    
    /*
    上面两句分别是普通版本和加过路径优化的版本
    第一个就是普通循环进行查找
    第二局是调用递归，每一次在寻找的时候都会对当前的节点进行更新，初次执行会慢，之后速度会飞升
    */
    return p[x];//最后返回一个根节点
&#125;
void merge(int x,int y)
&#123;
        p[x]=y;//核心函数二：合并     
&#125;
</code></pre>
<p>全代码：</p>
<pre><code class="c++">#include&lt;iostream&gt;

using namespace std;

const int N=100010;
int p[N];//定义多个集合

int find(int x)
&#123;
    if(p[x]!=x) p[x]=find(p[x]);
    /*
    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:
    p[x]=x;
    */
    return p[x];
    //找到了便返回祖宗节点的值
&#125;
void merge(int x ,int y)//这里是把x的头并到y了
&#123;
    p[find(x)]=find(y);//这里进行操作使用上一步的find函数
&#125;

int main()
&#123;
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++) p[i]=i;
    while(m--)
    &#123;
        char op[2];
        int a,b;
        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);
        if(*op==&#39;M&#39;) merge(a,b);//集合合并操作
        else
        if(find(a)==find(b))
        //如果祖宗节点一样,就输出yes
        printf(&quot;Yes\n&quot;);
        else
        printf(&quot;No\n&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
<h5 id="并查集优化：路径压缩"><a href="#并查集优化：路径压缩" class="headerlink" title="并查集优化：路径压缩"></a>并查集优化：路径压缩</h5><p><strong>并查集最牛逼的优化方式，另一种优化基本写代码时候不会使用</strong></p>
<p>原理：<strong>一旦在向上走的时候找到了根节点，将该路径所有节点都指向根节点</strong>，即只需要搜索一次，之后的重复操作速度就会提高，可以视为O（1）优化</p>
<h6 id="优化：加权合并"><a href="#优化：加权合并" class="headerlink" title="优化：加权合并"></a>优化：加权合并</h6><p>防止树越来越高</p>
<p>记录每棵树元素的个数作为树的权重</p>
<h4 id="堆：完全二叉树的操作"><a href="#堆：完全二叉树的操作" class="headerlink" title="堆：完全二叉树的操作"></a>堆：完全二叉树的操作</h4><p>应用：</p>
<ul>
<li>构造优先队列</li>
</ul>
<p>（不用stl）手搓一个堆，堆的基本</p>
<ul>
<li>插入一个数</li>
<li>求这个集合当中的最小值</li>
<li>删除最小值</li>
<li>删除任意一个元素（stl无法直接实现）</li>
<li>修改任意一个元素（stl无法直接实现）</li>
</ul>
<h6 id="堆的基本结构："><a href="#堆的基本结构：" class="headerlink" title="堆的基本结构："></a>堆的基本结构：</h6><p>堆属于一棵<strong>完全</strong>二叉树（指除了最后一排其他都是均匀分布，即所有节点都不是非空），最后一层节点从左到右依次排列</p>
<p>小根堆的性质：每一个点都是小于等于左右儿子（即递归定义），则根节点就是最小值</p>
<p>大根堆：相反</p>
<p><strong>凡是完全二叉树都是用一维数组存储的</strong></p>
<p>1号点是根节点</p>
<p><strong>x的左儿子下标：2x,</strong></p>
<p><strong>x的右儿子下标：2x+1</strong></p>
<p>stl里面的堆就是优先队列</p>
<p>特点：</p>
<ul>
<li>时间复杂度非常稳定，不依赖原始记录状态	 </li>
<li>是一种不稳定的排序方法（记录比较与交换跳跃进行）</li>
</ul>
<h6 id="基本函数："><a href="#基本函数：" class="headerlink" title="基本函数："></a>基本函数：</h6><p>down(x)：如果某一个点的值变大，就将该值向下压</p>
<p>up(x)：如果一个点的值变小，向上升</p>
<p>两个函数的执行次数都和二叉树的深度成正比，也就是logn</p>
<p><strong>这里的x实际上是所处的位置</strong></p>
<p>由基本函数构成堆的几种操作：</p>
<ol>
<li>插入一个数</li>
</ol>
<pre><code class="c++">heap[++size]=x;//这一步将堆数组的最后再一个换成需要的数
up(size);
</code></pre>
<ol start="2">
<li>求最小值</li>
</ol>
<pre><code class="c">heap[1];//是小根堆，则就最上面的就是最小的
</code></pre>
<ol start="3">
<li>删除最小值(也就是最顶部的根节点的删除)</li>
</ol>
<p><strong>思路</strong>：用堆底部的最后一个元素覆盖掉第一个元素，然后进行down（1)</p>
<p>原理：<strong>存储结构是一个一维数组</strong>，删除尾部节点很容易（直接size–就行），但删除头部却很麻烦</p>
<p>覆盖掉之后再使用向下函数down会让顶部元素下沉到正确位置</p>
<pre><code class="c++">heap[1]=heap[size];
size--;
down(1);
</code></pre>
<ol start="4">
<li>删除任意一个元素,和删除头部不太一样在于不确定改变值之后是大还是小</li>
</ol>
<p><strong>简单粗暴好使的办法：管他呢，down一次，up一次，因为up和down实际上只会执行一次</strong></p>
<pre><code class="c++">heap[k]=heap[size];
size--;//
down(k);
up(k);
</code></pre>
<ol start="5">
<li>修改任意一个元素的值：同删除一个元素的操作</li>
</ol>
<pre><code class="c++">heap[k]=x;
down(k);
up(k);
</code></pre>
<h6 id="构建小细节："><a href="#构建小细节：" class="headerlink" title="构建小细节："></a><strong>构建小细节：</strong></h6><p>不同于其它的一般采用下标从0开始，对于树形结构，因为树的性质有左儿子&#x3D;根&#x2F;2，如果从0开始左儿子也是0，不方便，因此堆排序实际上是从1开始</p>
<h5 id="开始构建："><a href="#开始构建：" class="headerlink" title="开始构建："></a>开始构建：</h5><h6 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h6><p>可以用插入的方式操作，但每一次插入都是logn，实际上不好</p>
<p>有时间复杂度为on的方式</p>
<pre><code class="c++">for(int i=size/2,i&gt;0;i--)down(i);
</code></pre>
<h6 id="构建up"><a href="#构建up" class="headerlink" title="构建up"></a>构建up</h6><p>妙啊（发出抱大佬大腿的声音）😍</p>
<pre><code class="c++">void up(int u)
&#123;
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//不管u是左右儿子，都不重要，直接/2指向的双亲都是同一个
    &#123;
        swap(u, u / 2);
        u &gt;&gt;= 1;//u变成原先的二分之一
    &#125;
&#125;
</code></pre>
<h6 id="构建down"><a href="#构建down" class="headerlink" title="构建down"></a>构建down</h6><pre><code class="c++">void down(int u)
&#123;
    int t=u;
    if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小
    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;=h[t])t=u*2+1;//判断右儿子和大小
    //最后t存的就是根，左右儿子三者之中最小的值下标
    if(u!=t)//不等，说明有可能还要继续递归进行对比
    &#123;
        swap(h[u],h[t]);
        down(t);//递归向下继续弄
    &#125;
    
&#125;
</code></pre>
<h5 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h5><p><strong>难点：支持随机的修改和删除</strong>,题中要求是第i个，但是i对应的下标会随着操作变化下标跟着变化，需要实时更新。因此<strong>映射也要交换好</strong></p>
<p><strong>解法：使用映射,老牛逼了</strong></p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-10%20234320.png"
                      alt="屏幕截图 2022-11-10 234320" style="zoom:33%;" 
                >

<pre><code class="c++">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;
//ph从左到右，hp从右到左、
//交换数的时候，指针也要交换
// 交换两个点，及其映射关系
void heap_swap(int a, int b)//针对这一道题开发的映射关系转换
&#123;
    swap(ph[hp[a]],ph[hp[b]]);//指针交换
    swap(hp[a], hp[b]);//逆指针交换
    swap(h[a], h[b]);//数值交换
&#125;

void down(int u)
&#123;
    int t = u;
    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;
    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;
    if (u != t)
    &#123;
        heap_swap(u, t);
        down(t);
    &#125;
&#125;

void up(int u)
&#123;
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])
    &#123;
        heap_swap(u, u / 2);
        u &gt;&gt;= 1;
    &#125;
&#125;

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
</code></pre>
<h6 id="解题技巧："><a href="#解题技巧：" class="headerlink" title="解题技巧："></a>解题技巧：</h6><p>当题中有明确给出第i个操作数，要考虑如何通过更新操作数的下标</p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-10%20234320.png"
                      alt="屏幕截图 2022-11-10 234320" style="zoom:50%;" 
                >

<h5 id="堆排序：onlogn"><a href="#堆排序：onlogn" class="headerlink" title="堆排序：onlogn"></a>堆排序：onlogn</h5><p><strong>一般升序使用大顶堆，降序采用小顶堆</strong></p>
<p>举例：对数组进行从小到大排序，输出前m小的数</p>
<p>思路：<strong>本题可以使用堆排序，构造小顶堆，然后输出堆顶，输出后把堆顶和堆尾交换。尾部边界缩小，重复执行m次即可。</strong></p>
<p>注意点：</p>
<ul>
<li>和完全二叉树一样下标从1开始</li>
</ul>
<h5 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h5><p>易错点：</p>
<h6 id="模拟堆（直接造小根堆）"><a href="#模拟堆（直接造小根堆）" class="headerlink" title="模拟堆（直接造小根堆）"></a>模拟堆（直接造小根堆）</h6><pre><code class="c++">#include &lt;iostream&gt;
using namespace  std;
const int M=100100;
int h[M];
int size;
void big_down(int u)//最后大的会向下走
&#123;
    int t=u;
    if(u*2&lt;=size&amp;&amp;h[u*2]&lt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小
    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&lt;=h[t])t=u*2+1;//判断右儿子和大小
    //最后t存的就是根，左右儿子三者之中最小的值下标
    if(u!=t)//不等，说明有可能还要继续递归进行对比
    &#123;
        swap(h[u],h[t]);
        big_down(t);//递归向下继续弄
    &#125;
&#125;
void small_down(int u)//最后小的会向下走
&#123;
    int t=u;
    if(u*2&lt;=size&amp;&amp;h[u*2]&gt;h[t])t=u*2;//先判断有没有左儿子，然后判断左儿子小
    if(u*2+1&lt;=size&amp;&amp;h[u*2+1]&gt;=h[t])t=u*2+1;//判断右儿子和大小
    //最后t存的就是根，左右儿子三者之中最小的值下标
    if(u!=t)//不等，说明有可能还要继续递归进行对比
    &#123;
        swap(h[u],h[t]);
        small_down(t);//递归向下继续弄
        注意这里向下的还是t
    &#125;
&#125;
int main()
&#123;

    cin&gt;&gt;size;
    for(int i=1;i&lt;=size;i++)//二叉树的读入范围
    &#123;
        cin&gt;&gt;h[i];
    &#125;
    for (int i = size / 2; i; i -- ) small_down(i);
    for(int i=1;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;endl;
    for (int i = size / 2; i; i -- ) big_down(i);
    for(int i=1;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;endl;

    return 0;
&#125;
</code></pre>
<h6 id="堆排序（整体）"><a href="#堆排序（整体）" class="headerlink" title="堆排序（整体）"></a>堆排序（整体）</h6><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int a[N];//保存数组
int n, m;//n个点，求前m小
int r ;//堆的右边界
void down(int u)//调整函数
&#123;
    //t记录最小点的编号
    int t = u;

易错部分：这里前面都是u最后对比是t，修改大小也是修改u
    if(2 * u &lt;= r &amp;&amp; a[2 * u] &lt; a[t]) t = 2 * u;

    if(2 * u + 1 &lt;= r &amp;&amp; a[2 * u + 1] &lt; a[t]) t = 2 * u + 1;

    //如果待调整点不是最小的
    if(u != t)
    &#123;
        //和最小的交换
        swap(a[u], a[t]);

        //递归处理
        down(t);
    &#125;
&#125;


因为堆是一棵二叉树构建起来的，因此是从1
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    r = n;//开始时，右边界是数组边界

    //读入数据
    for (int i = 1; i &lt;= n; i ++ )
    &#123;
        int x;
        cin &gt;&gt; a[i];
    &#125;

    //从第一个非叶节点开始，从右到左，从下到上处理每个节点
   for(int i = n /2 ; i ; i--)//创建小根堆
   &#123;
       //注意问题在于它小得没有规律
       down(i);//因为叶子节点没办法继续向下了，因此从叶子向上一层开始操作
   &#125;

    //输出m个最小值
    while (m -- )
    &#123;
        //堆顶保存的最小值，输出堆顶
        cout &lt;&lt; a[1] &lt;&lt; &quot; &quot;;

        //将堆顶和右边界交换
        swap(a[1], a[r]);

        //右边界左移
        r--;

        //从新处理堆顶
        down(1);
    &#125;
&#125;
</code></pre>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p><strong>下面这个关于编码的，很重要</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46518461/article/details/109404969?ops_request_misc=%7B%22request_id%22:%22166919312616782395398061%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166919312616782395398061&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-109404969-null-null.142%5Ev66%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev2%5Et3_control1&utm_term=%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91C++%E7%BC%96%E7%A0%81&spm=1018.2226.3001.4187" >(108条消息) 【数据结构——哈夫曼树及其应用】_FEI..的博客-CSDN博客_哈夫曼树的parent怎么求<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="哈夫曼编码-字母"><a href="#哈夫曼编码-字母" class="headerlink" title="哈夫曼编码:字母"></a>哈夫曼编码:字母</h5><p><strong>核心：无前缀编码</strong>，从根节点到叶子节点的路径代表编码，只要字母在叶子节点，对应编码就是无前缀</p>
<h6 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h6><ul>
<li>从底向上建立一棵无前缀编码树</li>
<li>频次低的树在最下面</li>
</ul>
<h6 id="自己写的代码-输入字符串进行编码并输出-："><a href="#自己写的代码-输入字符串进行编码并输出-：" class="headerlink" title="自己写的代码(输入字符串进行编码并输出)："></a>自己写的代码(输入字符串进行编码并输出)：</h6><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
using namespace std;
typedef struct
&#123;
    int weight;//结点的权值
    int parent, lchild, rchild;//双亲、左孩子、右孩子的下标
&#125;HTnode,*HuffmanTree;
void Select(HuffmanTree&amp; HT,int &amp;s1,int &amp;s2,int n)
&#123;
    s2=1,s1=2;//两个过大的数进行比对
    for (int i = 1;i &lt;= n;++s1)//在1到n之间的点进行寻找
    &#123;
        if(HT[s1].parent==0&amp;&amp;HT[s2].parent==0)//当
        &#123;
            break;
        &#125;
        if(HT[s1].parent==0)//当
        &#123;
            s2=s1;
        &#125;
        if(s2==s1)++s1;
    &#125;
    for (int i = 1;i &lt;= n;++i)//在1到n之间的点进行寻找
    &#123;
        if(HT[i].weight&lt;=HT[s1].weight&amp;&amp;HT[i].parent==0)//当
        &#123;
            s1=i;//连着更新两次，s1是最小的，s2是次小的
        &#125;
    &#125;
    for (int i = 1;i &lt;= n;++i)//在1到n之间的点进行寻找
    &#123;
        if(HT[i].weight&lt;=HT[s2].weight&amp;&amp;HT[i].parent==0&amp;&amp;i!=s1)//当
        &#123;
            s2=i;
        &#125;
    &#125;
&#125;
void CreateHuffmanTree(HuffmanTree&amp; HT, int n,int word[])//构造哈夫曼树，n为带权值的叶子结点个数
&#123;
    //使用了以获取的word数组存取已有的数量
    /*初始化*/
    int s1,s2;
    if (n &lt;= 1)
        return;
    int m = 2 * n - 1;//m为哈夫曼树中总结点的个数
    HT = new HTnode[m + 1];//0号单元未用，所以需要开辟m+1个单元，HT[m]表示根结点
    for (int i = 1;i &lt;= m;++i)//将1-m号单元的双亲，左右孩子的下标都初始化为0
    &#123;
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    &#125;
    int word_select=0;
    for (int i = 1;i &lt;= n;++i)
    &#123;
        for(;word[word_select]==0;word_select++);
//        cout&lt;&lt;(char)word_select &lt;&lt;&quot; word=&quot;&lt;&lt;word[word_select]&lt;&lt;endl;
        HT[i].weight=word[word_select];//输入前n个单元中叶子结点的权值
//        cout&lt;&lt;i&lt;&lt;&quot;个单元叶子节点的权值： &quot;&lt;&lt;HT[i].weight&lt;&lt;endl;
//这一句是输入测试，ok了
        word_select++;//到下一个防止连续搞
    &#125;//到这一步都没问题，叶子节点权值都录入了
    /*初始化工作结束，下面开始创建哈夫曼树*/
//    cout&lt;&lt;&quot;n=:&quot;&lt;&lt;n&lt;&lt;endl;
    for (int i = n + 1;i &lt;= m;++i)
    &#123;//通过n-1次的选择、删除、合并来创建哈夫曼树
        Select(HT,  s1, s2,n);//选择两个其双亲域为0且权值最小的结点
//        cout&lt;&lt;i-15&lt;&lt;&quot;次操作之后 &quot; &lt;&lt;&quot;s1 now=&quot;&lt;&lt;s1&lt;&lt;&quot; HT[s1].weight=&quot;&lt;&lt;HT[s1].weight;
//        cout&lt;&lt;&quot;  s2 now =&quot;&lt;&lt;s2&lt;&lt;&quot; HT[s2].weight=&quot;&lt;&lt;HT[s2].weight&lt;&lt;endl;
        HT[s1].parent = i;HT[s2].parent = i;//得到新结点i,将s1\s2的双亲域由0改为i
        HT[i].lchild = s1;HT[i].rchild = s2;//s1、s2分别作为i的左右孩子
        HT[i].weight = HT[s1].weight + HT[s2].weight;//i的权值为左右孩子的权值之和
//        cout&lt;&lt;&quot;  HT now =&quot;&lt;&lt;i&lt;&lt;&quot; HT[i].weight=&quot;&lt;&lt;HT[i].weight&lt;&lt;endl;
    &#125;
&#125;
typedef char** HuffmanCode;
////动态分配数组存储哈夫曼编码表
void CreatHuffmanCode(HuffmanTree HT, HuffmanCode&amp; HC, int n)//完全没有开始写的
&#123;//从叶子到根逆向求每个字符的哈夫曼编码，储存在编码表HC中
    HC = new char* [n + 1];//分配n个字符编码的头指针矢量
     char *cd = new char[n];//分配临时存放编码的动态数组空间
     int start;
     int c;
     int f;
    cd[n - 1] = &#39;\0&#39;;//编码结束符
    for (int i = 1;i &lt;= n;++i)//逐个字符求哈夫曼编码
    &#123;
        start = n - 1;//start开始时指向最后，即编码结束符的位置
        c = i;f = HT[i].parent;//f指向结点c的双亲结点
        while (f != 0)//从叶子结点开始向上回溯，直到根结点
        &#123;
            --start;//回溯一次，start向前指一个位置
            if (HT[f].lchild == c)
                cd[start] = &#39;0&#39;;//结点c是f的左孩子，则生成代码0
            else
                cd[start] = &#39;1&#39;;//结点c是f的右孩子，则生成代码1
            c = f;f = HT[f].parent;//继续向上回溯
        &#125;//求出第i个字符的编码
        HC[i] = new char[n - start];//为敌i个字符编码分配空间
        strcpy(HC[i], &amp;cd[start]);//将求得的编码从临时空间cd复制到HC当前行中
    &#125;
    delete cd;//释放临时空间
&#125;
char out[128]=&#123;&#39;\0&#39;&#125;;
int word[128]=&#123;0&#125;;//作为字母
int main() &#123;
    string ans=&quot;&quot;;
    string temp;
    while (getline(cin, temp)) &#123;
        if (temp == &quot;0&quot;) &#123;
            break;
        &#125;
        ans+=temp;
    &#125;//读入阶段
    int length=ans.size();
    for(int i=0;i&lt;length;i++)
    &#123;
        int idx=(int)(ans[i]);
        word[idx]++;
    &#125;
    int node_num=0;
    for(int i=1;i&lt;=128;i++)
    &#123;
        if(word[i]!=0)
        &#123;
            ++node_num;
            out[node_num]=(char)i;
//            cout &lt;&lt;(char)i &lt;&lt; &quot;: &quot;&lt;&lt; word[i] &lt;&lt; endl;
            //这里获得了对应的编码
        &#125;
    &#125;
    HuffmanTree HT;
    CreateHuffmanTree(HT,node_num,word);
    HuffmanCode HC;
    CreatHuffmanCode(HT,HC,node_num);
    for(int i=1;i&lt;=node_num;i++)
    &#123;
        cout&lt;&lt;out[i]&lt;&lt;&quot;:&quot;&lt;&lt;HC[i]&lt;&lt;endl;
    &#125;
    return 0;
&#125;
</code></pre>
<p>代码：</p>
<pre><code class="c++">// C++ program for Huffman Coding
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

// This constant can be avoided by explicitly
// calculating height of Huffman Tree
#define MAX_TREE_HT 100

// A Huffman tree node
struct MinHeapNode &#123;

    // One of the input characters
    char data;

    // Frequency of the character
    unsigned freq;

    // Left and right child of this node
    struct MinHeapNode *left, *right;
&#125;;

// A Min Heap: Collection of
// min-heap (or Huffman tree) nodes
struct MinHeap &#123;

    // Current size of min heap
    unsigned size;

    // capacity of min heap
    unsigned capacity;

    // Array of minheap node pointers
    struct MinHeapNode** array;
&#125;;

// A utility function allocate a new
// min heap node with given character
// and frequency of the character
struct MinHeapNode* newNode(char data, unsigned freq)
&#123;
    struct MinHeapNode* temp
        = (struct MinHeapNode*)malloc
(sizeof(struct MinHeapNode));

    temp-&gt;left = temp-&gt;right = NULL;
    temp-&gt;data = data;
    temp-&gt;freq = freq;

    return temp;
&#125;

// A utility function to create
// a min heap of given capacity
struct MinHeap* createMinHeap(unsigned capacity)

&#123;

    struct MinHeap* minHeap
        = (struct MinHeap*)malloc(sizeof(struct MinHeap));

    // current size is 0
    minHeap-&gt;size = 0;

    minHeap-&gt;capacity = capacity;

    minHeap-&gt;array
        = (struct MinHeapNode**)malloc(minHeap-&gt;
capacity * sizeof(struct MinHeapNode*));
    return minHeap;
&#125;

// A utility function to
// swap two min heap nodes
void swapMinHeapNode(struct MinHeapNode** a,
                    struct MinHeapNode** b)

&#123;

    struct MinHeapNode* t = *a;
    *a = *b;
    *b = t;
&#125;

// The standard minHeapify function.
void minHeapify(struct MinHeap* minHeap, int idx)

&#123;

    int smallest = idx;
    int left = 2 * idx + 1;
    int right = 2 * idx + 2;

    if (left &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[left]-&gt;
freq &lt; minHeap-&gt;array[smallest]-&gt;freq)
        smallest = left;

    if (right &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[right]-&gt;
freq &lt; minHeap-&gt;array[smallest]-&gt;freq)
        smallest = right;

    if (smallest != idx) &#123;
        swapMinHeapNode(&amp;minHeap-&gt;array[smallest],
                        &amp;minHeap-&gt;array[idx]);
        minHeapify(minHeap, smallest);
    &#125;
&#125;

// A utility function to check
// if size of heap is 1 or not
int isSizeOne(struct MinHeap* minHeap)
&#123;

    return (minHeap-&gt;size == 1);
&#125;

// A standard function to extract
// minimum value node from heap
struct MinHeapNode* extractMin(struct MinHeap* minHeap)

&#123;

    struct MinHeapNode* temp = minHeap-&gt;array[0];
    minHeap-&gt;array[0]
        = minHeap-&gt;array[minHeap-&gt;size - 1];

    --minHeap-&gt;size;
    minHeapify(minHeap, 0);

    return temp;
&#125;

// A utility function to insert
// a new node to Min Heap
void insertMinHeap(struct MinHeap* minHeap,
                struct MinHeapNode* minHeapNode)

&#123;

    ++minHeap-&gt;size;
    int i = minHeap-&gt;size - 1;

    while (i &amp;&amp; minHeapNode-&gt;freq &lt; minHeap-&gt;array[(i - 1) / 2]-&gt;freq) &#123;

        minHeap-&gt;array[i] = minHeap-&gt;array[(i - 1) / 2];
        i = (i - 1) / 2;
    &#125;

    minHeap-&gt;array[i] = minHeapNode;
&#125;

// A standard function to build min heap
void buildMinHeap(struct MinHeap* minHeap)

&#123;

    int n = minHeap-&gt;size - 1;
    int i;

    for (i = (n - 1) / 2; i &gt;= 0; --i)
        minHeapify(minHeap, i);
&#125;

// A utility function to print an array of size n
void printArr(int arr[], int n)
&#123;
    int i;
    for (i = 0; i &lt; n; ++i)
        cout&lt;&lt; arr[i];

    cout&lt;&lt;&quot;\n&quot;;
&#125;

// Utility function to check if this node is leaf
int isLeaf(struct MinHeapNode* root)

&#123;

    return !(root-&gt;left) &amp;&amp; !(root-&gt;right);
&#125;

// Creates a min heap of capacity
// equal to size and inserts all character of
// data[] in min heap. Initially size of
// min heap is equal to capacity
struct MinHeap* createAndBuildMinHeap(char data[], int freq[], int size)

&#123;

    struct MinHeap* minHeap = createMinHeap(size);

    for (int i = 0; i &lt; size; ++i)
        minHeap-&gt;array[i] = newNode(data[i], freq[i]);

    minHeap-&gt;size = size;
    buildMinHeap(minHeap);

    return minHeap;
&#125;

// The main function that builds Huffman tree
struct MinHeapNode* buildHuffmanTree(char data[], int freq[], int size)

&#123;
    struct MinHeapNode *left, *right, *top;

    // Step 1: Create a min heap of capacity
    // equal to size. Initially, there are
    // modes equal to size.
    struct MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);

    // Iterate while size of heap doesn&#39;t become 1
    while (!isSizeOne(minHeap)) &#123;

        // Step 2: Extract the two minimum
        // freq items from min heap
        left = extractMin(minHeap);
        right = extractMin(minHeap);

        // Step 3: Create a new internal
        // node with frequency equal to the
        // sum of the two nodes frequencies.
        // Make the two extracted node as
        // left and right children of this new node.
        // Add this node to the min heap
        // &#39;$&#39; is a special value for internal nodes, not used
        top = newNode(&#39;$&#39;, left-&gt;freq + right-&gt;freq);

        top-&gt;left = left;
        top-&gt;right = right;

        insertMinHeap(minHeap, top);
    &#125;

    // Step 4: The remaining node is the
    // root node and the tree is complete.
    return extractMin(minHeap);
&#125;

// Prints huffman codes from the root of Huffman Tree.
// It uses arr[] to store codes
void printCodes(struct MinHeapNode* root, int arr[], int top)

&#123;

    // Assign 0 to left edge and recur
    if (root-&gt;left) &#123;

        arr[top] = 0;
        printCodes(root-&gt;left, arr, top + 1);
    &#125;

    // Assign 1 to right edge and recur
    if (root-&gt;right) &#123;

        arr[top] = 1;
        printCodes(root-&gt;right, arr, top + 1);
    &#125;

    // If this is a leaf node, then
    // it contains one of the input
    // characters, print the character
    // and its code from arr[]
    if (isLeaf(root)) &#123;

        cout&lt;&lt; root-&gt;data &lt;&lt;&quot;: &quot;;
        printArr(arr, top);
    &#125;
&#125;

// The main function that builds a
// Huffman Tree and print codes by traversing
// the built Huffman Tree
void HuffmanCodes(char data[], int freq[], int size)

&#123;
    // Construct Huffman Tree
    struct MinHeapNode* root
        = buildHuffmanTree(data, freq, size);

    // Print Huffman codes using
    // the Huffman tree built above
    int arr[MAX_TREE_HT], top = 0;

    printCodes(root, arr, top);
&#125;

// Driver code
int main()
&#123;

    char arr[] = &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;
    int freq[] = &#123; 5, 9, 12, 13, 16, 45 &#125;;

    int size = sizeof(arr) / sizeof(arr[0]);

    HuffmanCodes(arr, freq, size);

    return 0;
&#125;
/*
结果输出：
f: 0
c: 100
d: 101
a: 1100
b: 1101
e: 111
*/
</code></pre>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>平衡二叉树：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/code_peak/article/details/120610047?ops_request_misc=%7B%22request_id%22:%22166979063716782390568989%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166979063716782390568989&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120610047-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev2%5Et3_control1&utm_term=avl%E6%A0%91c++&spm=1018.2226.3001.4187" >(110条消息) AVL树的详细实现(C++)_code_peak的博客-CSDN博客_c++实现avl树<i class="fas fa-external-link-alt"></i></a></p>
<p>avl树的各种延申应用：伸展树，B树，字典树</p>

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="../../../../tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">#学习笔记</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95PART2/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">数据结构与算法 PART 2</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="../../08/web%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">web技术学习笔记</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9APART1"><span class="nav-number">1.</span> <span class="nav-text">数据结构与算法：PART1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">1.0.1.</span> <span class="nav-text">算法时间分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3idx"><span class="nav-number">1.0.2.</span> <span class="nav-text">理解idx:</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A7%91%E7%8F%AD%E5%AD%A6%E4%B9%A0%E9%A1%BA%E5%BA%8F%EF%BC%9A%EF%BC%88%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E6%8F%90%E9%AB%98%E5%86%99%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%89"><span class="nav-number">1.0.2.0.0.1.</span> <span class="nav-text">科班学习顺序：（如何逐步提高写程序的性能）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E5%8A%9E%E6%B3%95%EF%BC%9A"><span class="nav-number">1.0.2.0.0.2.</span> <span class="nav-text">提高程序性能办法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.0.2.0.0.3.</span> <span class="nav-text">程序运行时间因素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9E%B6%E6%9E%84"><span class="nav-number">1.0.2.0.0.4.</span> <span class="nav-text">冯诺依曼架构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="nav-number">1.0.2.0.0.5.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.3.</span> <span class="nav-text">基础算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.0.3.0.1.</span> <span class="nav-text">位运算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E2%80%94%E2%80%94%E3%80%8B%E9%87%8D%E8%A6%81%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%9E%8B%F0%9F%98%8D"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">快排——》重要，面试常用型😍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="nav-number">1.0.3.1.0.1.</span> <span class="nav-text">模板：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E5%90%88%E7%90%86%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%9AAcWing-785-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E%E4%B8%8E%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90-AcWing"><span class="nav-number">1.0.3.1.0.2.</span> <span class="nav-text">快排合理性分析：AcWing 785. 快速排序算法的证明与边界分析 - AcWing</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E7%A7%BB%E5%8A%A8%E7%89%88%E6%9C%AC%E5%BF%AB%E6%8E%92%EF%BC%88%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">1.0.3.1.1.</span> <span class="nav-text">单向移动版本快排（实际使用快慢指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.0.3.1.1.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#plus-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E6%8F%92%E5%85%A5-%E4%BA%8C%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E3%80%8B%E7%A8%B3%E5%AE%9A%E5%8F%88%E5%A5%BD%E4%BD%BF"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">plus:折半插入排序（插入+二分）——》稳定又好使</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.0.3.3.0.1.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.3.4.0.1.</span> <span class="nav-text">模板</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%B9%9F%E8%83%8C%E4%B8%8B%E6%9D%A5%EF%BC%89%F0%9F%98%83"><span class="nav-number">1.0.3.5.</span> <span class="nav-text">归并排序（另一个重要排序，也背下来）😃</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A-1"><span class="nav-number">1.0.3.5.0.1.</span> <span class="nav-text">模板：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E8%B6%A3%E5%BA%94%E7%94%A8%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">1.0.3.5.0.2.</span> <span class="nav-text">有趣应用：逆序对</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timsort%EF%BC%88%E4%BC%98%E5%8C%96%E5%90%8E%E5%BD%92%E5%B9%B6%EF%BC%89"><span class="nav-number">1.0.3.6.</span> <span class="nav-text">timsort（优化后归并）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%8F%90%E5%8F%96%E9%99%8D%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8D%87%E7%BA%A7%E4%B8%BA%E5%8D%87%E5%BA%8F"><span class="nav-number">1.0.3.6.0.1.</span> <span class="nav-text">核心：提取降序数组升级为升序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%A0%88%E5%A4%84%E7%90%86%E5%BD%92%E5%B9%B6"><span class="nav-number">1.0.3.6.0.2.</span> <span class="nav-text">核心：栈处理归并</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%88%86%E5%8C%BA%E9%95%BF%E5%BA%A6%E5%9C%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%89%8D%E9%A2%84%E5%85%88%E8%AE%A1%E7%AE%97"><span class="nav-number">1.0.3.6.0.3.</span> <span class="nav-text">核心：最小分区长度在排序之前预先计算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#timsort%E6%A8%A1%E6%9D%BF%EF%BC%88%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%EF%BC%81%EF%BC%89"><span class="nav-number">1.0.3.6.0.4.</span> <span class="nav-text">timsort模板（自己写的！）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">1.0.3.7.</span> <span class="nav-text">二分</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%88%E4%B8%A4%E7%A7%8D%EF%BC%89"><span class="nav-number">1.0.3.7.0.1.</span> <span class="nav-text">整数模板（两种）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A789-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4-AcWing%E9%A2%98%E5%BA%93"><span class="nav-number">1.0.3.7.0.2.</span> <span class="nav-text">整数经典例题：789. 数的范围 - AcWing题库</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#519-%E8%B7%B3%E7%9F%B3%E5%A4%B4-AcWing%E9%A2%98%E5%BA%93"><span class="nav-number">1.0.3.7.0.3.</span> <span class="nav-text">519. 跳石头 - AcWing题库</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.3.7.0.4.</span> <span class="nav-text">浮点模板</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%94%B9%E8%BF%9B%EF%BC%9A"><span class="nav-number">1.0.3.7.1.</span> <span class="nav-text">二分改进：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-number">1.0.3.7.1.1.</span> <span class="nav-text">插值查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="nav-number">1.0.3.7.1.2.</span> <span class="nav-text">关键不同：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="nav-number">1.0.3.7.1.3.</span> <span class="nav-text">斐波那契查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88%E5%BA%94%E7%94%A8%E5%B9%BF%E6%B3%9B%EF%BC%89"><span class="nav-number">1.0.3.8.</span> <span class="nav-text">前缀和（应用广泛）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8-x3D-LZW%E5%8E%8B%E7%BC%A9-gt-%E6%96%87%E6%9C%AC%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.0.3.8.1.</span> <span class="nav-text">前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E9%83%A8%E5%88%86%EF%BC%9A"><span class="nav-number">1.0.3.8.1.1.</span> <span class="nav-text">压缩部分：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E9%83%A8%E5%88%86%EF%BC%9A"><span class="nav-number">1.0.3.8.1.2.</span> <span class="nav-text">解压缩部分：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%9A%E6%95%B4%E6%95%B0%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">1.0.3.9.</span> <span class="nav-text">离散化：整数离散化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96%E6%A8%A1%E6%9D%BF%EF%BC%9A-c-%E7%89%88%E6%9C%AC"><span class="nav-number">1.0.3.9.0.1.</span> <span class="nav-text">离散化模板：(c++版本)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%EF%BC%9A%E4%B8%8D%E5%90%8C%E4%BA%8E%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">1.0.3.10.</span> <span class="nav-text">区间合并：不同于离散化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.0.3.10.0.1.</span> <span class="nav-text">步骤：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.3.10.0.2.</span> <span class="nav-text">代码模板</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.0.4.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="nav-number">1.0.4.1.0.1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%88%B6%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.0.4.1.0.2.</span> <span class="nav-text">链表制造方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%B6%E4%BD%9C"><span class="nav-number">1.0.4.1.0.3.</span> <span class="nav-text">单链表制作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%B6%E4%BD%9C"><span class="nav-number">1.0.4.1.0.4.</span> <span class="nav-text">双链表制作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">1.0.4.1.0.5.</span> <span class="nav-text">链表递归与双指针</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%A0%B7%E5%88%A9%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%EF%BC%9A%EF%BC%88%E6%9C%89%E9%82%A3%E4%B9%88%E4%B8%80%E7%82%B9%E7%82%B9%E8%B4%B9%E8%84%91%E5%AD%90%EF%BC%89"><span class="nav-number">1.0.4.1.0.6.</span> <span class="nav-text">同样利用递归实现链表逆序：（有那么一点点费脑子）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-1"><span class="nav-number">1.0.4.1.0.7.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%80%86%E5%BA%8F"><span class="nav-number">1.0.4.1.0.8.</span> <span class="nav-text">双指针实现逆序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8B%BC%E6%8E%A5%EF%BC%88%E5%8F%88%E6%98%AF%E9%80%92%E5%BD%92-x2F-bushi%EF%BC%89"><span class="nav-number">1.0.4.1.0.9.</span> <span class="nav-text">有序链表的拼接（又是递归&#x2F;bushi）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%EF%BC%9A%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E7%BF%BB%E8%BD%AC%EF%BC%89"><span class="nav-number">1.0.4.1.0.10.</span> <span class="nav-text">回文链表判断：（映射，递归，翻转）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zhan%EF%BC%88%E6%A0%88%EF%BC%89%E4%B8%8D%E6%98%AFB%E7%AB%99%E9%82%A3%E4%B8%AA"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">zhan（栈）不是B站那个</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A-1"><span class="nav-number">1.0.4.2.0.1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E5%88%B6%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.0.4.2.0.2.</span> <span class="nav-text">栈制造方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E5%81%9A%E9%9D%9E%E9%99%8D%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.4.2.0.3.</span> <span class="nav-text">栈做非降路径问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.0.4.2.0.4.</span> <span class="nav-text">中缀表达式转换后缀表达式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E6%9E%90"><span class="nav-number">1.0.4.2.0.5.</span> <span class="nav-text">正则表达式分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="nav-number">1.0.4.2.0.6.</span> <span class="nav-text">正则表达式代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%88%E7%9E%B3%E5%AD%94%E5%9C%B0%E9%9C%87%E5%9E%8B%E9%A2%98%E8%A7%A3%EF%BC%89%F0%9F%98%A2"><span class="nav-number">1.0.4.2.0.7.</span> <span class="nav-text">单调栈（瞳孔地震型题解）😢</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.0.4.3.0.1.</span> <span class="nav-text">队列构造方式：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">1.0.4.3.0.2.</span> <span class="nav-text">循环队列：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%EF%BD%9E%EF%BF%A3%E2%96%BD%EF%BF%A3-%EF%BD%9E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%BB%8F%E5%85%B8%EF%BC%88%E9%85%8D%E5%90%88%E5%8D%95%E8%B0%83%E6%A0%88%E9%A3%9F%E7%94%A8%EF%BC%89"><span class="nav-number">1.0.4.3.0.3.</span> <span class="nav-text">单调队列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">1.0.4.4.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#KMP"><span class="nav-number">1.0.4.4.1.</span> <span class="nav-text">KMP</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BFy%E6%80%BB"><span class="nav-number">1.0.4.4.1.1.</span> <span class="nav-text">模板y总</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF"><span class="nav-number">1.0.4.4.1.2.</span> <span class="nav-text">前缀表：字符串的最长</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%96%B9%E6%B3%95%EF%BC%9A%E5%89%8D%E7%BC%80%E4%B8%8D%E5%87%8F%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.0.4.4.1.3.</span> <span class="nav-text">代码随想录方法：前缀不减形式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%E5%87%BA%E9%94%99%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.0.4.4.1.4.</span> <span class="nav-text">数据结构作业出错原因</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#automata-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">1.0.4.4.2.</span> <span class="nav-text">automata~有限状态自动机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%88%E6%9E%84%E5%BB%BA%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%8A%B6%E6%80%81%E8%A1%A8%EF%BC%89"><span class="nav-number">1.0.4.4.2.1.</span> <span class="nav-text">代码（构建自动机状态表）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E7%89%88%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">1.0.4.4.2.2.</span> <span class="nav-text">聪明版本自动机</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TRIE%E6%A0%91%EF%BC%88%E6%9C%89%E4%BA%9B%E7%B1%BB%E4%BC%BC%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%EF%BC%89"><span class="nav-number">1.0.4.4.3.</span> <span class="nav-text">TRIE树（有些类似哈夫曼树编码）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%B2%E6%A0%91"><span class="nav-number">1.0.4.4.3.1.</span> <span class="nav-text">如何存储：构建串树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE"><span class="nav-number">1.0.4.4.3.2.</span> <span class="nav-text">如何查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BATRIE%E6%A0%91"><span class="nav-number">1.0.4.4.3.3.</span> <span class="nav-text">构建TRIE树</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TRIE%E6%A0%91%E7%9A%84%E5%85%B6%E5%AE%83%E5%BA%94%E7%94%A8"><span class="nav-number">1.0.4.4.4.</span> <span class="nav-text">TRIE树的其它应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.0.4.4.4.1.</span> <span class="nav-text">思路：利用二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="nav-number">1.0.4.4.4.2.</span> <span class="nav-text">算法复杂度：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="nav-number">1.0.4.4.4.3.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E2%80%94%E2%80%94%E5%90%8C%E6%A0%B7%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E4%BD%86%E6%98%AF%E4%B8%8D%E7%94%A8%E6%89%8B%E6%90%93"><span class="nav-number">1.0.4.5.</span> <span class="nav-text">跳表——同样面试——但是不用手搓</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%8F%82%E8%80%83%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%9A"><span class="nav-number">1.0.4.5.0.1.</span> <span class="nav-text">一些参考的博客：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">1.0.4.5.0.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="nav-number">1.0.4.5.0.3.</span> <span class="nav-text">核心思想：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.0.4.5.1.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.0.4.5.1.1.</span> <span class="nav-text">构建过程：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TRIE%E6%A0%91%E7%9A%84%E5%85%B6%E5%AE%83"><span class="nav-number">1.0.4.5.1.2.</span> <span class="nav-text">TRIE树的其它</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8-%E9%9D%A2%E8%AF%95%E5%BE%88%E9%87%8D%E8%A6%81"><span class="nav-number">1.0.4.6.</span> <span class="nav-text">散列表——哈希表-面试很重要</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">1.0.4.6.0.1.</span> <span class="nav-text">线性表总结：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%BA%94%E7%94%A8"><span class="nav-number">1.0.4.6.0.2.</span> <span class="nav-text">哈希定义，应用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E6%A8%A1%E6%9D%BF%EF%BC%88%E6%AD%A3%E5%B8%B8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-number">1.0.4.6.0.3.</span> <span class="nav-text">哈希模板（正常+字符串版本）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%B4%A2%E5%BC%95%E5%80%BC"><span class="nav-number">1.0.4.6.0.4.</span> <span class="nav-text">分配索引值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E7%B4%A2%E5%BC%95%E5%80%BC%EF%BC%9A"><span class="nav-number">1.0.4.6.0.5.</span> <span class="nav-text">减少索引值：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E2%80%94%E2%80%94-gt-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-number">1.0.4.6.1.</span> <span class="nav-text">字符串哈希——&gt;字符串前缀哈希法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%EF%BC%89%F0%9F%98%8D%F0%9F%98%8D%F0%9F%98%8D%F0%9F%98%8D%F0%9F%98%8D"><span class="nav-number">1.0.4.7.</span> <span class="nav-text">哈希碰撞处理（面试高频）😍😍😍😍😍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%88Open-Hashing%EF%BC%89"><span class="nav-number">1.0.4.7.0.1.</span> <span class="nav-text">拉链法（Open Hashing）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95-Open-Addressing"><span class="nav-number">1.0.4.7.0.2.</span> <span class="nav-text">开放地址法 Open Addressing</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%9C%E9%B9%83%E5%93%88%E5%B8%8C%F0%9F%98%8E"><span class="nav-number">1.0.4.8.</span> <span class="nav-text">杜鹃哈希😎</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5%E6%97%B6%EF%BC%9A"><span class="nav-number">1.0.4.8.0.1.</span> <span class="nav-text">失败时：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.0.4.9.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%EF%BC%880%E4%BD%9C%E4%B8%BA%E7%A9%BA%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BC%9A%E6%9C%89%E7%A9%BA%E9%97%B4%E6%B5%AA%E8%B4%B9%EF%BC%89"><span class="nav-number">1.0.4.9.0.1.</span> <span class="nav-text">完全二叉树的构建（0作为空节点，会有空间浪费）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">1.0.4.10.</span> <span class="nav-text">树的恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.0.4.10.1.</span> <span class="nav-text">由先序和中序恢复二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%83%8C%E4%B9%9F%E8%A6%81%E8%83%8C%E4%BC%9A%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.4.10.1.1.</span> <span class="nav-text">背也要背会的模板:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E6%B6%89%E5%8F%8A%E2%80%94%E2%80%94%E7%AB%9E%E8%B5%9B%E9%A2%91%E7%8E%87%E4%B9%9F%E9%AB%98%F0%9F%98%8D"><span class="nav-number">1.0.4.11.</span> <span class="nav-text">并查集——面试涉及——竞赛频率也高😍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="nav-number">1.0.4.11.0.1.</span> <span class="nav-text">并查集应用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">1.0.4.11.0.2.</span> <span class="nav-text">基本原理：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%99%E6%B3%95%EF%BC%9A"><span class="nav-number">1.0.4.11.0.3.</span> <span class="nav-text">写法：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96%EF%BC%9A%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.0.4.11.1.</span> <span class="nav-text">并查集优化：路径压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E5%8A%A0%E6%9D%83%E5%90%88%E5%B9%B6"><span class="nav-number">1.0.4.11.1.1.</span> <span class="nav-text">优化：加权合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%EF%BC%9A%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.0.4.12.</span> <span class="nav-text">堆：完全二叉树的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">1.0.4.12.0.1.</span> <span class="nav-text">堆的基本结构：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.0.4.12.0.2.</span> <span class="nav-text">基本函数：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%B0%8F%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="nav-number">1.0.4.12.0.3.</span> <span class="nav-text">构建小细节：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%EF%BC%9A"><span class="nav-number">1.0.4.12.1.</span> <span class="nav-text">开始构建：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%A0%86"><span class="nav-number">1.0.4.12.1.1.</span> <span class="nav-text">构建堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAup"><span class="nav-number">1.0.4.12.1.2.</span> <span class="nav-text">构建up</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAdown"><span class="nav-number">1.0.4.12.1.3.</span> <span class="nav-text">构建down</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%A0%86"><span class="nav-number">1.0.4.12.2.</span> <span class="nav-text">模拟堆</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7%EF%BC%9A"><span class="nav-number">1.0.4.12.2.1.</span> <span class="nav-text">解题技巧：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9Aonlogn"><span class="nav-number">1.0.4.12.3.</span> <span class="nav-text">堆排序：onlogn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="nav-number">1.0.4.12.4.</span> <span class="nav-text">代码：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%A0%86%EF%BC%88%E7%9B%B4%E6%8E%A5%E9%80%A0%E5%B0%8F%E6%A0%B9%E5%A0%86%EF%BC%89"><span class="nav-number">1.0.4.12.4.1.</span> <span class="nav-text">模拟堆（直接造小根堆）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E6%95%B4%E4%BD%93%EF%BC%89"><span class="nav-number">1.0.4.12.4.2.</span> <span class="nav-text">堆排序（整体）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.0.4.13.</span> <span class="nav-text">哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81-%E5%AD%97%E6%AF%8D"><span class="nav-number">1.0.4.13.1.</span> <span class="nav-text">哈夫曼编码:字母</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.4.13.1.1.</span> <span class="nav-text">贪心算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E4%BB%A3%E7%A0%81-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E5%B9%B6%E8%BE%93%E5%87%BA-%EF%BC%9A"><span class="nav-number">1.0.4.13.1.2.</span> <span class="nav-text">自己写的代码(输入字符串进行编码并输出)：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AVL%E6%A0%91"><span class="nav-number">1.0.4.14.</span> <span class="nav-text">AVL树</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2023</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">breayhing / SIRI</a>
            
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
            <div class="deploy-info info-item">
                
                    本站由 <span class="tooltip" data-content="GitHub Pages"><img src="/images/deploy-provider/github.png"></span> 提供部署服务
                
            </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
