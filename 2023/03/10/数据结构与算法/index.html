<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="CS笔记 , 代码">
    <meta name="description" content="目前在更进的一个小网站">
    <meta name="author" content="breayhing / SIRI">
    
    <title>
        
            数据结构与算法 PART 1 |
        
        Breayhing的博客
    </title>
    
<link rel="stylesheet" href="../../../../css/style.css">

    <link rel="shortcut icon" href="../../../../images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/head.png","font_size":"18px","font_family":"STKaiti","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"Ubiquitous assimilation || 做一条咸鱼，但是没事扑腾两下","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="../../../../images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               Breayhing的博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../index.html"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../archives"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="../../../../categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               target="_blank" rel="noopener" href="http://sirohune.site/"
                            >
                                友情链接
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../index.html">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../archives">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="../../../../categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       target="_blank" rel="noopener" href="http://sirohune.site/">友情链接</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">数据结构与算法 PART 1</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="../../../../images/head.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">breayhing / SIRI</span>
                            
                                <span class="author-label">Lv2</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-03-10 17:02:00</span>
        <span class="mobile">2023-03-10 17:02</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-03-10 17:05:19</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="../../../../tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>31.8k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>140 分钟</span>
        </span>
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="数据结构与算法：PART1"><a href="#数据结构与算法：PART1" class="headerlink" title="数据结构与算法：PART1"></a>数据结构与算法：PART1</h1><hr>
<h3 id="算法时间分析："><a href="#算法时间分析：" class="headerlink" title="算法时间分析："></a>算法时间分析：</h3><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF" >https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="理解idx"><a href="#理解idx" class="headerlink" title="理解idx:"></a>理解idx:</h3><p>我感觉idx相当于一个分配器，如果需要加入新的结点就用++idx分配出一个下标（最主要可以做到不重复地重新分配下标）</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5673/" >AcWing 835. 如何理解单(双)链表，Trie树和堆中的idx？ - AcWing<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<p><strong>所有数据结构 学习的同时一定要理解该种数据结构的使用范围，干什么的&#x2F;</strong></p>
<h6 id="科班学习顺序：（如何逐步提高写程序的性能）"><a href="#科班学习顺序：（如何逐步提高写程序的性能）" class="headerlink" title="科班学习顺序：（如何逐步提高写程序的性能）"></a>科班学习顺序：（如何逐步提高写程序的性能）</h6><p>基础程序设计-&gt;数据结构与算法-&gt;操作系统-&gt;编译器的优化（编译原理）</p>
<h6 id="提高程序性能办法："><a href="#提高程序性能办法：" class="headerlink" title="提高程序性能办法："></a>提高程序性能办法：</h6><p>好的算法：正确性，可读性，健壮性，效率</p>
<h6 id="程序运行时间因素"><a href="#程序运行时间因素" class="headerlink" title="程序运行时间因素"></a>程序运行时间因素</h6><ol>
<li>所用算法</li>
<li>问题的规模</li>
<li>书写程序所用语言-&gt;级别越高效率越低</li>
<li>编译程序所用的机器(mac比windows快)</li>
<li>机器执行所用的速度（涉及到硬件，比如老电脑和新电脑）</li>
</ol>
<p>算法时间度量：<strong>为了完成某一问题机器所做的操作执行次数</strong></p>
<p>统计方法：写代码前&#x2F;写代码后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum=<span class="number">0</span>, n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//执行n+1次</span></span><br><span class="line">&#123;</span><br><span class="line">sum+=i;<span class="comment">//执行n次</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum;<span class="comment">//执行n次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="冯诺依曼架构"><a href="#冯诺依曼架构" class="headerlink" title="冯诺依曼架构"></a>冯诺依曼架构</h6><p>I&#x2F;O&lt;-&gt;中央存储单元&lt;-&gt;</p>
<p>CPU:解析指令</p>
<p>内存：存储指令和数据</p>
<p>程序大小相对不重要，执行操作与数据重要</p>
<h6 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h6><p>通过计算算法所创建的空间大小。</p>
<h3 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h3><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure>



<h4 id="快排——》重要，面试常用型😍"><a href="#快排——》重要，面试常用型😍" class="headerlink" title="快排——》重要，面试常用型😍"></a>快排——》重要，面试常用型😍</h4><p>快排本质就是使用<strong>分治思想，递归实现</strong></p>
<p><strong>最快onlogn，最慢oN2</strong></p>
<p>步骤：</p>
<ol>
<li>确定分界点</li>
<li>调整范围<strong>（最麻烦部分）</strong></li>
<li>对左右两边进行操作</li>
</ol>
<h6 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//记住开头不变，最后右边是j+1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//左右指针相遇时候返回</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];<span class="comment">//这里x暂时设定为左右边界的中间值，原因在于后边是do while指令，因此提前ij各往外移动一个位置</span></span><br><span class="line">     <span class="comment">//第一步：分成子问题</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;<span class="comment">//注意这个顺序一定不能错</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="comment">//容易错的点：要在这里打一个if</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);<span class="comment">//swap函数自己补充，这里ij可以相等</span></span><br><span class="line">    &#125;<span class="comment">//这样操作过一轮之后x左边都是比它小的，右边都是比它大的</span></span><br><span class="line">    <span class="comment">//第二步：递归处理子问题</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);<span class="comment">//这里一定一定是j，i会出问题</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里两步的顺序一定一定记住，不然可能无限划分</span></span><br><span class="line">    <span class="comment">//接着对它左右两端进行同样一次的操作，递归到最后就是全部完成排序</span></span><br><span class="line">    <span class="comment">//第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如原本为a[<span class="number">10</span>]，数据为a[<span class="number">0</span>]-a[<span class="number">9</span>];</span><br><span class="line">则排序为</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, <span class="number">0</span>, <span class="number">9</span>);<span class="comment">//注意这里很容易错误弄范围</span></span><br></pre></td></tr></table></figure>



<h6 id="快排合理性分析：AcWing-785-快速排序算法的证明与边界分析-AcWing"><a href="#快排合理性分析：AcWing-785-快速排序算法的证明与边界分析-AcWing" class="headerlink" title="快排合理性分析：AcWing 785. 快速排序算法的证明与边界分析 - AcWing"></a>快排合理性分析：<a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/16777/" >AcWing 785. 快速排序算法的证明与边界分析 - AcWing<i class="fas fa-external-link-alt"></i></a></h6><p>由于使用do-while循环,所以i和j一定会!!!自增!!!,使得循环会继续下去,但是如果采用while循环(i和j的初始化做出对应的变更),<strong>i和j在特殊情况下不自增的话,循环就会卡死</strong></p>
<p>边界问题：</p>
<p>快排属于分治算法，<strong>最怕的就是 n分成0和n，或 n分成n和0,这会造成无限划分</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q[i] &lt; x) i++;</span><br><span class="line">  <span class="keyword">while</span>(q[j] &gt; x) j--;</span><br><span class="line">当q[i]和q[j]都为 x 时, i 和 j 都不会更新,导致 <span class="keyword">while</span> 陷入死循环</span><br></pre></td></tr></table></figure>

<h5 id="单向移动版本快排（实际使用快慢指针）"><a href="#单向移动版本快排（实际使用快慢指针）" class="headerlink" title="单向移动版本快排（实际使用快慢指针）"></a>单向移动版本快排（实际使用快慢指针）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pivot = arr[low]; <span class="comment">// 待比较的基准元素</span></span><br><span class="line">	<span class="type">int</span> i = low;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = low + <span class="number">1</span>; j &lt;= high; j++) </span><br><span class="line">    &#123; <span class="keyword">if</span> (arr[j] &lt; pivot) </span><br><span class="line">    	&#123; i++; 		<span class="comment">//最终i停留的位置是要交换的位置</span></span><br><span class="line">     		<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">swap</span>(arr[i], arr[low]); </span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123; </span><br><span class="line">    	<span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line">		<span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>); </span><br><span class="line">		<span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种排序实际上将数组分成了三个部分：比pivot小，pivot，比pivot大，因此分治部分只需要对于pi-1和pi+1进行操作就行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行逻辑：指针j运行快，i运行慢，j只会在遇到比基准元素大的时候跳过</p>
<p>正常流程：如果j指向的都是比pivot小的元素，ji同步运动，指针一直向右走</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-02%20124330.png"
                      alt="屏幕截图 2022-11-02 124330"
                ></p>
<p>如果j右边是比pivot大的元素，即i右边紧挨着就是更大的元素，j跳过，i停留不移动</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-02%20124554.png"
                      alt="屏幕截图 2022-11-02 124554"
                ></p>
<p>然后让i++，刚好就到了大的元素，进行交换</p>
<p>结束情况：j遍历完成，i最后右移一次，停止</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-02%20124702.png"
                      alt="屏幕截图 2022-11-02 124702"
                ></p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>接着就是分治了</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, key, j; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		key = arr[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果大于key需要向后移动一位</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key)</span><br><span class="line">        &#123;<span class="comment">//直接插入是一直插入到对比结束</span></span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j]; j = j - <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="plus-折半插入排序（插入-二分）——》稳定又好使"><a href="#plus-折半插入排序（插入-二分）——》稳定又好使" class="headerlink" title="plus:折半插入排序（插入+二分）——》稳定又好使"></a>plus:折半插入排序（插入+二分）——》稳定又好使</h4><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> item, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) &#123; <span class="keyword">return</span> (item &gt; a[low]) ? (low + <span class="number">1</span>) : low;&#125; </span><br><span class="line"> 	<span class="type">int</span> mid = (low + high) / <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span> (item == a[mid]) &#123; <span class="keyword">return</span> mid + <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (item &gt; a[mid]) &#123; <span class="keyword">return</span> <span class="built_in">binarySearch</span>(a, item, mid + <span class="number">1</span>, high);&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">binarySearch</span>(a, item, low, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//二分搜索部分</span></span><br><span class="line"><span class="comment">//注意二分一定有解，但是答案不一定有解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, loc, j, k, selected; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">         j = i - <span class="number">1</span>;</span><br><span class="line">		selected = a[i];</span><br><span class="line">		<span class="comment">// 寻找应该插入的位置</span></span><br><span class="line">		loc = <span class="built_in">binarySearch</span>(a, selected, <span class="number">0</span>, j);</span><br><span class="line">        <span class="comment">//这里直接找到，后面的while循环就不需要再考虑对比，直接上就行</span></span><br><span class="line">		<span class="comment">// 移动后面所有的数据</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= loc) </span><br><span class="line">        &#123; </span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">         	j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = selected;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h6 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从大gap开始，逐步减少gap</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) </span><br><span class="line">	&#123; </span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i += <span class="number">1</span>) </span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">// i 是直接插入排序算法中待插入的元素int temp = arr[i];</span></span><br><span class="line"><span class="comment">// 向前查找，并同时移位</span></span><br><span class="line">			<span class="type">int</span> j;</span><br><span class="line">			<span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) </span><br><span class="line">			&#123; </span><br><span class="line">    			arr[j] = arr[j - gap];</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">// 把i元素放入合适的位置</span></span><br><span class="line">			arr[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序（另一个重要排序，也背下来）😃"><a href="#归并排序（另一个重要排序，也背下来）😃" class="headerlink" title="归并排序（另一个重要排序，也背下来）😃"></a>归并排序（另一个重要排序，也背下来）😃</h4><p><strong>不太好的点：归并排容易爆内存</strong></p>
<h6 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//最后拆分成单元素的时候就返回</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//二分</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="comment">//以上先疯狂二分，将整个数组全部拆分成最小部分，然后下面部分开始递归合并</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">   	分别作用：</span><br><span class="line">        k用于tmp数组，因此从<span class="number">0</span>开始</span><br><span class="line">        i从最左，j从中间开始向右</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<span class="comment">//这里由于递归，每一个小数组都归并好了，归并最后的大数组</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<span class="comment">//归并，结果合并到tmp，</span></span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<span class="comment">//赋值剩下的i</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<span class="comment">//赋值剩下的j</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, k = <span class="number">0</span>; i &lt;= r; i ++, k ++ ) q[i] = tmp[k];</span><br><span class="line">    k代表临时数组的值</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值回去，使得q同步变得有序，用于小数组递归回去用</span></span><br><span class="line">    <span class="comment">//憋想着省去这一步，不然小数组无法被弄成有序，最后归并会失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用举例：</p>
<p>几个注意点：</p>
<ul>
<li>tmp一开始就声明（不然爆内存）</li>
<li>merge里面j&#x3D;mid+1（这里弄错之后排序都不对劲）</li>
<li>merge函数中i与j的范围记得别被错</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> array[N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;<span class="comment">//j的赋值容易不对劲</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&lt;=array[j])tmp[k++]=array[i++];<span class="comment">//这里判断的时候还是加‘=’</span></span><br><span class="line">        <span class="keyword">else</span> tmp[k++]=array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;tmp[k++]=array[i++];&#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)&#123;tmp[k++]=array[j++];&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)<span class="comment">//这里的范围也容易搞混</span></span><br><span class="line">    &#123;<span class="comment">//注意归并排序中所有都是&lt;=</span></span><br><span class="line">        array[i]=tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid=(i+j)/<span class="number">2</span>;<span class="comment">//这里有一个特别狠的二分</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">mergesort</span>(l,mid);</span><br><span class="line">    <span class="built_in">mergesort</span>(mid+<span class="number">1</span>,r);<span class="comment">//这里需要+1</span></span><br><span class="line">    <span class="built_in">merge</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mergesort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;array[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="有趣应用：逆序对"><a href="#有趣应用：逆序对" class="headerlink" title="有趣应用：逆序对"></a>有趣应用：逆序对</h6><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/790/" >788. 逆序对的数量 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="timsort（优化后归并）"><a href="#timsort（优化后归并）" class="headerlink" title="timsort（优化后归并）"></a>timsort（优化后归并）</h4><p>这个就看苏老师的ppt课件</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35678407/article/details/82974174?ops_request_misc=%7B%22request_id%22:%22166806089616782425695863%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166806089616782425695863&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82974174-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev2%5Et3_control1&utm_term=timsort&spm=1018.2226.3001.4187" >(105条消息) Timsort——自适应、稳定、高效排序算法_码到sucess的博客-CSDN博客_timsort<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="核心：提取降序数组升级为升序"><a href="#核心：提取降序数组升级为升序" class="headerlink" title="核心：提取降序数组升级为升序"></a>核心：提取降序数组升级为升序</h6><p>数组本质都是部分有序的,</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-09%20152030.png"
                      alt="屏幕截图 2022-11-09 152030"
                ></p>
<p>因此第一步：将所有部分降序数组全部翻转（这里直接逆序就好）</p>
<p>这一步模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=r;i&lt;=j;i++,j--)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">array_reverse</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,tmp=<span class="number">0</span>,stage_judge;</span><br><span class="line">    <span class="keyword">if</span>(q[<span class="number">0</span>]&lt;=q[<span class="number">1</span>])stage_judge=<span class="number">1</span>;<span class="comment">//升序标记</span></span><br><span class="line">    <span class="keyword">else</span>  stage_judge=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&gt;q[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stage_judge==<span class="number">1</span>)stage_judge=<span class="number">0</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q[i]&lt;=q[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stage_judge==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp!=l<span class="number">-1</span>)++l;</span><br><span class="line">                <span class="built_in">reverse</span>(q,l,i);</span><br><span class="line">                tmp=i;</span><br><span class="line">                stage_judge=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;<span class="comment">//前进一个</span></span><br><span class="line">            l=i;<span class="comment">//l=前进一位之后的i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="核心：栈处理归并"><a href="#核心：栈处理归并" class="headerlink" title="核心：栈处理归并"></a>核心：栈处理归并</h6><p>先将所有已知的升序排列的压入总栈，</p>
<p>这一步：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">stack_check</span><span class="params">(<span class="type">int</span> N)</span><span class="comment">//对栈进行检验,并且要的是归并两个连续短区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> stack_pos1,stack_pos2,stack_pos3;</span><br><span class="line">    <span class="type">int</span> stack_length1,stack_length2,stack_length3;<span class="comment">//1最顶，3最底层</span></span><br><span class="line">    <span class="built_in">pop</span>(stack_pos1,stack_length1);</span><br><span class="line">    <span class="built_in">pop</span>(stack_pos2,stack_length2);</span><br><span class="line">    <span class="built_in">pop</span>(stack_pos3,stack_length3);</span><br><span class="line">    <span class="keyword">if</span>(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)<span class="comment">//x&gt;y或者x+y&gt;z</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_length1&gt;stack_length3)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">push</span>(stack_pos1,stack_length1);</span><br><span class="line">                <span class="built_in">merge</span>(stack_pos3, stack_length3,stack_pos2, stack_length2 );<span class="comment">//对yz进行归并</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                    <span class="built_in">push</span>(stack_pos3,stack_length3);</span><br><span class="line">                    <span class="built_in">merge</span>(stack_pos2,stack_length2,stack_pos1,stack_length1);<span class="comment">//对xy进行归并</span></span><br><span class="line">        &#125;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;q[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(stack_idx&gt;=<span class="number">2</span>)<span class="built_in">stack_check</span>(N);<span class="comment">//递归检测</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//按照原先顺序再压进去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push</span>(stack_pos3,stack_length3);</span><br><span class="line">        <span class="built_in">push</span>(stack_pos2,stack_length2);</span><br><span class="line">        <span class="built_in">push</span>(stack_pos1,stack_length1);</span><br><span class="line">        cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="核心：最小分区长度在排序之前预先计算"><a href="#核心：最小分区长度在排序之前预先计算" class="headerlink" title="核心：最小分区长度在排序之前预先计算"></a>核心：最小分区长度在排序之前预先计算</h6><p>➢ 归并过程低效的主要原因是大分区和小分区合并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(stack_idx&gt;=<span class="number">1</span>)<span class="comment">//输出阶段,这里就是检测是否正确归并入栈，没有归并</span></span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">pop</span>(stack_pos1,stack_length1);</span><br><span class="line">        <span class="built_in">pop</span>(stack_pos2,stack_length2);</span><br><span class="line">       <span class="keyword">if</span>(stack_pos1&gt;stack_pos2)<span class="built_in">merge</span>(stack_pos2,stack_length2,stack_pos1,stack_length1);</span><br><span class="line">       <span class="keyword">else</span> <span class="built_in">merge</span>(stack_pos1,stack_length1,stack_pos2,stack_length2);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;q[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h6 id="timsort模板（自己写的！）"><a href="#timsort模板（自己写的！）" class="headerlink" title="timsort模板（自己写的！）"></a>timsort模板（自己写的！）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M =<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> q[M];</span><br><span class="line"><span class="type">int</span> tmp[M];</span><br><span class="line"><span class="type">int</span> pos_stack[M];<span class="comment">//存储下标</span></span><br><span class="line"><span class="type">int</span> length_stack[M];<span class="comment">//存储长度</span></span><br><span class="line"><span class="type">int</span> stack_idx=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos_stack[++stack_idx]=pos;</span><br><span class="line">    length_stack[stack_idx]=length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> &amp;tmp_pos,<span class="type">int</span> &amp;tmp_length)</span><span class="comment">//给两个数赋值然后弄出去</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmp_pos= pos_stack[stack_idx];</span><br><span class="line">    tmp_length= length_stack[stack_idx];</span><br><span class="line">    --stack_idx;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=r;i&lt;=j;i++,j--)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">array_reverse</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,tmp=<span class="number">0</span>,tem_l=<span class="number">0</span>,stage_judge;</span><br><span class="line">    <span class="keyword">if</span>(q[<span class="number">0</span>]&lt;=q[<span class="number">1</span>])stage_judge=<span class="number">1</span>;<span class="comment">//升序标记</span></span><br><span class="line">    <span class="keyword">else</span>  stage_judge=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&gt;q[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stage_judge==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stage_judge=<span class="number">0</span>;<span class="comment">//之前是升序这里突然降序了</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q[i]&lt;=q[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stage_judge==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp!=l<span class="number">-1</span>)++l;</span><br><span class="line">                <span class="built_in">reverse</span>(q,l,i);</span><br><span class="line">                tmp=i;</span><br><span class="line">                stage_judge=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;<span class="comment">//前进一个</span></span><br><span class="line">            l=i;<span class="comment">//l=前进一位之后的i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> pos1,<span class="type">int</span> length1,<span class="type">int</span> pos2,<span class="type">int</span> length2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=pos2+length2<span class="number">-1</span>;<span class="comment">//最右端</span></span><br><span class="line">    <span class="type">int</span> l=pos1;<span class="comment">//最左端</span></span><br><span class="line">    <span class="comment">//归并部分</span></span><br><span class="line">    <span class="type">int</span> mid=pos1+length1<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = pos2 ;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<span class="comment">//这里由于递归，每一个小数组都归并好了，归并最后的大数组</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<span class="comment">//归并，结果合并到tmp，</span></span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<span class="comment">//赋值剩下的i</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<span class="comment">//赋值剩下的j</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">    <span class="built_in">push</span>(pos1,length1+length2);<span class="comment">//合并完之后进行压栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stack_check</span><span class="params">(<span class="type">int</span> N)</span><span class="comment">//对栈进行检验,并且要的是归并两个连续短区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> stack_pos1,stack_pos2,stack_pos3;</span><br><span class="line">    <span class="type">int</span> stack_length1,stack_length2,stack_length3;<span class="comment">//1最顶，3最底层</span></span><br><span class="line">    <span class="built_in">pop</span>(stack_pos1,stack_length1);</span><br><span class="line">    <span class="built_in">pop</span>(stack_pos2,stack_length2);</span><br><span class="line">    <span class="built_in">pop</span>(stack_pos3,stack_length3);</span><br><span class="line">    <span class="keyword">if</span>(stack_length2&lt;stack_length1||stack_length3&lt;stack_length1+stack_length2)<span class="comment">//x&gt;y或者x+y&gt;z</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_length1&gt;stack_length3)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">push</span>(stack_pos1,stack_length1);</span><br><span class="line">                <span class="built_in">merge</span>(stack_pos3, stack_length3,stack_pos2, stack_length2 );<span class="comment">//对yz进行归并</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                    <span class="built_in">push</span>(stack_pos3,stack_length3);</span><br><span class="line">                    <span class="built_in">merge</span>(stack_pos2,stack_length2,stack_pos1,stack_length1);<span class="comment">//对xy进行归并</span></span><br><span class="line">        &#125;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;idx: &quot;&lt;&lt;stack_idx&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;q[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(stack_idx&gt;=<span class="number">2</span>)<span class="built_in">stack_check</span>(N);<span class="comment">//递归检测</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//按照原先顺序再压进去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push</span>(stack_pos3,stack_length3);</span><br><span class="line">        <span class="built_in">push</span>(stack_pos2,stack_length2);</span><br><span class="line">        <span class="built_in">push</span>(stack_pos1,stack_length1);</span><br><span class="line">        cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并搞定</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="type">int</span> stack_pos1,stack_pos2,stack_pos3;</span><br><span class="line">    <span class="type">int</span> stack_length1,stack_length2,stack_length3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array_reverse</span>(q, N - <span class="number">1</span>);<span class="comment">//没问题了,别动！</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&gt;q[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push</span>(l,i-l+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            l=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//这里完成将栈压入</span></span><br><span class="line">    <span class="comment">//接下来就是找最大的，然后合并</span></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;q[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(stack_idx&gt;=<span class="number">2</span>)<span class="built_in">stack_check</span>(N);</span><br><span class="line">    <span class="keyword">while</span>(stack_idx&gt;=<span class="number">1</span>)<span class="comment">//输出阶段,这里就是检测是否正确归并入栈，没有归并</span></span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">pop</span>(stack_pos1,stack_length1);</span><br><span class="line">        <span class="built_in">pop</span>(stack_pos2,stack_length2);</span><br><span class="line">       <span class="keyword">if</span>(stack_pos1&gt;stack_pos2)<span class="built_in">merge</span>(stack_pos2,stack_length2,stack_pos1,stack_length1);</span><br><span class="line">       <span class="keyword">else</span> <span class="built_in">merge</span>(stack_pos1,stack_length1,stack_pos2,stack_length2);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;q[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//23         2 4 7 8 23 19 16 14 13 12 10 20 18 17 15 11 0 5 6 1 3 21 22</span></span><br></pre></td></tr></table></figure>



<h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>二分本质并不是单调性：有单调性一定可以二分解，可以二分解的题目不一定满足单调性，本质：可以将原本区间分成两个部分</p>
<p><em><strong>二分一定有解（自己的二分的性质是一定有边界的），但题目可能会无解</strong></em>（看例题）</p>
<p><strong>整数二分比实数二分蛋疼很多</strong>：整数有边界问题很恶心</p>
<p><strong>当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了</strong></p>
<h6 id="整数模板（两种）"><a href="#整数模板（两种）" class="headerlink" title="整数模板（两种）"></a>整数模板（两种）</h6><p>应用：</p>
<p>1：找大于等于数的第一个位置 （满足某个条件的第一个数）<br>2：找小于等于数的最后一个数 （满足某个条件的最后一个数）<br>3.查找最大值 （满足该边界的右边界）、<br>4.查找最小值 (满足该边界的左边界)</p>
<p>然后每次使用这这两个模板的时候，<strong>先想是找这个区间的左端点还是还是右端点，然后选择用模板，最后再去写判断条件</strong>。</p>
<p>设置红绿交界点是要求的位置</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-09%20210347.png"
                      alt="屏幕截图 2022-10-09 210347"
                ></p>
<ol>
<li>最后收敛到<strong>整个数组中满足条件的最右边的点</strong></li>
<li>最后收敛到数组中满足条件的<strong>最左边的点</strong></li>
</ol>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-09%20211416.png"
                      alt="屏幕截图 2022-10-09 211416"
                ></p>
<p>记忆方式：<em><strong>有减必有加</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心在于判断l=mid还是r=mid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//收敛到最右边的点</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：情况1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SR</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//需要补上l+r+1，防止死循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;<span class="comment">//有减，前面必定有加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//收敛到最左边的点</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：情况2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SL</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//这里是（l+2）/2</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质：</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> l;<span class="comment">//这里最终l和r相等，不需要考虑别的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="整数经典例题：789-数的范围-AcWing题库"><a href="#整数经典例题：789-数的范围-AcWing题库" class="headerlink" title="整数经典例题：789. 数的范围 - AcWing题库"></a>整数经典例题：<a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/791/" >789. 数的范围 - AcWing题库<i class="fas fa-external-link-alt"></i></a></h6><p>经典：二分模板最终一定有解，题目不一定有解（最后的判断不满足题目）</p>
<p>解答：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ-WNt-WNtw==,size_20,color_FFFFFF,t_70,g_se,x_16"
                      alt="在这里插入图片描述"
                ></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SL</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//最终结果是最左边满足条件的</span></span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SR</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//有+</span></span><br><span class="line">    <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;<span class="comment">//有-</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span> ( m-- ) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">SL</span>(<span class="number">0</span>, n - <span class="number">1</span>, x);<span class="comment">//查找左边界 并返回下标l</span></span><br><span class="line">        <span class="comment">//这里最后的L就是最左边第一个满足&gt;x的数字，也就是满足二分得到的结果（最接近x且&gt;=x）</span></span><br><span class="line">        <span class="comment">//因此下一步可以直接判断是否直接=x</span></span><br><span class="line">        <span class="keyword">if</span> (q[l]!=x) cout &lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;<span class="comment">//如果找不到  返回-1 -1</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">//如果找到了  输出左下标</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">SR</span>(<span class="number">0</span>, n - <span class="number">1</span>, x) &lt;&lt; endl; <span class="comment">//输出右下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样的例题：（爷跟你拼了）</p>
<h6 id="519-跳石头-AcWing题库"><a href="#519-跳石头-AcWing题库" class="headerlink" title="519. 跳石头 - AcWing题库"></a><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/521/" >519. 跳石头 - AcWing题库<i class="fas fa-external-link-alt"></i></a></h6><p>照样使用二分（虽然是比较复杂的二分）：<strong>二分,贪心</strong>O(NlogL)</p>
<p><em><strong>思路：</strong></em>使得选手们在比赛过程中的最短跳跃距离尽可能长，<strong>当出现最小值最大（最右端）或最大值最小（最左端）或求最大值、最小值时，就可以考虑一下二分了</strong>。验证答案具有单调性：<strong>拿走的石头越多，最短跳跃距离越大</strong>，这就叫答案的单调性</p>
<p>核心原理：</p>
<ul>
<li><strong>二分答案</strong><br>二分答案就是把一组数据每次分成两部分，就是把大问题转化成小问题。例如猜数游戏，猜1-100的一个数，就先猜50，若小了，就猜75，若大了，就猜25，就这样一直猜下去，最终找到答案。<strong>而我们每一次猜的这个答案就是所求范围内的数据的中间数据，这就是二分答案。这个二分的中间数据就是指要求的内容</strong>。</li>
<li><strong>如果长度 LenLen 可以满足，那么当长度小于 LenLen 时也可以满足，所以我们可以二分出最大的 LenLen。</strong>也就是在所有可满足的Len中寻找最右端的答案（这里指从0到最大），因此使用模板SR（再看上一道题实际上一个原理）</li>
<li>剩下的问题是如何判断给定 LenLen 的情况下，能否最多拿走 M块石头，使得所有相邻两块石头之间的距离不小于 LenLen。<strong>这一步可以贪心来做。从前往后扫描，<em>并记一下上一块石头的位置</em></strong>。</li>
<li><strong>如果当前石头和上一块石头的距离小于 LenLen，则将当前石头拿走</strong></li>
<li><strong>如果当前石头和上一块石头的距离大于等于 LenLen，则将上一块石头更新成当前这块。</strong>（和上一条是贪心时候的两种解法）</li>
<li>这里给出贪心证明：如果某个最优解中是拿走了上一块石头，那么我们可以改成留下上一块石头，拿走当前这块石头，这样总共拿走的石头数量不变，所以当前选法也是一组最优解。</li>
<li>check函数：<strong>我们遍历一遍每一块石头，累计出有多少块石头之间的间隔&lt;&#x3D;mid,如果超过m个，就不合法，如果小于等于m，就合法。</strong>(累计间隔小也就是需要搬走多少个石头)</li>
<li>扫描结束后判断拿走的石头数量是否小于等于 M。（<strong>判断这个答案能不能执行，能说明答案mid还能猜测更大，更新l，不能说明mid猜测过大了，更新r</strong>）</li>
</ul>
<p>时间复杂度分析<br>总共二分 O(logL)O(logL) 次，每次贪心的计算是 O(N)O(N)，因此总时间复杂度是 O(NlogL)O(NlogL)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//check函数判断这个最短跳跃距离x是否合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,last=<span class="number">0</span>; <span class="comment">//last表示的是上一块石头的位置,cnt用来计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//枚举每一块石头 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不移动走石头，就实时更新上一块石头位置，如果移动，就不更新</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]-last&lt;x) cnt++;<span class="comment">//如果这一块石头和上一块石头的距离比x小,计数+1。而且如果石头移走，last还是上一块石头的位置。</span></span><br><span class="line">        <span class="keyword">else</span> last=a[i]; <span class="comment">//否则这块石头就不必移走，last=这块石头的位置。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;m) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//cnt如果超过m个，就不合法。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    a[n+<span class="number">1</span>]=s;<span class="comment">//将终点的距离也算进去</span></span><br><span class="line"></span><br><span class="line">    n=n+<span class="number">1</span>;<span class="comment">//注意这里的n需要加一，check函数需要用</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=s; <span class="comment">//注意l和r都是最短跳跃距离的边界，而不是石头的边界。 </span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;<span class="comment">//答案猜小了</span></span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;<span class="comment">//答案猜大了</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/21312/" >https://www.acwing.com/blog/content/21312/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/118815/" >https://www.acwing.com/solution/content/118815/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/59bjss/" >https://leetcode.cn/leetbook/read/illustration-of-algorithm/59bjss/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/120802/" >https://www.acwing.com/solution/content/120802/<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="浮点模板"><a href="#浮点模板" class="headerlink" title="浮点模板"></a>浮点模板</h6><p>浮点好处在于不用考虑整数二分中的边界问题，因此直接用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;<span class="comment">//这里就不用多考虑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题：<a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/792/" >790. 数的三次方根 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-1000</span>,r = <span class="number">1000</span>;<span class="comment">//这里一开始范围设定大，直接从0开始</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt;= <span class="number">1e-7</span>) &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &lt;= x) l = mid;  <span class="comment">//如果是小于等于的话，就可以说明答案会更大</span></span><br><span class="line">        <span class="comment">//比较重要的一步，c++里面几次方就直接弄，别用mid^3,配合c++primer食用</span></span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.6lf&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二分改进："><a href="#二分改进：" class="headerlink" title="二分改进："></a>二分改进：</h5><h6 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h6><p>应用范围：<strong>表长较大，关键字分布均匀</strong></p>
<h6 id="关键不同："><a href="#关键不同：" class="headerlink" title="关键不同："></a>关键不同：</h6><p>二分mid固定为0.5，插值查找mid参数动态变化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;</span><br></pre></td></tr></table></figure>

<h6 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h6><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46359697/article/details/121952936?ops_request_misc=%7B%22request_id%22:%22166770338816782388045113%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166770338816782388045113&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-121952936-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE&spm=1018.2226.3001.4187" >(104条消息) 七大查找之斐波那契查找_非常规自我实现的博客-CSDN博客_fibonacci查找<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="前缀和（应用广泛）"><a href="#前缀和（应用广泛）" class="headerlink" title="前缀和（应用广泛）"></a>前缀和（应用广泛）</h4><p>数据结构应用：字符串哈希表kmp，自动机kmp，</p>
<h5 id="前缀和-哈希表-x3D-LZW压缩-gt-文本压缩"><a href="#前缀和-哈希表-x3D-LZW压缩-gt-文本压缩" class="headerlink" title="前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩"></a>前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩</h5><h6 id="压缩部分："><a href="#压缩部分：" class="headerlink" title="压缩部分："></a>压缩部分：</h6><h6 id="解压缩部分："><a href="#解压缩部分：" class="headerlink" title="解压缩部分："></a>解压缩部分：</h6><h4 id="离散化：整数离散化"><a href="#离散化：整数离散化" class="headerlink" title="离散化：整数离散化"></a>离散化：整数离散化</h4><p>如果使用哈希，会有额外的空间开销</p>
<p>特点：值域范围大，但是个数少（比如要访问到数组的10^9的位置，但个数只有10^5）也就是对于一个函数a-&gt;b，实际上只需要映射a，不需要操作b（<strong>当然高级玩家也可以继续弄b</strong>）。一般有两个问题：</p>
<ol>
<li>a数组里面可能有重复元素，因此需要<em><strong>去重</strong></em>，（去重是最重要的）</li>
<li>如何算出a[i]离散化后的值，<strong>保序离散化</strong>（a数组本身下标有序的），映射后一定也要是有序的，a[i].由于a有序，可以使用<strong>二分</strong></li>
</ol>
<p>需要使用的知识点：</p>
<ul>
<li>vector</li>
<li>pair</li>
</ul>
<h6 id="离散化模板：-c-版本"><a href="#离散化模板：-c-版本" class="headerlink" title="离散化模板：(c++版本)"></a>离散化模板：(c++版本)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alls存储的是最开始的下标</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">    <span class="comment">//前缀和从1开始相对方便</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/2321/" >AcWing 802. 区间和 - AcWing<i class="fas fa-external-link-alt"></i></a></p>
<p>分析：</p>
<p>使用离散化原因：</p>
<ol>
<li>存储下标过大，不能开这么大的下标</li>
<li>使用数轴，会存在负值，不能使用下标</li>
<li><strong>哈希表不能像离散化缩小数组的空间，可能导致遍历-e9~1e9</strong>。此处的含义就是假如我们需要计算1e-9和1e9区间内的值，那我们需要从前到后枚举，无论该值是否存在。<strong>因为哈希表不能排序</strong>，因此不能提前知道哪些数周上的点不存在，会枚举多次（如最后query的时候，从1到1e9，使用哈希表就要遍历才知道是否有点，时间开销太大），</li>
</ol>
<p>离散化本质：<strong>映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量</strong>，也就是<strong>如何能够将不连续的点映射到连续的数组的下标。</strong></p>
<p>本题解法：(离散化) O((n+2∗m)log(n+2∗m))</p>
<ol>
<li>开辟额外数组存放原来 的下标标志</li>
<li>对原来的数轴下标进行排序再去重，原因：考虑前缀和思想，我们需要求出的区间内的和的两端断点不一定有元素，提前加如需要求前缀和的两个端点，有利于我们进行二分搜索，其实二分搜索里面我们一般假定有解的，如果没解的话需要特判，所以提前加入了这些元素，从而导致可能出现重复元素</li>
<li>最多使用n+2m次操作，最多使用的下标跨度为3*10^5,</li>
</ol>
<p>首先用而二分写好映射后对应的数组下标，复杂度log(n + 2 * m)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全解：</p>
<p>关于unique和erease可以看</p>
<p>[(100条消息) C++ 之vector元素去重unique()_sandalphon4869的博客-CSDN博客_unique vector](<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/sandalphon4869/article/details/98209093?ops_request_misc=%7B%22request_id%22:%22166674706816800184111752%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166674706816800184111752&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-98209093-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=vector" >https://blog.csdn.net/sandalphon4869/article/details/98209093?ops_request_misc=%7B%22request%5Fid%22%3A%22166674706816800184111752%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166674706816800184111752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-98209093-null-null.142^v59^pc_rank_34_1,201^v3^control_1,213^v1^t3_control1&amp;utm_term=vector<i class="fas fa-external-link-alt"></i></a> unique&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>auto:<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/lwgkzl/article/details/82110068?ops_request_misc=%7B%22request_id%22:%22166674813816782412534322%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166674813816782412534322&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-82110068-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=auto&spm=1018.2226.3001.4187" >(100条消息) c++ auto基本用法_lwgkzl的博客-CSDN博客_auto用法<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;<span class="comment">//pair可以同时存储两个数据，可以理解成半封装的结构体</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;<span class="comment">//最多涉及的下标长度</span></span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;<span class="comment">//存储下标值</span></span><br><span class="line">vector&lt;PII&gt; add, query;<span class="comment">//分别存储询问和加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;<span class="comment">//为了最终的映射从1开始</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;:: <span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//这里是手动实现unique，非c++语言需要手动</span></span><br><span class="line">    <span class="comment">//作用为自动去重</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        <span class="keyword">if</span>(!i || a[i] != a[i - <span class="number">1</span>])</span><br><span class="line">            a[j ++ ] = a[i];</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, c;<span class="comment">//x是下标</span></span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="comment">//全部存储后alls组成为x,x,x,x,x,l1,r1,l2,r2等等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接unique(a)不加其它参数就是默认直接从头到尾，</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());<span class="comment">//对原来的数组下标进行从小到大</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos = <span class="built_in">unique</span>(alls);</span><br><span class="line">     <span class="comment">//pos是去重以后vector中没有重复元素的下一个位置的迭代器</span></span><br><span class="line">    <span class="comment">//从容器的开始到返回的迭代器位置的元素是不重复的元素，而从返回的迭代器位置到vector.end()的元素都是没有意义的（这东西就是原来排序后的东西，没变过）。</span></span><br><span class="line">    <span class="comment">//比如1 2 3 3 4 4 5 5unique后为1 2 3 4 5   5 5 5（别管这三个什么，没意义）</span></span><br><span class="line"></span><br><span class="line">    alls.<span class="built_in">erase</span>(pos, alls.<span class="built_in">end</span>());<span class="comment">//删除重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)<span class="comment">//add是一个vector&lt;PII&gt; add，为方便初始化这么用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);<span class="comment">//第一个值是要加的数的下标</span></span><br><span class="line">        a[x] += item.second;<span class="comment">//对应的数组位置加该数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="comment">//这里用前缀和方法求所有的前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), </span><br><span class="line">        r = <span class="built_in">find</span>(item.second);<span class="comment">//两个都是</span></span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//这里最后就是对应过来的减去后的值，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这些数据是验算用的</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span><span class="comment">//m。n</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>补充auto：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;<span class="comment">//这一步就是迭代器从begin走到end</span></span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间合并：不同于离散化"><a href="#区间合并：不同于离散化" class="headerlink" title="区间合并：不同于离散化"></a>区间合并：不同于离散化</h4><p>应用：很多区间，如果有交集就合并成一个更长的区间</p>
<p>区间合并算法：快速地进行多个区间的合并,当然可以进行一些特殊处理，比如对于端点就进行统一归并</p>
<h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li>按区间左端点进行排序</li>
<li>扫描过程中，对于所有有交集的区间进行合并。</li>
</ol>
<p>左边端点设置成start，右边设置成end，可能有的关系：</p>
<img  
                     lazyload
                     alt="image"
                     data-src="D:\me\配图\image-20221203210856611.png"
                      alt="image-20221203210856611" style="zoom:33%;" 
                >

<ol>
<li><strong>左右都在内部：原本区间不变</strong></li>
<li>仅一部分在内部：新的ed会边长（<strong>左端点不会更新，因为是按照左端点从小到大的顺序进行区间的扫描的</strong>）</li>
<li><strong>都不在内部：不用管就完事了</strong></li>
</ol>
<h6 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());<span class="comment">//这里是因为pair是默认按照左端点排序的</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)<span class="comment">//情况3：两个区间无法合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//区间1放进去res数组</span></span><br><span class="line">            st = seg.first, ed = seg.second;<span class="comment">//维护区间2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);<span class="comment">//情况12，可以合并，进行更新</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//考虑循环结束时的st,ed变量，此时的st,ed变量不需要继续维护，只需要放进res数组即可。</span></span><br><span class="line">    <span class="comment">//因为这是最后的一个序列，所以不可能继续进行合并。</span></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//说的就是你，最后一个序列，if就是防一下空序列</span></span><br><span class="line"></span><br><span class="line">    segs = res;<span class="comment">//这样回复的就是答案segs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大原因：排过序了，不用担心复用</span></span><br><span class="line"><span class="comment">//排过序之后，不可能有区间2包含区间1，只能是1包含后面的</span></span><br><span class="line"><span class="comment">//本质，遍历，每一次如果两个区间没有相交的部分（无法合并），那么就将一个区间推入作为答案，同时更新左右端点</span></span><br></pre></td></tr></table></figure>

<p>y总：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());<span class="comment">//先对于全部区间进行排序</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">-2e9</span>,r = <span class="number">-2e9</span>;<span class="comment">//小就完事了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:segs)<span class="comment">//定义了一个迭代器，这里是一个遍历的过程</span></span><br><span class="line">    &#123;<span class="comment">//! 第一段区间一定是  ed&lt; item.first</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt; item.first)<span class="comment">//当前区间右端点严格小于枚举区间的左边</span></span><br><span class="line">        &#123;<span class="comment">//情况1：两个区间无法合并</span></span><br><span class="line">            <span class="keyword">if</span>(l != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;l,r&#125;);<span class="comment">//! 第一次在这里初始化</span></span><br><span class="line">            <span class="comment">//区间1放进去res数组</span></span><br><span class="line">            l = item.first;<span class="comment">//! 第一段区间从这里开始即seg[0].first</span></span><br><span class="line">            <span class="comment">//维护区间2</span></span><br><span class="line">            r = item.second;<span class="comment">//第一段区间的。seg[0].second</span></span><br><span class="line">        &#125;<span class="comment">//todo 这个循环结束之后还会剩下一个区间</span></span><br><span class="line">        <span class="keyword">else</span> r = <span class="built_in">max</span>(r,item.second);<span class="comment">//第二种情况，说明有交集，右端点更新成维护的区间的右端点以及最大值</span></span><br><span class="line">    &#125;<span class="comment">//! 如果不是空的  那我们就加上一段</span></span><br><span class="line">    <span class="keyword">if</span>(l != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;l,r&#125;);<span class="comment">//最后一个区间判断一下，防止空区间</span></span><br><span class="line">    segs = res;<span class="comment">//区间更新变成res</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p> 有限性：数据元素个数有穷</p>
<p>相同性：数据元素的类型是同一的</p>
<p>顺序性：相邻的数据元素之间存在序偶关系</p>
<h6 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h6><ul>
<li><p>链表当中利用结构体制造链表的速度都是非常慢的，会消耗很多的时间，而正常面试中需要使用到链表时候大小都是有限制的，一般是十万或者百万的级别，而单单是new这些节点就会导致超时，<strong>在笔试题中最好不要用结构体指针</strong>，可以优化比如提前构建好多个节点，但已经类似于数组模拟链表了.<strong>算法题中绝对绝对不要考虑内存泄漏的问题</strong></p>
</li>
<li><p>使用结构体去构建链表的另一个问题在于键入指令会很麻烦</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组版本</span></span><br><span class="line"><span class="type">int</span> next[N],prev[N],valu[N]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[prev[k]]=next[k];<span class="comment">//向右跳过中间</span></span><br><span class="line">    prev[next[k]]=prev[k];<span class="comment">//向左跳过中间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体版本</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> valu,next,prev;</span><br><span class="line">&#125;nodes[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nodes[nodes[k].prev].next=nodes[k].next;</span><br><span class="line">    nodes[nodes[k].next].prev=nodes[k].prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两种类型相比第二种整体结构易于理解但是在使用过程中语句特别长而且不太容易理解</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>ps:算法题中大部分操作都是头插法</p>
<h6 id="链表制造方式"><a href="#链表制造方式" class="headerlink" title="链表制造方式"></a>链表制造方式</h6><ol>
<li>结构体+指针（c++需要使用new，费时间）</li>
<li>数组模拟（这里是静态数组，用空间换时间）</li>
</ol>
<p>小tips：邻接表<strong>本质就是n个单链表拼起来</strong>，正常一个head对应一条链表，这个就是开了一个组，head[i]对应第i条链表</p>
<p>数组模拟链表</p>
<ol>
<li>单链表：邻接表（实际上n个链表），主要应用在于存储图和树</li>
<li>双链表：优化某些问题</li>
</ol>
<h6 id="单链表制作"><a href="#单链表制作" class="headerlink" title="单链表制作"></a>单链表制作</h6><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/828/" >826. 单链表 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用版本的静态链表  </span></span><br><span class="line"><span class="comment">//e[n]:某个点的值，ne[n]:某个点的指针，使用下标关联起来</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n =<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//e[i]节点i</span></span><br><span class="line"><span class="comment">//ne[i]节点i的next指针指向的值</span></span><br><span class="line"><span class="comment">//idx存储已经用过哪一个点</span></span><br><span class="line"><span class="type">int</span> head,e[n],ne[n],idx;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个的灵魂在于idx,有了idx可以保证无论新插的节点是头插还是尾插都没区别，都会用来计数，然后在对第k个进行操作的时候直接就定位到了idx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head=<span class="number">-1</span>;<span class="comment">//让head指向一个空的位置</span></span><br><span class="line">    idx=<span class="number">0</span><span class="comment">//idx数量实际上就是链表当中总共节点的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">add_to_tail</span>(<span class="type">int</span> x)<span class="comment">//尾插</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="number">-1</span><span class="comment">//当是第一次插入时特殊处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        ne[idx]=head;</span><br><span class="line">        head=idx;</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=head;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="number">-1</span>)<span class="keyword">while</span>(ne[i]!=<span class="number">-1</span>)i=ne[i];<span class="comment">//最后ne[i]=-1</span></span><br><span class="line">    ne[idx]=<span class="number">-1</span>;</span><br><span class="line">    ne[i]=idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">add_to_head</span>(<span class="type">int</span> x)<span class="comment">//头插</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;<span class="comment">//保存x的值到一个新的位置</span></span><br><span class="line">    ne[idx]=head;<span class="comment">//更新指向，新元素指向原先head的位置，也就是-1（第一次跑）</span></span><br><span class="line">    head=idx;<span class="comment">//head头节点更新位置，更新到新元素的下标</span></span><br><span class="line">    idx++;<span class="comment">//下一个新的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">add</span>(<span class="type">int</span> k,<span class="type">int</span> x)<span class="comment">//注意和头插的区别在于位置变换的是ne[k]</span></span><br><span class="line">&#123;</span><br><span class="line">    k=k<span class="number">-1</span>；<span class="comment">//千万注意注意这里要改一下</span></span><br><span class="line">        <span class="comment">//否则会出范围的</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    e[idx]=x;<span class="comment">//先保存</span></span><br><span class="line">    ne[idx]=ne[k];<span class="comment">//指向原先k的位置</span></span><br><span class="line">    ne[k]=idx;</span><br><span class="line">    idx++;<span class="comment">//说明加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">delete</span>(<span class="type">int</span> k)<span class="comment">//tm惊为天人的简洁版本</span></span><br><span class="line">&#123;<span class="comment">//这里是删除第k个添加的，并不是按照值来删除</span></span><br><span class="line">    k=k<span class="number">-1</span>；<span class="comment">//千万注意注意这里要改一下</span></span><br><span class="line">        <span class="comment">//同样会出范围</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    ne[k]=ne[ne[k]];<span class="comment">//我tm直接更新ne[k]指向的位置，中间数直接损失指引</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">dele</span>(<span class="type">int</span> a)<span class="comment">//这个是删除某一个特定值</span></span><br><span class="line">       &#123;<span class="comment">//一个问题是如果只有一个元素需要特判</span></span><br><span class="line">           <span class="keyword">if</span>(e[head]==a)head=ne[head];<span class="comment">//直接清空就行</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=head;ne[i]!=<span class="number">-1</span>;i=ne[i])<span class="comment">//多个元素时候的删除操作</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(e[ne[i]]==a)<span class="comment">//这里关系是跳过中间</span></span><br><span class="line">               &#123;</span><br><span class="line">                   ne[i]=ne[ne[i]];</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head;i!=<span class="number">-1</span>;i=ne[i])<span class="comment">//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;e[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="双链表制作"><a href="#双链表制作" class="headerlink" title="双链表制作"></a>双链表制作</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>&lt;iostream&lt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> r[M],prev[M],e[M],index;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//双链表相对单链表的初始化不同</span></span><br><span class="line">   r[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//最左端指向最右端</span></span><br><span class="line">   l[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//最右端指向最左端</span></span><br><span class="line">   index=<span class="number">2</span>;<span class="comment">//另一个好处就是非常直白，双数肯定是向右的，单数向左的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_right</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span><span class="comment">//第k个的右边插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    <span class="comment">//新节点的延申部位都搞定了，开始双向连接</span></span><br><span class="line">    l[r[k]]=idx;</span><br><span class="line">    r[k]=idx<span class="comment">//</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向右插就是</span></span><br><span class="line">  <span class="built_in">add_to_right</span>( x, k+<span class="number">1</span>)<span class="comment">//k+1因为index从2开始计数</span></span><br><span class="line"><span class="comment">//聪明的方法，在左边插入直接调用add_to_right(x,l[k]),也就是在k的左边节点调用向右插，结果就是第k个节点左边插入</span></span><br><span class="line"><span class="built_in">add_to_right</span>( x, l[k+<span class="number">1</span>])<span class="comment">//同理</span></span><br><span class="line"><span class="comment">//如果是最左端或者最右端更简单</span></span><br><span class="line"><span class="comment">//最左端</span></span><br><span class="line"> <span class="built_in">add_to_right</span>( x, <span class="number">0</span>)</span><br><span class="line"> <span class="comment">//右端</span></span><br><span class="line"><span class="built_in">add_to_right</span>( x, l[<span class="number">1</span>])      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dele</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])<span class="comment">//灵魂在于这里每一次索引更新：i=ne[i]（因为静态数组里面下标所在位置不固定了）</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;e[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用的时候的api：</span></span><br><span class="line">	<span class="built_in">add_to_right</span>( x, k+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">add_to_left</span>(x,k+<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">dele</span>(k+<span class="number">1</span>)</span><br><span class="line">     第k个插入的数左边插入：<span class="built_in">add_to_right</span>(x,l[k+<span class="number">1</span>])</span><br><span class="line">     第k个插入的数右边插入：<span class="built_in">add_to_right</span>(x,k+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表制作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>* pre; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>*p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>*head;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>*tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Home</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p=head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">End</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p=tail-&gt;pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==head) <span class="keyword">return</span>;</span><br><span class="line">    p=p-&gt;pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Right</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==tail) <span class="keyword">return</span>;</span><br><span class="line">	p=tail-&gt;pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="keyword">if</span>(p==head) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>*tmp=(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">	tmp=p;</span><br><span class="line">	tmp-&gt;pre-&gt;next=tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next-&gt;pre=tmp-&gt;pre;</span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">50010</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>*head=(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>*tail=(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>*p=head;</span><br><span class="line">	head-&gt;next=tail;</span><br><span class="line">	tail-&gt;pre=head;</span><br><span class="line">	tail-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	head-&gt;pre=<span class="literal">NULL</span>; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">Home</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#125;&#x27;</span>) <span class="built_in">End</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&lt;&#x27;</span>) <span class="built_in">Left</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&gt;&#x27;</span>) <span class="built_in">Right</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;#&#x27;</span>) <span class="built_in">Back</span>();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">struct</span> Node*q=(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">			q-&gt;data=s[i];</span><br><span class="line">			q-&gt;pre=p;</span><br><span class="line">			q-&gt;next=p-&gt;next;</span><br><span class="line">			p-&gt;next-&gt;pre=q;</span><br><span class="line">			p-&gt;next=q;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">			&#125;	</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(p=head-&gt;next;p!=tail;p=p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">100090</span>;</span><br><span class="line"><span class="type">int</span> nex[M];</span><br><span class="line"><span class="type">int</span> pre[M];</span><br><span class="line"><span class="type">int</span> valu[M];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//双链表相对单链表的初始化不同</span></span><br><span class="line">   nex[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//最左端指向最右端</span></span><br><span class="line">   pre[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//最右端指向最左端</span></span><br><span class="line">   idx=<span class="number">2</span>;<span class="comment">//另一个好处就是非常直白，双数肯定是向右的，单数向左的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_right</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    valu[idx]=x;</span><br><span class="line">    nex[idx]=nex[k];</span><br><span class="line">    pre[idx]=k;</span><br><span class="line">    <span class="comment">//新节点的延申部位都搞定了，开始双向连接</span></span><br><span class="line">    pre[nex[k]]=idx;</span><br><span class="line">    nex[k]=idx;<span class="comment">//</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更聪明的方法，在左边插入直接调用add_to_right(x,prev[k]),也就是在k的左边节点调用向右插</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dele</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nex[pre[k]]=nex[k];</span><br><span class="line">    pre[nex[k]]=pre[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tem;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">initial</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;index;</span><br><span class="line">            <span class="built_in">dele</span>(index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tem;</span><br><span class="line">            <span class="built_in">add_to_right</span>(tem,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tem;</span><br><span class="line">            <span class="built_in">add_to_right</span>(tem,pre[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&quot;IL&quot;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;index&gt;&gt;tem;</span><br><span class="line">            <span class="built_in">add_to_right</span>(tem,pre[index+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&quot;IR&quot;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;index&gt;&gt;tem;</span><br><span class="line">            <span class="built_in">add_to_right</span>(tem,index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=nex[<span class="number">0</span>];i!=<span class="number">1</span>;i=nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;valu[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="链表递归与双指针"><a href="#链表递归与双指针" class="headerlink" title="链表递归与双指针"></a>链表递归与双指针</h6><p>应用：力扣19题</p>
<p>方法：未知链表长度情况下通过递归获取长度</p>
<p><strong>注意这种递归本质上是逆序进行扫描，从null扫描到head（不是空节点头，而是存放第一个值的头）</strong></p>
<p>读取顺序讲解：</p>
<p>以1234，2示例如有a,b,c,d四个节点，分别存放1，2，3，4（a是头4是尾，4-&gt;next&#x3D;NULL）</p>
<p>那么调用函数length时候会先一直向下扫描（因为未满足条件之前不会进行return），扫描到d的下一个节点null这时返回1-&gt;到达节点d，（<strong>因为有pos&#x3D;length(node-&gt;next,n)+1,+1导致从节点null返回d时候pos变成1</strong>）返回2（到达节点c），返回3（到达节点b），注意<strong>这时候满足倒序扫描到第三个了，也就是要删除的节点再向上回溯了1位</strong>,因此删除节点c,即node-&gt;next&#x3D;node-&gt;next-&gt;next**(b指向c变成b指向d)**</p>
<p>好处：时间少（只用扫描一次），空间少（没有额外开辟指针）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//尝试递归解决</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(ListNode *node,<span class="type">int</span> n)</span><span class="comment">//这一段千万千万注意是倒序，倒叙进行读取！！！</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归停止</span></span><br><span class="line">        <span class="type">int</span> pos=<span class="built_in">length</span>(node-&gt;next,n)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos==n+<span class="number">1</span>)<span class="comment">//进行判断了，说明在第几层递归</span></span><br><span class="line">            node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> pos;<span class="comment">//递归层层回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos =<span class="built_in">length</span>(head,n);</span><br><span class="line">        <span class="keyword">if</span>(pos==n)<span class="keyword">return</span> head-&gt;next;<span class="comment">//链表总长度刚好等于倒退长度，即处理头节点情况</span></span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考网址：<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/" >【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="同样利用递归实现链表逆序：（有那么一点点费脑子）"><a href="#同样利用递归实现链表逆序：（有那么一点点费脑子）" class="headerlink" title="同样利用递归实现链表逆序：（有那么一点点费脑子）"></a>同样利用递归实现链表逆序：（有那么一点点费脑子）</h6><h6 id="-1"><a href="#-1" class="headerlink" title=""></a><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif"
                      alt="img"
                ></h6><p>原理：链表自身带有递归属性（一个大问题可以拆解成小问题）</p>
<p>将链表拆分成头节点和剩余节点，同理继续拆解，一直拆解到最后的尾节点和前面的一堆“头”节点,<strong>最后一个节点不需要进行翻转</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457324-INLSje-image.png"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457360-ZminDz-image.png"
                      alt="image.png"
                ></p>
<p>这里就是对于子问题，将子链表进行翻转，就可以得到整个链表的反转，也就是递归的第一步</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用递推公式反转当前结点之后的所有节点</span></span><br><span class="line">    <span class="comment">// 返回的结果是反转后的链表的头结点</span></span><br><span class="line">    ListNode newHead = <span class="built_in">reverseList</span>(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设后续子链表已经全部完成翻转，那么只需要对“头节点”完成翻转</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457400-xIhTwQ-image.png"
                      alt="image.png"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/1611457409-hQkmzj-image.png"
                      alt="image.png"
                ></p>
<p>也就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head-&gt;next-&gt;neat=head;</span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>完善之后就是有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用递推公式反转当前结点之后的所有节点</span></span><br><span class="line">    <span class="comment">// 返回的结果是反转后的链表的头结点</span></span><br><span class="line">    ListNode newHead = <span class="built_in">reverseList</span>(head.next);</span><br><span class="line">    <span class="comment">//到这里已经是假设后面的链表部分已经全部反转完成，也就是只需要处理头节点和剩余部分的关系</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> newHead;<span class="comment">//注意哦，这里返回的是newhead，因为newhead是反转之后的链表的头节点，即最尾部的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再加上约束条件（递归终止条件）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (head == NULL || head-&gt;next == NULL) &#123;//返回条件/结束递归条件</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;<span class="comment">//返回条件/结束递归条件</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = <span class="built_in">reverseList</span>(head-&gt;next);<span class="comment">//这里递归，ret会在走到链表末端开始翻转</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*执行起来大概是这么一个既视感</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>



<h6 id="双指针实现逆序"><a href="#双指针实现逆序" class="headerlink" title="双指针实现逆序"></a>双指针实现逆序</h6><p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif"
                      alt="img"
                ></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = <span class="literal">NULL</span>, *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="literal">NULL</span>) &#123;<span class="comment">//终止条件，最后的指针pre走到末尾停止</span></span><br><span class="line">            ListNode* temp = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;<span class="comment">//开始反置指针指向</span></span><br><span class="line">            <span class="comment">//cur和pre整体向前移动一个位置</span></span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原理：一开始创建两个指针pre和cur，pre指向head，cur指向null，tem有点类似指针交换数值中的tem，指向正常链表顺序的下一个节点（这里就是head-&gt;next），</p>
<hr>
<h6 id="有序链表的拼接（又是递归-x2F-bushi）"><a href="#有序链表的拼接（又是递归-x2F-bushi）" class="headerlink" title="有序链表的拼接（又是递归&#x2F;bushi）"></a><strong>有序链表的拼接（又是递归&#x2F;bushi）</strong></h6><p>时间复杂度：O(m+n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;<span class="comment">//终止条件：l1走到末尾了</span></span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;<span class="comment">//终止条件：l2走到末尾了</span></span><br><span class="line">            <span class="keyword">return</span> l1;<span class="comment">//剩下的都弄上去就是</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分割线</span></span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);<span class="comment">//对l1的剩余部分进行一个递归操作</span></span><br><span class="line">            <span class="comment">//重点部分mergeTwoLists(l1-&gt;next, l2)，对l1后面的元素处理</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> l1;<span class="comment">//因为L1的这个元素小，因此把它拎出来</span></span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);<span class="comment">//对l2的剩余部分进行递归操作，l2-&gt;next同理</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> l2;<span class="comment">//同理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">解释的一个部分</span><br><span class="line"></span><br><span class="line">关于<span class="keyword">return</span> L1的个人理解: 递归的核心在于,我只关注我这一层要干什么,返回什么,至于我的下一层(规模减<span class="number">1</span>),我不管,我就是甩手掌柜.</span><br><span class="line"></span><br><span class="line">好,现在我要merge L1,L2.我要怎么做?</span><br><span class="line"></span><br><span class="line">- 显然,如果L1空或L2空,我直接返回L2或L1就行,这很好理解.<span class="comment">//上方的两个NULL情况</span></span><br><span class="line">- <span class="comment">//如果L1第一个元素小于L2的? 那我得把L1的这个元素放到最前面,至于后面的那串长啥样 ,我不管. 我只要接过下级员工干完活后给我的包裹, 然后把我干的活附上去(令L1-&gt;next = 这个包裹)就行</span></span><br><span class="line">- 这个包裹是下级员工干的活,即<span class="built_in">merge</span>(L1-&gt;next, L2)</span><br><span class="line"></span><br><span class="line">我该返回啥?</span><br><span class="line"></span><br><span class="line">- 现在不管我的下一层干了什么,又返回了什么给我, 我只要知道,假设我的工具人们都完成了任务, 那我的任务也就完成了,可以返回最终结果了</span><br><span class="line">- 最终结果就是我一开始接手的L1头结点+下级员工给我的大包裹,要一并交上去, 这样我的boss才能根据我给它的L1头节点往下找,检查我完成的工作</span><br></pre></td></tr></table></figure>

<h6 id="回文链表判断：（映射，递归，翻转）"><a href="#回文链表判断：（映射，递归，翻转）" class="headerlink" title="回文链表判断：（映射，递归，翻转）"></a>回文链表判断：（映射，递归，翻转）</h6><p><strong>映射到数组上再对数组进行操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vals.<span class="built_in">emplace_back</span>(head-&gt;val);<span class="comment">//使用迭代器更加节省时间一些，如果是数组会报错</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = (<span class="type">int</span>)vals.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vals[i] != vals[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优雅递归</strong></p>
<p>遍历节点的方式<strong>可是我看不懂</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode* frontPointer;<span class="comment">//这个是前指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        frontPointer = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释：currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val !&#x3D; frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。<br>空间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。我们要理解计算机如何运行递归函数，在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 nn 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时空间复杂度要考虑堆栈的使用情况。<br>这种方法不仅使用了 O(n)O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。</p>
<p><strong>快慢指针</strong></p>
<p>很优雅**<del>但是我照样看不懂</del>***<strong>没想到吧老子看懂了哈哈哈哈哈哈哈</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode* firstHalfEnd = <span class="built_in">endOfFirstHalf</span>(head);<span class="comment">//返回慢的那一半</span></span><br><span class="line">        ListNode* secondHalfStart = <span class="built_in">reverseList</span>(firstHalfEnd-&gt;next);<span class="comment">//对中间开始往右的第一个开始翻转</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = secondHalfStart;</span><br><span class="line">        <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd-&gt;next = <span class="built_in">reverseList</span>(secondHalfStart);<span class="comment">//为了保证链表本身不变，实际上可以省略（大概）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;<span class="comment">//是你最爱的双指针翻转法</span></span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstHalf</span><span class="params">(ListNode* head)</span> </span>&#123;<span class="comment">//快慢指针，快的走俩，慢的走1，在中点停止</span></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="zhan（栈）不是B站那个"><a href="#zhan（栈）不是B站那个" class="headerlink" title="zhan（栈）不是B站那个"></a>zhan（栈）不是B站那个</h4><h6 id="前言：-1"><a href="#前言：-1" class="headerlink" title="前言："></a>前言：</h6><p>栈属于一种FILO数据结构，类似阉割版本的顺序表，在计算机中有非常广泛的应用</p>
<p>例：使用递归时，编译器自身对于递归指令的使用就是一种栈，或者计算中缀表达式（通过将中缀表达式转换为后缀表达式，再对后缀表达式进行栈运算就可以得出结果）-&gt;全部利用栈的FILO结构</p>
<h6 id="栈制造方式"><a href="#栈制造方式" class="headerlink" title="栈制造方式"></a>栈制造方式</h6><ul>
<li>数组栈-&gt;非常非常easy</li>
<li>链表栈-&gt;参考链表，但是阉割</li>
</ul>
<h6 id="栈做非降路径问题"><a href="#栈做非降路径问题" class="headerlink" title="栈做非降路径问题"></a>栈做非降路径问题</h6><p>离散数学组合数学里面的东西，如果对一个栈仅允许出栈入栈操作，对输入固定长度字母求所有的输出模式，其实本质就是一个非降路径，只需要计算从(0,0)到(n,n)的不经过y&#x3D;x+1的所有路径</p>
<h6 id="中缀表达式转换后缀表达式"><a href="#中缀表达式转换后缀表达式" class="headerlink" title="中缀表达式转换后缀表达式"></a>中缀表达式转换后缀表达式</h6><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/wujing1_1/article/details/107774753?ops_request_misc=%7B%22request_id%22:%22166755340216782425667308%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166755340216782425667308&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-107774753-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80&spm=1018.2226.3001.4187" >(104条消息) 中缀表达式转后缀表达式的方法_說詤榢的博客-CSDN博客_中缀表达式转后缀表达式<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="正则表达式分析"><a href="#正则表达式分析" class="headerlink" title="正则表达式分析"></a>正则表达式分析</h6><p>分析：</p>
<ul>
<li><strong>使用栈来求：</strong>中缀表达式可以拆分成一棵中缀树，后缀类似拆分成后缀树，如（1+1）<em>（2+2），中缀中根节点是</em>，叶节点是+，叶子是1 1 2 2，如果用树的思想去做应该使用树的中序遍历，但是问题在于不好处理运算符的优先级问题，而改造成后缀表达式就会方便很多，如同上例子换成后缀表达式变成了1 1 + 2 2 + *，然后使用栈来进行运算，数字压栈，运算符出栈两个进行运算后再次压栈，这样就可以避开运算符优先级的处理问题（<del><strong>相对更好理解一些而且不需要搭建树，可以使用栈来搞</strong></del>）</li>
<li><strong>使用递归来求：</strong>已知将该表达式抽象成为一棵树，那么对每个子树使用递归求值可以不断削减树的层数，最后获得根树的值（**<del>很牛逼但是很麻烦，要提前接触到树</del>**）</li>
</ul>
<p>这里使用栈来进行一个中缀表达式的计算</p>
<p>先看下只有 + 和 * 的。</p>
<p>输入长度为n的字符串，例如：1+2+3<em>4</em>5</p>
<p>输出表达式的值，即：63</p>
<p>应该用什么数据结构？</p>
<p>栈。</p>
<p>应该先计算哪一步？</p>
<p>实际应该先计算1+2。</p>
<p>“表达式求值”问题，两个核心关键点：</p>
<p>（1）双栈，一个操作数栈，一个运算符栈；</p>
<p>（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：</p>
<p>如果栈顶的运算符优先级低，新运算符直接入栈</p>
<p>如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈</p>
<p>仍以1+2+3<em>4</em>5举例，看是如何利用上述两个关键点实施计算的。</p>
<p>首先，这个例子只有+和*两个运算符，所以它的运算符表是：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_095276ee89-00.webp.jpg"
                      alt="00.webp.jpg"
                ></p>
<p>这里的含义是：</p>
<p>（1）如果栈顶是+，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；</p>
<p>（2）如果栈顶是+，即将入栈的是*，栈顶优先级低，直接入栈；</p>
<p>（3）如果栈顶是*，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；</p>
<p>（4）如果栈顶是<em>， 即将入栈的是</em>，栈顶优先级高，需要先计算，再入栈；</p>
<p>有了运算符表，一切就好办了。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_0d357dc289-01.webp.jpg"
                      alt="01.webp.jpg"
                ></p>
<p>一开始，初始化好输入的字符串，以及操作数栈，运算符栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_10cc705789-02.webp.jpg"
                      alt="02.webp.jpg"
                ></p>
<p>一步步，扫描字符串，操作数一个个入栈，运算符也入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_14359ecb89-3.png"
                      alt="3.png"
                ></p>
<p>下一个操作符要入栈时，需要先比较优先级。</p>
<p>栈内的优先级高，必须先计算，才能入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_17b96fe289-4.webp.jpg"
                      alt="4.webp.jpg"
                ></p>
<p>计算的过程为：</p>
<p>（1）操作数出栈，作为num2；</p>
<p>（2）操作数出栈，作为num1；</p>
<p>（3）运算符出栈，作为op；</p>
<p>（4）计算出结果；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_1b6cac1c89-5.webp.jpg"
                      alt="5.webp.jpg"
                ></p>
<p>（5）结果入操作数栈；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_1ed49bd989-6.png"
                      alt="6.png"
                ></p>
<p>接下来，运算符和操作数才能继续入栈。下一个操作符要入栈时，继续比较与栈顶的优先级。</p>
<p>栈内的优先级低，可以直接入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_21bfcd8989-7.png"
                      alt="7.png"
                ></p>
<p>字符串继续移动。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_26237d8e89-8.png"
                      alt="8.png"
                ></p>
<p>又要比较优先级了。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_28e8139389-9.webp.jpg"
                      alt="9.webp.jpg"
                ></p>
<p>栈内的优先级高，还是先计算（3*4&#x3D;12），再入栈。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_2c8291c589-10.png"
                      alt="10.png"
                ></p>
<p>不断入栈，直到字符串扫描完毕。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/55289_2e61c67089-11.webp.jpg"
                      alt="11.webp.jpg"
                ></p>
<p>不断出栈，直到得到最终结果3+60&#x3D;63，算法完成。</p>
<p>总结</p>
<p>“表达式求值”问题，两个核心关键点：</p>
<p>（1）双栈，一个操作数栈，一个运算符栈；</p>
<p>（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：<br>如果栈顶的运算符优先级低，新运算符直接入栈</p>
<p>如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈</p>
<p>这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。</p>
<p>运算符有+-<em>&#x2F;()~^&amp;都没问题，如果共有n个运算符，会有一个n</em>n的优先级表。</p>
<h6 id="正则表达式代码"><a href="#正则表达式代码" class="headerlink" title="正则表达式代码"></a>正则表达式代码</h6><p>代码：</p>
<p><strong>上       代        码</strong></p>
<p><del>虽然但是接下来这个代码是中缀计算的</del></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span><span class="comment">//stl库中使用栈</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span><span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span><span class="comment">//一个目前不太懂的头文件，回头看primer自己理解吧</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;<span class="comment">//存储数字的栈</span></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;<span class="comment">//存储运算符的栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级表</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; h&#123; &#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span><span class="comment">//求值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = num.<span class="built_in">top</span>();<span class="comment">//第二个操作数</span></span><br><span class="line">    num.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = num.<span class="built_in">top</span>();<span class="comment">//第一个操作数</span></span><br><span class="line">    num.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> p = op.<span class="built_in">top</span>();<span class="comment">//运算符</span></span><br><span class="line">    op.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;<span class="comment">//结果 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;+&#x27;</span>) r = b + a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;-&#x27;</span>) r = b - a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;*&#x27;</span>) r = b * a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;/&#x27;</span>) r = b / a;</span><br><span class="line"></span><br><span class="line">    num.<span class="built_in">push</span>(r);<span class="comment">//结果入栈到num中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;<span class="comment">//读入表达式</span></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)<span class="comment">//调用了string的函数s.size()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))<span class="comment">//判断数字入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, j = i;<span class="comment">//计算数字</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//将string型的数字转换为int？</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(x);<span class="comment">//数字入栈</span></span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左括号无优先级，直接入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)<span class="comment">//左括号入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)<span class="comment">//右括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)<span class="comment">//一直计算到左括号</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();<span class="comment">//左括号出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; h[op.<span class="built_in">top</span>()] &gt;= h[s[i]])<span class="comment">//待入栈运算符优先级低，则先计算</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);<span class="comment">//操作符入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();<span class="comment">//剩余的进行计算</span></span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="单调栈（瞳孔地震型题解）😢"><a href="#单调栈（瞳孔地震型题解）😢" class="headerlink" title="单调栈（瞳孔地震型题解）😢"></a>单调栈（瞳孔地震型题解）😢</h6><p>使用单调递增栈</p>
<p>麻烦地方：超时</p>
<p>考虑方式有些类似双指针</p>
<p>思路：<strong>暴力</strong>-&gt;优化暴力</p>
<p>队列里面是否有元素没用</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/20201211221031165.gif"
                      alt="在这里插入图片描述"
                ></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;<span class="comment">//总共要输入几次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(tt&amp;&amp;stk[tt]&gt;=x)tt--;<span class="comment">//如果栈内元素只要比待进入元素小就弹出</span></span><br><span class="line">        <span class="keyword">if</span>(tt)cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//弹出后输出第一个栈顶元素</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//栈空后输出-1</span></span><br><span class="line">        stk[++tt]=x;<span class="comment">//一轮走下来以后新的元素入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>FIFO构造</p>
<h6 id="队列构造方式："><a href="#队列构造方式：" class="headerlink" title="队列构造方式："></a>队列构造方式：</h6><p>数组构造（也是hin简单就是了）😒</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板用栈直接改都可以</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">200600</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bottom=<span class="number">0</span>;<span class="comment">//队列底部，弹出时候bottom+1</span></span><br><span class="line"><span class="type">int</span> line[M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;<span class="comment">//队列头部，增加时候top+1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    line[top]=x;</span><br><span class="line">    ++top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bottom++;<span class="comment">//底部上移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;line[bottom]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==bottom)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="循环队列："><a href="#循环队列：" class="headerlink" title="循环队列："></a>循环队列：</h6><p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;<span class="comment">//如果到达某一特定值那么就重置变成队头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)<span class="comment">//不为空</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="单调队列-～￣▽￣-～滑动窗口经典（配合单调栈食用）"><a href="#单调队列-～￣▽￣-～滑动窗口经典（配合单调栈食用）" class="headerlink" title="单调队列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）"></a>单调<del>队</del>列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）</h6><p>😶‍🌫️准备好开始头疼</p>
<p>思路同单调栈：从暴力解决入手接着开始优化</p>
<p>可以使用队列对窗口进行维护（标准的入列和出列）</p>
<p>优化：<strong>队列中是否有没用的元素，对没用的元素进行删除看能否得到单调性</strong>，如3，-1，-3，在-3入列的时候就有3&gt;-3，则最小值一定不会是3而且-3存在时间更久，因此使用单调栈的同样原理可以求出单调最小，并且是一个单调递增的最小</p>
<p>可以使用STL标准库来写或者说使用栈和队列数组模拟去写，而相对而言使用数组有很大的好处在于数组速度快，在比赛或者笔试时候会慢一些，在IDE中可能会有O2或者O3优化</p>
<p>再看一遍单调栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;<span class="comment">//总共要输入几次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(tt&amp;&amp;stk[tt]&gt;=x)tt--;<span class="comment">//如果栈内元素只要比待进入元素大就弹出</span></span><br><span class="line">        <span class="keyword">if</span>(tt)cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//弹出后输出第一个栈顶元素</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//栈空后输出-1</span></span><br><span class="line">        stk[++tt]=x;<span class="comment">//一轮走下来以后新的元素入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/20201211221031165.gif"
                      alt="在这里插入图片描述"
                ></p>
<p>解题思路（以最大值为例）：</p>
<p>由于我们需要求出的是滑动窗口的最大值。</p>
<p>如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i&lt;j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：</p>
<p>当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。</p>
<p>因此，<strong>由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。</strong></p>
<p>因此我们可以使用一个队列存储<strong>所有还没有被移除的下标，这里是q</strong>。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。</p>
<p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。</p>
<p>为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，<strong>那么队尾的元素就可以被永久地移除</strong>，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p>
<p>由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。</p>
<p>窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。</p>
<p>每一个窗口的最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hh = <span class="number">0</span>; tt = <span class="number">-1</span>;          <span class="comment">//头在左尾在右                         // 重置！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="comment">//注意这个栈可以想成朝着右边（tt，正常栈操作），但是底部可以操作（hh，向右缩）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//窗口终点是i，那么起点就是i-k+1</span></span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;<span class="comment">//窗口左边向右移动一个</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里操作下来要是从大到小的排列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;<span class="comment">//右边已经有更大的了，之前的小的a[q[tt]]可以不用考虑了，就操作tt</span></span><br><span class="line">        q[++ tt] = i;<span class="comment">//窗口右边向右移动一个</span></span><br><span class="line">        <span class="comment">//i+1&gt;=k这里就是一个特判，因为一开始窗口没有值，只有窗口全部充满之后才有后面的操作</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);<span class="comment">//这里知道栈的底部（也就是q[hh]）对应的下标是该窗口中没有删除而且是最大的</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>判断最小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> q[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> hh=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tt = <span class="number">-1</span>;<span class="comment">//尾部是1</span></span><br><span class="line"><span class="type">int</span> n, k;<span class="comment">//hh是头，tt是尾，</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头在左尾在右</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;<span class="comment">//k是窗口大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里是关于窗口的维护</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);<span class="comment">//数组a存放了所有的数字</span></span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;       </span><br><span class="line">        <span class="comment">//数组q存放的是下标</span></span><br><span class="line">        <span class="comment">// 若队首出窗口，hh加1，即整体向前移动一格</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里开始跟单调栈的原理相同</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        hh&lt;=tt是队列不为空</span></span><br><span class="line"><span class="comment">        a[i] &lt;= a[q[tt]]这里就是单调栈的如果新来的a[i]不是栈里面最大的就弹栈，--tt</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    <span class="comment">// 若队尾不单调，tt减1</span></span><br><span class="line">        q[++ tt] = i;                                  <span class="comment">// 下标加到队尾，新元素入栈，上面入的是元素本身这里入的是元素下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);       <span class="comment">// 这里确定过栈中的都是最小的元素了因此直接输出</span></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;<span class="comment">//换行</span></span><br></pre></td></tr></table></figure>



<p>全部代码！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N], tail = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> head=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//a存储正常原数组的值</span></span><br><span class="line"><span class="comment">//注意注意q存储的是a的“下标”，“下标”而不是“值”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;<span class="comment">//hh是头，tt是尾</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)<span class="comment">//输出最小，每一次循环里面q[head]的值也就是a[q[head]]总是窗口中最小的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i-k+1就是窗口头部位置</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[head]) ++ head;                  <span class="comment">// 若队首出窗口，head加1</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; a[i] &lt;= a[q[tail]]) -- tail;    <span class="comment">// 若队尾不单调，tail持续减1</span></span><br><span class="line">        q[++ tail] = i;                                  <span class="comment">// 下标加到队尾,尾部进入窗口</span></span><br><span class="line">        <span class="keyword">if</span> (i-k + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[head]]);       <span class="comment">// 输出结果(只有窗口形成之后才会输出)</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    head = <span class="number">0</span>; tail = <span class="number">-1</span>;                                   <span class="comment">// 重置！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[head]) ++ head;				<span class="comment">//判断头部是否出窗口</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; a[i] &gt;= a[q[tail]]) -- tail;</span><br><span class="line">        q[++ tail] = i;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[head]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><h5 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>K<del>M</del>P</h5><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46007276/article/details/104372119?ops_request_misc=%7B%22request_id%22:%22166616507616781432932798%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166616507616781432932798&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104372119-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1&utm_term=kmp%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187" >(100条消息) 数据结构KMP算法配图详解（超详细）_哈顿之光的博客-CSDN博客_kmp算法难吗是什么级别<i class="fas fa-external-link-alt"></i></a>（<strong>好好看好好学</strong>）</p>
<h6 id="模板y总"><a href="#模板y总" class="headerlink" title="模板y总"></a>模板y总</h6><p><strong>注意kmp算法的下标要从1开始弄！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//一开始就是1开始弄的</span></span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者邪教读取法:cin&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )<span class="comment">//与匹配部分基本一样一样</span></span><br><span class="line">&#123;<span class="comment">//一点细节，这里是子串p</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//也是回溯</span></span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//匹配成功子串向前走</span></span><br><span class="line">    ne[i] = j;<span class="comment">//欸，这里不一样了，</span></span><br><span class="line">    <span class="comment">//ne数组其实也是一样样的，i=2是因为实际上1是肯定是0（前面都没字符自然是0），ne数组也是从1开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kmp匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )<span class="comment">//</span></span><br><span class="line">&#123;<span class="comment">//一点细节，下面是长串s</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//不相等的时候递归回退，与代码随想录是一种方法</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//如果匹配成功，子串也向前一位走</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];<span class="comment">//回溯到前一次</span></span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">char</span> p[N],s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])j++;</span><br><span class="line">		ne[i]=j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])j++;</span><br><span class="line">		<span class="keyword">if</span>(j==n)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;i-n&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//就是输出下标</span></span><br><span class="line">			j=ne[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键：<strong>特殊数组next的构造</strong>，<strong>前缀表</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221019194121.gif"
                      alt="微信图片_20221019194121"
                ></p>
<p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了</strong></p>
<h6 id="前缀表：字符串的最长"><a href="#前缀表：字符串的最长" class="headerlink" title="前缀表：字符串的最长"></a>前缀表：字符串的最长</h6><p>前缀：不包含尾字符的所有子串</p>
<p>后缀：相较于前缀，不包含首字母的所有子串</p>
<p>因此如果仅有单个字符则其前缀为0</p>
<p>特性：</p>
<p>目前讲解的构造方法</p>
<p>例：子串aabaabaaf，前缀表010120(aabaaf)</p>
<ul>
<li>前缀形式：010120</li>
<li>全部后移方式：-1 0 10120</li>
<li>整体减一方式：-1 0 -1 0 1 -1</li>
</ul>
<p>共同点：最后都应当保持封闭，虽然理解有出入但本质相同</p>
<h6 id="代码随想录方法：前缀不减形式"><a href="#代码随想录方法：前缀不减形式" class="headerlink" title="代码随想录方法：前缀不减形式"></a>代码随想录方法：前缀不减形式</h6><p>prev,latter;</p>
<p>prev:<strong>前缀末尾位置</strong>，同时代表<em><strong>prev包括prev之前子串最长相等前后缀的长度，也表示前缀末尾</strong></em></p>
<p>latter:<strong>后缀末尾位置</strong></p>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prev=<span class="number">0</span>;</span><br><span class="line">latter=<span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化latter</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开始处理前后缀不同情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//prev和latter一直不相等</span></span><br><span class="line"><span class="keyword">for</span>(latter=<span class="number">1</span>;latter&lt;slength;latter++)<span class="comment">//后缀指针只管往前走就完事</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里if是出错的根源</span></span><br><span class="line">    <span class="keyword">while</span>(s[prev]!=s[latter]&amp;&amp;prev&gt;<span class="number">0</span>)<span class="comment">//注意这里因为有-1存在所以一定小心越界，</span></span><br><span class="line">    &#123;</span><br><span class="line">        prev=next[prev<span class="number">-1</span>];<span class="comment">//prev冲突时候是一个连续回退的过程，如果使用if就错了，使用while循环回退</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只要s[latter]!=s[prev]时候prev应该向前回退</span></span><br><span class="line">    <span class="comment">//原因：使用前缀表在进行kmp对比的时候如果遇到冲突，也是看冲突位置前一位的表进行跳转</span></span><br><span class="line">    </span><br><span class="line">    分界线：前后缀相同的情况</span><br><span class="line">        <span class="keyword">if</span>(s[prev]==s[latter])</span><br><span class="line">        &#123;</span><br><span class="line">            prev++;<span class="comment">//代表prev之前最长相等前缀可以更新</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//latter因为有for循环，因此自然向前有++操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    	 next[latter]=prev;<span class="comment">//更新next数组的值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里则是全部操作的部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里是返回第一个找到的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);<span class="comment">//获取next数组</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];<span class="comment">//一样进行回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="comment">//使用循环，直接对prev进行+就行</span></span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221019194410.gif"
                      alt="微信图片_20221019194410"
                ></p>
<p>注意这里是文本串和模式串不匹配时候的操作（这里next数组采用正常前缀表）</p>
<h6 id="数据结构作业出错原因"><a href="#数据结构作业出错原因" class="headerlink" title="数据结构作业出错原因"></a>数据结构作业出错原因</h6><p>要求每一个都求出来</p>
<p>问题在于：当每一次<strong>满足条件后进行清零操作</strong>，<em><strong>本质上同一次两者不等时候的回溯操作（prev到上一位最接近的前缀位置）</strong></em>,如果使用prev&#x3D;0就会出现可能错过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">    ababa  aba <span class="number">001</span></span><br><span class="line">    <span class="comment">//正确解</span></span><br><span class="line">    <span class="keyword">if</span>(prev==sublength)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;endl&lt;&lt;latter-sublength+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">            prev=next[prev<span class="number">-1</span>];<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//在第一次解的时候prev=3;latter=2(因为latter在一次循环之后才会有增操作)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用回溯prev=1,sub[prev]=b那么就接着从latter=3.T[latter]=b无缝开始向前对比</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">/错误</span><br><span class="line">    <span class="keyword">if</span>(prev==sublength)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;endl&lt;&lt;latter-sublength+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">            prev=<span class="number">0</span>;<span class="comment">//这样就会是错误结果</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h5 id="automata-有限状态自动机"><a href="#automata-有限状态自动机" class="headerlink" title="automata~有限状态自动机"></a>automata~有限状态自动机</h5><p>参考：</p>
<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/tyler_download/article/details/52549315?ops_request_misc=%7B%22request_id%22:%22166619414916782414994917%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166619414916782414994917&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-52549315-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1&utm_term=%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA&spm=1018.2226.3001.4187" >(100条消息) 字符串匹配算法之：有限状态自动机_tyler_download的博客-CSDN博客_有限自动机算法<i class="fas fa-external-link-alt"></i></a></li>
<li>苏老师坚果云ppt状态机代码部分</li>
</ul>
<h6 id="代码（构建自动机状态表）"><a href="#代码（构建自动机状态表）" class="headerlink" title="代码（构建自动机状态表）"></a>代码（构建自动机状态表）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dfa[<span class="number">0</span>][P[<span class="number">0</span>]] = <span class="number">1</span>; <span class="comment">//初始化第一行</span></span><br><span class="line"><span class="comment">// dfa[状态][下一个字符] for(int X = 0, j = 1; j &lt; plen; j++) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 dfa[j][]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; R; c++) &#123; <span class="comment">// R 为字符种类数量</span></span><br><span class="line"></span><br><span class="line">dfa[j][c] = dfa[X][c];</span><br><span class="line"></span><br><span class="line">&#125; dfa[j][P[j]] = j + <span class="number">1</span>; X = dfa[X][P[j]]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-20%20194911.png"
                      alt="屏幕截图 2022-10-20 194911"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-20%20195102.png"
                      alt="屏幕截图 2022-10-20 195102"
                ></p>
<h6 id="聪明版本自动机"><a href="#聪明版本自动机" class="headerlink" title="聪明版本自动机"></a>聪明版本自动机</h6><p>已知ascii码总共就128个，直接开一个大表就行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfa[<span class="number">256</span>][<span class="number">256</span>]=<span class="number">0</span>;<span class="comment">//这样直接省略后续一系列初始化，使用int转换字符串传入就行，非常省心</span></span><br></pre></td></tr></table></figure>

<h5 id="TRIE树（有些类似哈夫曼树编码）"><a href="#TRIE树（有些类似哈夫曼树编码）" class="headerlink" title="TRIE树（有些类似哈夫曼树编码）"></a>TRIE树（有些类似哈夫曼树编码）</h5><p>类似但和哈夫曼树没有关系</p>
<p>又称字典树、单词查找树</p>
<p>应用：快速存储和查找字符串集合的数据结构</p>
<h6 id="如何存储：构建串树"><a href="#如何存储：构建串树" class="headerlink" title="如何存储：构建串树"></a>如何存储：构建串树</h6><p>从根节点开始存储每一个字符，开始逐个向下进行创建，在单词的末尾打上一个标记表示该单词走到结尾了</p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-24%20202126.png"
                      alt="屏幕截图 2022-11-24 202126" style="zoom:33%;" 
                >

<p><strong>TRIE树本质是一颗N叉树，有多少种字符一个节点就最多有多少条边</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/31041_aed49a42ad-Trie2.PNG"
                      alt="Trie2.PNG"
                ></p>
<h6 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h6><p>从单词的首字母开始向下走，走到标记表示到头了</p>
<h6 id="构建TRIE树"><a href="#构建TRIE树" class="headerlink" title="构建TRIE树"></a>构建TRIE树</h6><p>这里使用了数组模拟树的知识</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>];</span><br><span class="line"><span class="comment">//这里是26因为只有小写字母</span></span><br><span class="line"><span class="comment">//二维是可以有多少个分支，一维的意义是来自哪一个双亲节点</span></span><br><span class="line"><span class="type">int</span> cnt[N], idx;<span class="comment">//idx是下标为0的点，是根节点和空节点，表示当前要插入的节点是第几个,每创建一个节点值+1</span></span><br><span class="line">   <span class="comment">// cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）</span></span><br><span class="line"><span class="type">char</span> str[N];<span class="comment">//存储要插入/查询的单词</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">//类似指针，指向当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//u表示是具体哪一个字母</span></span><br><span class="line">        <span class="comment">//p表示的是第几个结点，u表示的是哪个字母，如果s[p][u]不为空就证明有以这个字母为值的子结点</span></span><br><span class="line">        <span class="comment">//它代表的值就是指向了该子结点，即说明了第几个结点是它的子结点</span></span><br><span class="line">         <span class="comment">//如s[2][1]=3，表示结点2有一个值为b（第二个数字代表的是a～z）的子结点，是结点3</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<span class="comment">//不存在就创建节点</span></span><br><span class="line">        <span class="comment">//令p指向子结点</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不管是未存在过的新插入还是已有字典再增加一个，都是以这个结点为末尾的字符串次数加1</span></span><br><span class="line">    cnt[p] ++ ;<span class="comment">//结束时的标记，也是记录以此节点结束的字符串个数</span></span><br><span class="line">    <span class="comment">//这一步重要！</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )<span class="comment">//走到该单词为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//获得对应子节点的编号</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];<span class="comment">//返回以p为结尾的单词数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//这里有I是插入字符串，其它是查找该字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);<span class="comment">//前一次输入被覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="TRIE树的其它应用"><a href="#TRIE树的其它应用" class="headerlink" title="TRIE树的其它应用"></a>TRIE树的其它应用</h5><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF" >https://www.acwing.com/blog/content/32/%E5%A5%BD%E4%B8%9C%E8%A5%BF<i class="fas fa-external-link-alt"></i></a></p>
<p>启示：<strong>字典树不单单可以高效存储和查找字符串集合，还可以存储二进制数字</strong></p>
<h6 id="思路：利用二叉树"><a href="#思路：利用二叉树" class="headerlink" title="思路：利用二叉树"></a>思路：利用二叉树</h6><p><strong>对所有的aiaj建立一个串数组，对于每一个固定的ai，每一次尽量与和当前不同的分支向下走，走到底这样一定就可以得到最优解</strong></p>
<p>即顺序：所有值的二进制表示建立树-&gt;遍历一次，每一个ai进行寻找对应的最大的值，最后遍历一次之后获得答案</p>
<h6 id="算法复杂度："><a href="#算法复杂度：" class="headerlink" title="算法复杂度："></a>算法复杂度：</h6><p>（建立树）+n（每一个ai只需要在已经建立好的树再从头到尾走一次就好）</p>
<h6 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h6><p>insert函数改：</p>
<p>每个数看作一个31位长度的二进制数，最高位是0往0走，最高位1往1走，然后和类似TRIE的操作，但是构建的是一颗二叉树（一定概率变成斜树）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;  <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从最大位开始建立</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;   <span class="comment">/////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx; <span class="comment">///如果插入中发现没有该子节点,开出这条路</span></span><br><span class="line">        p=son[p][u]; <span class="comment">//指针指向下一层</span></span><br><span class="line">    &#125;<span class="comment">//与上面不一样这里就不需要标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;                               <span class="comment">///从最大位开始找</span></span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u]) <span class="comment">////如果当前层有对应的不相同的数</span></span><br><span class="line">        &#123;   <span class="comment">///p指针就指到不同数的地址</span></span><br><span class="line"></span><br><span class="line">          p=son[p][!u];</span><br><span class="line">          res=res*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//右移，因为树右儿子是1</span></span><br><span class="line">             <span class="comment">///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001</span></span><br><span class="line">        &#125;                                                   <span class="comment">///       010 </span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">////   ---&gt;011                                                                           </span></span><br><span class="line">            <span class="comment">//刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=son[p][u];</span><br><span class="line">            res=res*<span class="number">2</span>+<span class="number">0</span>;<span class="comment">//左移，因为树左儿子是1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N=<span class="number">100010</span>,M=<span class="number">31</span>*N;<span class="comment">//M表示树的节点个数，每个数最多有31个长度，因此建立</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>],idx;</span><br><span class="line"><span class="comment">//M代表一个数字串二进制可以到多长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;  <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//这里相等i&gt;=0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;   <span class="comment">/////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx; <span class="comment">///如果插入中发现没有该子节点,开出这条路</span></span><br><span class="line">        p=son[p][u]; <span class="comment">//指针指向下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;                               <span class="comment">///从最大位开始找</span></span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u]) <span class="comment">////如果当前层有对应的不相同的数</span></span><br><span class="line">        &#123;   <span class="comment">///p指针就指到不同数的地址</span></span><br><span class="line"></span><br><span class="line">          p=son[p][!u];</span><br><span class="line">          res=res*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">             <span class="comment">///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001</span></span><br><span class="line">        &#125;                                                       <span class="comment">///       010 </span></span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=son[p][u];</span><br><span class="line">            res=res*<span class="number">2</span>+<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//最后返回是十进制形态的答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">search</span>(a[i]));  <span class="comment">///search(a[i])查找的是a[i]值的最大与或值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="跳表——同样面试——但是不用手搓"><a href="#跳表——同样面试——但是不用手搓" class="headerlink" title="跳表——同样面试——但是不用手搓"></a>跳表——同样面试——但是不用手搓</h4><h6 id="一些参考的博客："><a href="#一些参考的博客：" class="headerlink" title="一些参考的博客："></a>一些参考的博客：</h6><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/yjw123456/article/details/105159817?ops_request_misc=%7B%22request_id%22:%22166720710116782395320448%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166720710116782395320448&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105159817-null-null.142%5Ev62%5Epc_search_tree,201%5Ev3%5Econtrol_1,213%5Ev1%5Et3_control1&utm_term=%E8%B7%B3%E8%A1%A8&spm=1018.2226.3001.4187" >(101条消息) 十分钟弄懂什么是跳表，不懂可以来打我_愤怒的可乐的博客-CSDN博客_跳表<i class="fas fa-external-link-alt"></i></a></p>
<p>优点：<strong>将链表查找的时间复杂度改造成log</strong>，<strong>据说可以取代红黑树</strong></p>
<p>跳表属于对<strong>链表</strong>的改进</p>
<p>有点相似kmp？通过一些手段加快跳跃的速度</p>
<p>想法：链表中增加一些“超级链接”</p>
<h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><ul>
<li>跳表结合了链表和二分查找的思想</li>
<li>由原始链表和一些通过“跳跃”生成的链表组成</li>
<li><strong>第0层是原始链表，越上层“跳跃”的越高，元素越少</strong></li>
<li>上层链表是下层链表的子序列</li>
<li>查找时从顶层向下，不断缩小搜索范围</li>
<li><strong>每一层增长哪一个节点实际上是随机生长的</strong></li>
</ul>
<h6 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h6><ul>
<li>跳表节点中用数组存储不同层级的下一个节点</li>
<li>随即生长</li>
<li>空间使用率最高的跳表</li>
</ul>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="构建过程："><a href="#构建过程：" class="headerlink" title="构建过程："></a>构建过程：</h6><p>初始化和单链表一样，仅有一个空节点，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//保存值</span></span><br><span class="line">    E data;</span><br><span class="line">    <span class="comment">//保存了每一层上的节点信息，可能为null</span></span><br><span class="line">    List&lt;Node&gt; forwards;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(E data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        forwards = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//事先把每一层都置为null，虽然空间利用率没那么高，但是简化了实现</span></span><br><span class="line">        <span class="comment">//也可以通过自定义列表(比如B树实现中用到的Vector)来实现，就可以不用下面的操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxLevel; i++) &#123;</span><br><span class="line">            forwards.<span class="built_in">add</span>(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data == null ? <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span> + data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到当前节点level层上的下一个(右边一个)节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param level</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node <span class="title">next</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.forwards.<span class="built_in">get</span>(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="TRIE树的其它"><a href="#TRIE树的其它" class="headerlink" title="TRIE树的其它"></a>TRIE树的其它</h6><h4 id="散列表——哈希表-面试很重要"><a href="#散列表——哈希表-面试很重要" class="headerlink" title="散列表——哈希表-面试很重要"></a>散列表——哈希表-面试很重要</h4><p>特点：查找与删除，查找全部在常数时间内完成</p>
<p>应用：</p>
<ul>
<li>操作系统</li>
<li>数据库</li>
<li>编译器</li>
<li>计网</li>
<li>图像检索（最初始用于人脸识别等）</li>
</ul>
<h6 id="线性表总结："><a href="#线性表总结：" class="headerlink" title="线性表总结："></a>线性表总结：</h6><p><img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-24%20163929.png"
                      alt="屏幕截图 2022-10-24 163929"
                ></p>
<h6 id="哈希定义，应用"><a href="#哈希定义，应用" class="headerlink" title="哈希定义，应用"></a>哈希定义，应用</h6><p>本质：给定一个输入给出一个唯一的序列号输出，<strong>将一个比较大的空间映射到一个比较小的空间，将一个复杂的数据结构映射到一个小的</strong></p>
<p>应用举例： </p>
<ul>
<li>输入n个数10^5，数的范围+-10^9,选择一些数字插入，选择另外一些数字查询</li>
<li>文本压缩和解压缩</li>
</ul>
<p>定位的过程：元素通过哈希函数转换成唯一的整数（<strong>必须快速计算</strong>）<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-24%20164952.png"
                      alt="屏幕截图 2022-10-24 164952"
                ></p>
<p>第一步：将一个元素映射成一个整数</p>
<h6 id="哈希模板（正常-字符串版本）"><a href="#哈希模板（正常-字符串版本）" class="headerlink" title="哈希模板（正常+字符串版本）"></a>哈希模板（正常+字符串版本）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>  N=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//这么理解：就是正常的数组模拟链表，但是加入哈希函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];<span class="comment">//就是把head换成了h[k],因为原先是单链，现在多链</span></span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;<span class="comment">//首先哈希</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            &#123;<span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">3</span>;<span class="comment">//开放寻址的大小要放大的</span></span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> null=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<span class="comment">//这里易错，是&amp;&amp;</span></span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="分配索引值"><a href="#分配索引值" class="headerlink" title="分配索引值"></a>分配索引值</h6><p>这里对字符进行处理，每一种字符都视为一种对应的数字，不同的位数有不同的加权值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="type">unsigned</span> <span class="type">int</span> hash_val = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(*key != <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line"> &#123; hash_val = (hash_val &lt;&lt; <span class="number">5</span>) + *key++;</span><br><span class="line"><span class="comment">//这里使用&lt;&lt;实际上就是直接×2^5</span></span><br><span class="line">  <span class="comment">//每一次移动5位（这样子硬件便于实现，参考计组）</span></span><br><span class="line">&#125; <span class="keyword">return</span> hash_val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：虽然时间非常高效，但是空间浪费非常大（毕竟不能载满）</p>
<h6 id="减少索引值："><a href="#减少索引值：" class="headerlink" title="减少索引值："></a>减少索引值：</h6><p>方法1：忽略一部分元素，将另一部分直接视为索引值</p>
<p>好处：快，坏处：难于分配索引值</p>
<p>方法2：折叠，使用不同方式将原数据拆分，再合并在一起</p>
<p>方法3：余数运算，可以元素值除以某一特殊数字，余数用作索引值，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">int</span> H_SIZE)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="type">unsigned</span> <span class="type">int</span> hash_val = <span class="number">0</span>; <span class="keyword">while</span>(*key != <span class="string">&#x27;\0&#x27;</span>) &#123; hash_val = (hash_val &lt;&lt; <span class="number">5</span>) + *key++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">return</span> hash_val % H_SIZE;<span class="comment">//这里缩了一下</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="字符串哈希——-gt-字符串前缀哈希法"><a href="#字符串哈希——-gt-字符串前缀哈希法" class="headerlink" title="字符串哈希——&gt;字符串前缀哈希法"></a>字符串哈希——&gt;字符串前缀哈希法</h5><p>作用有些类似kmp，字符串也可以用哈希表做-&gt;一个集合到另一个集合的映射</p>
<p>实际上是<strong>字符串的前缀哈希法</strong>，对前缀进行哈希</p>
<p>问题：</p>
<ul>
<li>如何定义某一个前缀的哈希值，可以将字符串视为p进制的一个数，每一位上的字母（acscii）视为对应的数字，<strong>但是不能映射成0</strong>-&gt;相同的字符串映射结果会相同-&gt;AA等等</li>
<li>哈希字符串<strong>假定人品足够不存在碰撞</strong>，没有考虑冲突情况，经验值：p取<strong>131或13331</strong>时候，q取2^64，几乎99%情况不会出现冲突</li>
</ul>
<p>好处：<em><strong>可以利用最前的哈希计算出所有子串的哈希</strong></em>，</p>
<p>已知h[r],h[l],</p>
<p>h[r]中r为第0位，h[l-1]中l-2为第0位</p>
<p>操作</p>
<ol>
<li>h[l-1]与h[r]对齐，即向后移动多少位</li>
<li>h[r]-h[l-1]就能求出来了</li>
</ol>
<p>小技巧：<strong>使用unsigned long long 存储所有h，相当于对所有数取模了</strong>(因为溢出就相当于取模)</p>
<p>总结：左移高位对齐</p>
<p>之后对前缀全部处理完之后，就能用o1时间计算任意子串哈希值</p>
<p>预处理：h[i]&#x3D;h[i-1]*p+str[i] (第i位字母)</p>
<p>牛逼的地方：比kmp牛逼：<strong>可以快速判断，快过o(n)</strong>,<strong>是处理字符串的利器</strong></p>
<p>代码核心部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/843/" >841. 字符串哈希 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/24738/" >AcWing 841. 字符串哈希 【公式助理解】 - AcWing<i class="fas fa-external-link-alt"></i></a></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="C:\Users\胡锡睿\Pictures\Screenshots\屏幕截图_20221025_085505.png"
                      alt="屏幕截图_20221025_085505"
                ></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;<span class="comment">//也就是取模2^64，</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>,P = <span class="number">131</span>;<span class="comment">//131 13331</span></span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// h[i]前i个字符的hash值</span></span><br><span class="line"><span class="comment">// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字</span></span><br><span class="line"><span class="comment">// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突</span></span><br><span class="line"><span class="comment">// 使用场景： 两个字符串的子串是否相同</span></span><br><span class="line"><span class="function">ULL <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//为求l到r的哈希值</span></span><br><span class="line">    <span class="comment">//已知h[r],h[l-1]，也就是1到l-1，1到r的哈希值</span></span><br><span class="line">    <span class="comment">//因为字符串视为一个p进制的数，因此越左边权重越高，为高位，右边是低位</span></span><br><span class="line">    <span class="comment">//h[r]中r是第0位，h[1]为r-1位</span></span><br><span class="line">    <span class="comment">//h[l-1]l-1是第0位，h[1]为l-2位</span></span><br><span class="line">    <span class="comment">//两者相差r-1-l+2=r-l+1位</span></span><br><span class="line">    <span class="comment">//本质就是高位对齐，h[r]与h[l-1]对齐，</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    string x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串从1开始编号，h[1]为前一个字符的哈希值</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//以上是初始化，第0位实际上不加入计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        p[i+<span class="number">1</span>] = p[i]*P;            </span><br><span class="line">        h[i+<span class="number">1</span>] = h[i]*P +x[i];      <span class="comment">//前缀和求整个字符串的哈希值</span></span><br><span class="line">        <span class="comment">//这里x也是从第一位开始，也就是0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">query</span>(l1,r1) == <span class="built_in">query</span>(l2,r2)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="哈希碰撞处理（面试高频）😍😍😍😍😍"><a href="#哈希碰撞处理（面试高频）😍😍😍😍😍" class="headerlink" title="哈希碰撞处理（面试高频）😍😍😍😍😍"></a>哈希碰撞处理（面试高频）😍😍😍😍😍</h4><p><strong>可以把离散化看成一种特殊的哈希方式</strong></p>
<p><strong>哈希表属于期望算法</strong>，可以将哈希表的链长视为一个常数，</p>
<p>碰撞：两个相同的索引放在相同的索引位置</p>
<p>碰撞可能性很大-&gt;定义域很大值域比较小</p>
<h6 id="拉链法（Open-Hashing）"><a href="#拉链法（Open-Hashing）" class="headerlink" title="拉链法（Open Hashing）"></a>拉链法（Open Hashing）</h6><p>原理：如果多个索引值最终哈希值相同，使用链表的形式另外存储相同的值</p>
<p>添加，直接添加链</p>
<p>查找：对应位置在链表遍历一下</p>
<p>删除：算法题中一般不会进行删除节点，而是会开 一个数组打一个标记（如bool标记）</p>
<p><strong>数学上取质数，而且举例2的幂尽可能远冲突概率最小</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">3</span>;  <span class="comment">// 取大于1e5的第一个质数，而且要离2的整次幂尽可能远， 取质数冲突的概率最小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* 开一个槽 h</span></span><br><span class="line"><span class="comment">//图论中存点的方式和数组的链法一样，都是一个数组一个链</span></span><br><span class="line"><span class="type">int</span> h[N], <span class="comment">//哈希表</span></span><br><span class="line"><span class="comment">//经典数组实现链表</span></span><br><span class="line">e[N], </span><br><span class="line">ne[N], </span><br><span class="line">idx;  <span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;<span class="comment">//k就是对应的哈希值，这一步实现了映射。接下来是写入</span></span><br><span class="line">    <span class="comment">//(x%N+N)这一步为了最后一定是一个正数，如果是负数数组无法写入</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i]) &#123;<span class="comment">//这里是遍历对应到的链表</span></span><br><span class="line">        <span class="comment">//同时由于初始化是-1，开始哈希数组也要初始化为-1</span></span><br><span class="line">        <span class="keyword">if</span> (e[i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);  <span class="comment">//将槽先清空 空指针一般用 -1 来表示</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        string op;<span class="comment">//字符串的话编译器会自动忽略空格，换行符等，不容易出错</span></span><br><span class="line">        <span class="comment">//有些脏数据会增加额外空格</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：消耗空间</p>
<h6 id="开放地址法-Open-Addressing"><a href="#开放地址法-Open-Addressing" class="headerlink" title="开放地址法 Open Addressing"></a>开放地址法 Open Addressing</h6><p>思路：只用一个一维数组来模拟哈希表，因此形式会相对简洁，但是一般来说一维数组的长度应该是需要的数组大小的2~3倍，</p>
<p>类似数组模拟链表的方式，将数据存储在空余空间中，<strong>想象上厕所，一个坑位完了就下一个</strong></p>
<p>探测方法：</p>
<ul>
<li>线性探测</li>
</ul>
<p>缺点：费时间，元素容易聚集，分布不均匀，聚集越多性能越差</p>
<ul>
<li>平方探测</li>
</ul>
<p>避免了元素的聚集，如果顺序表长度为指数，顺序表空位多于一半，平方探测总能插入新元素</p>
<ul>
<li>伪随机探测</li>
</ul>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">3</span>;        <span class="comment">//大于数据范围的第一个质数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> null = <span class="number">0x3f3f3f3f</span>;  <span class="comment">//规定空指针为 null 0x3f3f3f3f</span></span><br><span class="line"><span class="comment">//这个数只要不在原本数据范围内就行</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//这一个函数同时实现查找和插入功能</span></span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x) &#123;</span><br><span class="line">        t++;<span class="comment">//这一步是线性探测，可以使用平方或者伪随机优化</span></span><br><span class="line">        <span class="keyword">if</span> (t == N) &#123;<span class="comment">//如果到头了，就返回从头找</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;  <span class="comment">//如果这个位置是空的, 则返回的是他应该存储的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);  <span class="comment">//规定空指针为 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) &#123;</span><br><span class="line">            h[<span class="built_in">find</span>(x)] = x;<span class="comment">//妙啊</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="杜鹃哈希😎"><a href="#杜鹃哈希😎" class="headerlink" title="杜鹃哈希😎"></a>杜鹃哈希😎</h4><p>感觉：拆东墙补西墙，但是很牛逼</p>
<p>优点：只要两个表中间有元素，一定可以通过哈希函数在顺序表中直接找到不用探测，非常高效</p>
<p>原因：所有索引位置都是哈希函数得到</p>
<h6 id="失败时："><a href="#失败时：" class="headerlink" title="失败时："></a>失败时：</h6><ul>
<li>没有足够空间，路径无限循环</li>
<li>转移链表过长</li>
</ul>
<p>缺点：元素过多时候插入元素困难</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/blubluhao/article/details/74912393?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%9D%9C%E9%B9%83%E5%93%88%E5%B8%8C&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-74912393.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1&spm=1018.2226.3001.4187" >(101条消息) 杜鹃散列_EmberWn的博客-CSDN博客_杜鹃散列<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/awst-lee/p/16801380.html" >【散列】杜鹃散列详情与C++实现代码 - awst_lee - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/kekukele/p/3812780.html" >Cuckoo hash算法分析 - 可酷可乐 - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cuckoo_hashing" >Cuckoo hashing - Wikipedia<i class="fas fa-external-link-alt"></i></a>（科学上网看）</p>
<p>杜鹃哈希举例：</p>
<p><strong>坏消息：根本看不懂</strong></p>
<p><strong>好消息：不用看了</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为杜鹃散列生成泛型HashFamily接口,用来发出多簇散列函数到杜鹃散列表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CuckooHashFamily</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> AnyType&amp; x, <span class="type">int</span> which)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getNumberOfFunctions</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">generateNewFunctions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 杜鹃散列法的非正式字符串散列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> count&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringHashFamily</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; MULTIPLIERS;</span><br><span class="line">	UniformRandom r;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StringHashFamily</span>() :<span class="built_in">MULTIPLIERS</span>(count) &#123;</span><br><span class="line">		<span class="built_in">generateNewFuntions</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getNumberOfFunctions</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">generateNewFuntions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; mult : MULTIPLIERS)</span><br><span class="line">			mult = r.<span class="built_in">nextInt</span>();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> string&amp; x, <span class="type">int</span> which)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> multiplier = MULTIPLIERS[which];</span><br><span class="line">		<span class="type">size_t</span> hashVal = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> ch : x)</span><br><span class="line">			hashVal = multiplier * hashVal + ch;</span><br><span class="line">		<span class="keyword">return</span> hashVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//杜鹃散列类接口，允许(由HashFamily模板参数类型指定)任意个数的散列函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AnyType, <span class="keyword">typename</span> HashFamily&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">HashEntry</span> &#123;</span><br><span class="line">		AnyType element;</span><br><span class="line">		<span class="type">bool</span> isActive;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">HashEntry</span>(<span class="type">const</span> AnyType&amp;e=<span class="built_in">AnyType</span>(),<span class="type">bool</span> a=<span class="literal">false</span>)</span><br><span class="line">			:element&#123;e&#125;,isActive&#123;a&#125;&#123;&#125;</span><br><span class="line">		<span class="built_in">HashEntry</span>(AnyType&amp;&amp;e,<span class="type">bool</span> a=<span class="literal">false</span>)</span><br><span class="line">			:element&#123;std::<span class="built_in">move</span>(e)&#125;,isActive&#123;a&#125;&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 杜鹃散列的插入例程使用不同的算法，</span></span><br><span class="line"><span class="comment">	* 该算法随机选择要逐出的项，</span></span><br><span class="line"><span class="comment">	* 但不再试图重新逐出最后的项。</span></span><br><span class="line"><span class="comment">	* 如果存在太多的逐出项则散列表将尝试选取新的散列函数(再散列)，</span></span><br><span class="line"><span class="comment">	* 而若有太多的再散列则散列表将扩张</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insertHelper1</span><span class="params">(<span class="type">const</span> AnyType&amp; xx)</span> </span>&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> COUNT_LIMIT = <span class="number">100</span>;</span><br><span class="line">		AnyType x = xx;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="type">int</span> lastPos = <span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> pos;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; COUNT_LIMIT; ++count) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; ++i)</span><br><span class="line">					pos = <span class="built_in">myhash</span>(x, i);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">isActive</span>(pos)) &#123;</span><br><span class="line">					array[pos] = std::<span class="built_in">move</span>(HashEntry&#123; std::<span class="built_in">move</span>(x),<span class="literal">true</span> &#125;);</span><br><span class="line">					++currentSize;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//无可用位置，逐出一个随机项</span></span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				pos = <span class="built_in">myhash</span>(x, r.<span class="built_in">nextInt</span>(numHashFunctions));</span><br><span class="line">			&#125; <span class="keyword">while</span> (pos == lastPos &amp;&amp; i++ &lt; <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">			lastPos = pos;</span><br><span class="line">			std::<span class="built_in">swap</span>(x, array[pos].element);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (++rehashes &gt; ALLOWED_REHASHES) &#123;</span><br><span class="line">			<span class="built_in">expand</span>();		<span class="comment">//使散列表扩大</span></span><br><span class="line">			rehashes = <span class="number">0</span>;	<span class="comment">//重置rehashes的计数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">rehash</span>();		<span class="comment">//表大小相同，散列函数都是新的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insertHelper1</span><span class="params">(AnyType&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> COUNT_LIMIT = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="type">int</span> lastPos = <span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> pos;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; COUNT_LIMIT; ++count) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; ++i)</span><br><span class="line">					pos = <span class="built_in">myhash</span>(x, i);</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">isActive</span>(pos)) &#123;</span><br><span class="line">					array[pos] = std::<span class="built_in">move</span>(HashEntry&#123; std::<span class="built_in">move</span>(x),<span class="literal">true</span> &#125;);</span><br><span class="line">					++currentSize;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//无可用位置，逐出一个随机项</span></span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				pos = <span class="built_in">myhash</span>(x, r.<span class="built_in">nextInt</span>(numHashFunctions));</span><br><span class="line">			&#125; <span class="keyword">while</span> (pos == lastPos &amp;&amp; i++ &lt; <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">			lastPos = pos;</span><br><span class="line">			std::<span class="built_in">swap</span>(x, array[pos].element);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (++rehashes &gt; ALLOWED_REHASHES) &#123;</span><br><span class="line">			<span class="built_in">expand</span>();		<span class="comment">//使散列表扩大</span></span><br><span class="line">			rehashes = <span class="number">0</span>;	<span class="comment">//重置rehashes的计数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">rehash</span>();		<span class="comment">//表大小相同，散列函数都是新的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isActive</span><span class="params">(<span class="type">int</span> currentPos)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> currentPos != <span class="number">-1</span> &amp;&amp; array[currentPos].isActive;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 使用特定函数计算x的散列代码</span></span><br><span class="line"><span class="comment">	* 选取适当的散列函数，然后把它换算成合法的数组下标</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">myhash</span><span class="params">(<span class="type">const</span> AnyType&amp; x, <span class="type">int</span> which)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hashFunctions.<span class="built_in">hash</span>(x, which) % array.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 查找所有散列函数的位置</span></span><br><span class="line"><span class="comment">	* 返回查阅所有的散列函数以返回包含项x的下标，若找不到则返回-1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">findPos</span><span class="params">(<span class="type">const</span> AnyType&amp; x)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> pos = <span class="built_in">myhash</span>(x, i);</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isActive</span>(pos) &amp;&amp; array[pos].element == x)</span><br><span class="line">				<span class="keyword">return</span> pos;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 创建一个大数组但使用那些相同的散列函数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">rehash</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(array.<span class="built_in">size</span>() / MAX_LOAD));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 保留数组的大小不变，创建一个新的数组</span></span><br><span class="line"><span class="comment">	* 该数组使用那些新选出的散列函数填充</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		hashFunctions.<span class="built_in">generateNewFuntions</span>();</span><br><span class="line">		<span class="built_in">rehash</span>(array.<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">(<span class="type">int</span> newSize)</span> </span>&#123;</span><br><span class="line">		std::vector&lt;HashEntry&gt; oldArray = array;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//创建新的双倍大小的空散列表</span></span><br><span class="line">		array.<span class="built_in">resize</span>(<span class="built_in">nextPrime</span>(newSize));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : array)</span><br><span class="line">			entry.isActive = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//复制整个表</span></span><br><span class="line">		currentSize = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : oldArray)</span><br><span class="line">			<span class="keyword">if</span> (entry.isActive)</span><br><span class="line">				<span class="built_in">insert</span>(std::<span class="built_in">move</span>(entry.element));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> MAX_LOAD=<span class="number">0.4</span>; <span class="comment">//最大装填因子</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ALLOWED_REHASHES = <span class="number">5</span>; <span class="comment">//最大散列次数</span></span><br><span class="line"> </span><br><span class="line">	vector&lt;HashEntry&gt;array;</span><br><span class="line">	<span class="type">int</span> currentSize;</span><br><span class="line">	<span class="type">int</span> numHashFunctions;</span><br><span class="line">	<span class="type">int</span> rehashes;</span><br><span class="line">	UniformRandom r;</span><br><span class="line">	HashFamily hashFunctions;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">HashTable</span><span class="params">(<span class="type">int</span> size = <span class="number">101</span>)</span> :array(nextPrime(size)) &#123;</span></span><br><span class="line">		numHashFunctions = hashFunctions.<span class="built_in">getNumberOfFunctions</span>();</span><br><span class="line">		rehashes = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">makeEmpty</span>();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//清空杜鹃散列表</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">makeEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		currentSize = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : array)</span><br><span class="line">			entry.isActive = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 搜索杜鹃散列表的例程</span></span><br><span class="line"><span class="comment">	* 如果找到x则返回true</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> AnyType&amp; x)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findPos</span>(x) != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 从散列表中删除x</span></span><br><span class="line"><span class="comment">	* 若项x被找到且被删除则返回true</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> AnyType&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> currentPos = <span class="built_in">findPos</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">isActive</span>(currentPos))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		array[currentPos].isActive = <span class="literal">false</span>;</span><br><span class="line">		--currentSize;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//杜鹃散列表中公有插入方法</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> AnyType&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">contains</span>(x))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (currentSize &gt;= array.<span class="built_in">size</span>() * MAX_LOAD)</span><br><span class="line">			<span class="built_in">expand</span>(); </span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">insertHelper1</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(AnyType&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">contains</span>(x))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (currentSize &gt;= array.<span class="built_in">size</span>() * MAX_LOAD)</span><br><span class="line">			<span class="built_in">expand</span>(); </span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">insertHelper1</span>(std::<span class="built_in">move</span>(x));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> currentSize;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> array.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>最后通过看大神的代码才恍然大悟，二叉树的建立，需要按照一棵满二叉树来建立</p>
<p>问题来了，我们的节点不够满二叉树的，这就是关键，空节点也需要补上！</p>
<p>使用数组构造一棵二叉树也是同理！</p>
<h6 id="完全二叉树的构建（0作为空节点，会有空间浪费）"><a href="#完全二叉树的构建（0作为空节点，会有空间浪费）" class="headerlink" title="完全二叉树的构建（0作为空节点，会有空间浪费）"></a>完全二叉树的构建（0作为空节点，会有空间浪费）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1010</span>;<span class="comment">//完全二叉树</span></span><br><span class="line"><span class="type">int</span> tree[M]=&#123;<span class="number">0</span>&#125;;<span class="comment">//全部初始化成0方便判断</span></span><br><span class="line"><span class="type">int</span> judge=<span class="number">1</span>;<span class="comment">//判断是否继续读入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">real_depth</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        n=n/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLR</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;tree[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">DLR</span>(i*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">DLR</span>(i*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LDR</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">DLR</span>(i*<span class="number">2</span>);</span><br><span class="line">        cout&lt;&lt;tree[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">DLR</span>(i*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRD</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DLR</span>(i*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">DLR</span>(i*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;tree[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> node_num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++ )<span class="comment">//计数是第几组</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        cin&gt;&gt;node;</span><br><span class="line">        tree[<span class="number">1</span>]=node;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="number">0</span>||node==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(judge==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt; node;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;&quot;node:  &quot;&lt;&lt;node&lt;&lt;endl;</span></span><br><span class="line">            ++i;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(node==<span class="number">-1</span>)<span class="comment">//实现了深度搞定，接下来是前序遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">real_depth</span>(i<span class="number">-1</span>) &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[i/<span class="number">2</span>]!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tree[i]=node;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tree[i/<span class="number">2</span>]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(tree[i/<span class="number">2</span>]==<span class="number">0</span>)i=i/<span class="number">2</span>;<span class="comment">//回退到上层节点是有数字</span></span><br><span class="line">                    i=i/<span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;&quot;back: &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">while</span>(tree[i*<span class="number">2</span>])i=i*<span class="number">2</span>;</span><br><span class="line">                    i=i*<span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;&quot;go: &quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">                    tree[i]=node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node_num=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DLR</span>(<span class="number">1</span>);<span class="comment">//完全二叉树记得要从节点1开始，也就是初始的节点</span></span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=node_num;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           tree[i]=<span class="number">0</span>;<span class="comment">//清零</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="树的恢复"><a href="#树的恢复" class="headerlink" title="树的恢复"></a>树的恢复</h4><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43889841/article/details/96907208" >(105条消息) 先序遍历中序遍历还原二叉树_May Hacker的博客-CSDN博客_先序遍历中序遍历还原树<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="由先序和中序恢复二叉树"><a href="#由先序和中序恢复二叉树" class="headerlink" title="由先序和中序恢复二叉树"></a>由先序和中序恢复二叉树</h5><p>理论基础：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/" >105. 从前序与中序遍历序列构造二叉树 - 力扣（Leetcode）<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="背也要背会的模板"><a href="#背也要背会的模板" class="headerlink" title="背也要背会的模板:"></a>背也要背会的模板:</h6><p>[(105条消息) 根据先序中序还原二叉树_BugMaker-shen的博客-CSDN博客_由先序和中序恢复二叉树](<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42500831/article/details/105984986?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%85%88%E5%BA%8F" >https://blog.csdn.net/qq_42500831/article/details/105984986?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=先序<i class="fas fa-external-link-alt"></i></a> + 中序 恢复二叉树&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-105984986.142^v63^control,201^v3^control_1,213^v2^t3_control1&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>原理：使用递归</p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-17%20155014.png"
                      alt="屏幕截图 2022-11-17 155014" style="zoom:50%;" 
                >

<p>🙏🙏🙏🙏🙏🙏🙏🙏🙏感谢这位西电的朋友助我脱离苦海，感谢感谢</p>
<p>可以直接用那种：😭😭😭😭（<strong>数据结构放假是机考！机考！机考！我giao！！！</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">char</span> data)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">getCharArray</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这一步就是为了利用vector有现成的构造函数，能省很多步骤</span></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : str)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里的for(char c:str)就是定义一个遍历字符c，让它分别等于字符串数组str里面的各个字符，然后执行下面的语句，当c被赋值为str里面所有字符各一次后，就会退出这个循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这相当于JAVA的强for循环的语法结构。相当于C++的：</span></span><br><span class="line"><span class="comment">for( int i = 0; i &lt; s.length(); i++)</span></span><br><span class="line"><span class="comment">&#123; s[i]…</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">getTree</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; preOrder, vector&lt;<span class="type">char</span>&gt;&amp; inOrder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preOrder.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* root = <span class="keyword">new</span> <span class="built_in">Node</span>(preOrder[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//构造根结点，并且将root指针指向前序的第一个节点，即总根节点</span></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;::iterator mid = <span class="built_in">find</span>(inOrder.<span class="built_in">begin</span>(), inOrder.<span class="built_in">end</span>(), preOrder[<span class="number">0</span>]);<span class="comment">//遍历一次找到前序在</span></span><br><span class="line">    <span class="type">int</span> left_nodes = mid - inOrder.<span class="built_in">begin</span>();<span class="comment">//接下来进行分区处理</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">left_inOrder</span><span class="params">(inOrder.begin(), mid)</span></span>;<span class="comment">//中序的左子树</span></span><br><span class="line">    <span class="comment">//这里直接用了vector的构造，将inOrder赋值过去，最后一个mid不会复制</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">right_inOrder</span><span class="params">(mid+<span class="number">1</span>, inOrder.end())</span></span>;<span class="comment">//中序的右子树</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">left_preOrder</span><span class="params">(preOrder.begin()+<span class="number">1</span>, preOrder.begin()+<span class="number">1</span>+left_nodes)</span></span>;<span class="comment">//前序的左子树，就省去根节点了</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">right_preOrder</span><span class="params">(preOrder.begin()+<span class="number">1</span>+left_nodes, preOrder.end())</span></span>;<span class="comment">//前序右子树</span></span><br><span class="line">    root-&gt;left = <span class="built_in">getTree</span>(left_preOrder, left_inOrder);<span class="comment">//新树的左子树</span></span><br><span class="line">    root-&gt;right = <span class="built_in">getTree</span>(right_preOrder, right_inOrder);<span class="comment">//新树右子树</span></span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//返回一个节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span></span>&#123;<span class="comment">//后续遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    cout&lt;&lt;root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string pre_str;</span><br><span class="line">    string in_str;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; pre_str &gt;&gt; in_str)&#123;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; preOrder = <span class="built_in">getCharArray</span>(pre_str);<span class="comment">//string转换成vector向量形式</span></span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; inOrder = <span class="built_in">getCharArray</span>(in_str);<span class="comment">//</span></span><br><span class="line">        Node* root = <span class="built_in">getTree</span>(preOrder, inOrder);</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LeetCode解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inorderBegin, <span class="type">int</span> inorderEnd, vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> preorderBegin, <span class="type">int</span> preorderEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorderBegin == preorderEnd) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootValue = preorder[preorderBegin]; <span class="comment">// 注意用preorderBegin 不要用0</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preorderEnd - preorderBegin == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切割中序数组</span></span><br><span class="line">        <span class="comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span></span><br><span class="line">        <span class="type">int</span> leftInorderBegin = inorderBegin;</span><br><span class="line">        <span class="type">int</span> leftInorderEnd = delimiterIndex;</span><br><span class="line">        <span class="comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span></span><br><span class="line">        <span class="type">int</span> rightInorderBegin = delimiterIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightInorderEnd = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割前序数组</span></span><br><span class="line">        <span class="comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span></span><br><span class="line">        <span class="type">int</span> leftPreorderBegin =  preorderBegin + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftPreorderEnd = preorderBegin + <span class="number">1</span> + delimiterIndex - inorderBegin; <span class="comment">// 终止位置是起始位置加上中序左区间的大小size</span></span><br><span class="line">        <span class="comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span></span><br><span class="line">        <span class="type">int</span> rightPreorderBegin = preorderBegin + <span class="number">1</span> + (delimiterIndex - inorderBegin);</span><br><span class="line">        <span class="type">int</span> rightPreorderEnd = preorderEnd;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;leftInorder :&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = leftInorderBegin; i &lt; leftInorderEnd; i++) &#123;</span><br><span class="line">            cout &lt;&lt; inorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;rightInorder :&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rightInorderBegin; i &lt; rightInorderEnd; i++) &#123;</span><br><span class="line">            cout &lt;&lt; inorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;leftPreorder :&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = leftPreorderBegin; i &lt; leftPreorderEnd; i++) &#123;</span><br><span class="line">            cout &lt;&lt; preorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;rightPreorder :&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rightPreorderBegin; i &lt; rightPreorderEnd; i++) &#123;</span><br><span class="line">            cout &lt;&lt; preorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="并查集——面试涉及——竞赛频率也高😍"><a href="#并查集——面试涉及——竞赛频率也高😍" class="headerlink" title="并查集——面试涉及——竞赛频率也高😍"></a>并查集——面试涉及——竞赛频率也高😍</h4><p><strong>面试官一般都习惯去问一些代码短但是思路精巧的（便于手写代码）</strong></p>
<p>提前学习知识：链表，线性表</p>
<p>全名：归并查找集合，即判断两个元素是否属于同一个集合</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/838/" >836. 合并集合 - AcWing题库<i class="fas fa-external-link-alt"></i></a></p>
<p>可选方法：</p>
<ul>
<li>建两个哈希表分别找</li>
<li>建两个跳表分别找</li>
</ul>
<p>在集合经常动态变化时候，查找方法效率并不高</p>
<h6 id="并查集应用："><a href="#并查集应用：" class="headerlink" title="并查集应用："></a>并查集应用：</h6><p>快速处理下列问题：</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否属于同一个集合中</li>
</ol>
<p><strong>并查集能在近乎O（1）的时间复杂度之内快速支持以上两种操作</strong></p>
<p>正常：合并元素方式，至少需要对线性表&#x2F;链表整个进行一次遍历，耗时高</p>
<h6 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h6><p><strong>每一个集合使用一棵树来维护（不一定是二叉树，可能是三叉树，B+树等），每一个集合的编号就是根节点的编号</strong>，树中对于每一个点都存储其父节点（用p[x]表示x的父节点），在求某个元素是否属于某一个集合的时候，就在该元素向上遍历，知道到达根节点，最后判断根节点的编号是否是所需编号</p>
<p><strong>解决问题与流程：</strong></p>
<ol>
<li><p>如何判断树根，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[x]==x)<span class="comment">//对于树根编号等于自身</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何求x的集合编号:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p[x]!=x)x=p[x]<span class="comment">//多么熟悉的链表的遍历操作，因此是链表实现</span></span><br><span class="line">    <span class="comment">//这一步实际上的时间复杂度会高，因为还是会向上进行一个遍历，时间和树的高度有关，因此树最好高度越低越好</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何合并两个集合：<strong>加一条边，将一个树插入到另一棵树身上就可以</strong></p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-17%20164329.png"
                      alt="屏幕截图 2022-11-17 164329" style="zoom:33%;" 
                >

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设p[x]是x集合编号，p[y]是y的集合编号，那么只需要</span></span><br><span class="line">p[x]=y</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//核心的函数</span></span></span><br><span class="line"><span class="function">    <span class="comment">//加上路径压缩，会自动找到根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if(p[x]!=x)x=p[x];</span></span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="comment">//易错：p[x]=find(p[x])这里要更新的</span></span><br><span class="line">    <span class="comment">//易错：这里是if不能是循环while</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    上面两句分别是普通版本和加过路径优化的版本</span></span><br><span class="line"><span class="comment">    第一个就是普通循环进行查找</span></span><br><span class="line"><span class="comment">    第二局是调用递归，每一次在寻找的时候都会对当前的节点进行更新，初次执行会慢，之后速度会飞升</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> p[x];<span class="comment">//最后返回一个根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        p[x]=y;<span class="comment">//核心函数二：合并     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//定义多个集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:</span></span><br><span class="line"><span class="comment">    p[x]=x;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="comment">//找到了便返回祖宗节点的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x ,<span class="type">int</span> y)</span><span class="comment">//这里是把x的头并到y了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);<span class="comment">//这里进行操作使用上一步的find函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;M&#x27;</span>) <span class="built_in">merge</span>(a,b);<span class="comment">//集合合并操作</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))</span><br><span class="line">        <span class="comment">//如果祖宗节点一样,就输出yes</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="并查集优化：路径压缩"><a href="#并查集优化：路径压缩" class="headerlink" title="并查集优化：路径压缩"></a>并查集优化：路径压缩</h5><p><strong>并查集最牛逼的优化方式，另一种优化基本写代码时候不会使用</strong></p>
<p>原理：<strong>一旦在向上走的时候找到了根节点，将该路径所有节点都指向根节点</strong>，即只需要搜索一次，之后的重复操作速度就会提高，可以视为O（1）优化</p>
<h6 id="优化：加权合并"><a href="#优化：加权合并" class="headerlink" title="优化：加权合并"></a>优化：加权合并</h6><p>防止树越来越高</p>
<p>记录每棵树元素的个数作为树的权重</p>
<h4 id="堆：完全二叉树的操作"><a href="#堆：完全二叉树的操作" class="headerlink" title="堆：完全二叉树的操作"></a>堆：完全二叉树的操作</h4><p>应用：</p>
<ul>
<li>构造优先队列</li>
</ul>
<p>（不用stl）手搓一个堆，堆的基本</p>
<ul>
<li>插入一个数</li>
<li>求这个集合当中的最小值</li>
<li>删除最小值</li>
<li>删除任意一个元素（stl无法直接实现）</li>
<li>修改任意一个元素（stl无法直接实现）</li>
</ul>
<h6 id="堆的基本结构："><a href="#堆的基本结构：" class="headerlink" title="堆的基本结构："></a>堆的基本结构：</h6><p>堆属于一棵<strong>完全</strong>二叉树（指除了最后一排其他都是均匀分布，即所有节点都不是非空），最后一层节点从左到右依次排列</p>
<p>小根堆的性质：每一个点都是小于等于左右儿子（即递归定义），则根节点就是最小值</p>
<p>大根堆：相反</p>
<p><strong>凡是完全二叉树都是用一维数组存储的</strong></p>
<p>1号点是根节点</p>
<p><strong>x的左儿子下标：2x,</strong></p>
<p><strong>x的右儿子下标：2x+1</strong></p>
<p>stl里面的堆就是优先队列</p>
<p>特点：</p>
<ul>
<li>时间复杂度非常稳定，不依赖原始记录状态	 </li>
<li>是一种不稳定的排序方法（记录比较与交换跳跃进行）</li>
</ul>
<h6 id="基本函数："><a href="#基本函数：" class="headerlink" title="基本函数："></a>基本函数：</h6><p>down(x)：如果某一个点的值变大，就将该值向下压</p>
<p>up(x)：如果一个点的值变小，向上升</p>
<p>两个函数的执行次数都和二叉树的深度成正比，也就是logn</p>
<p><strong>这里的x实际上是所处的位置</strong></p>
<p>由基本函数构成堆的几种操作：</p>
<ol>
<li>插入一个数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heap[++size]=x;<span class="comment">//这一步将堆数组的最后再一个换成需要的数</span></span><br><span class="line"><span class="built_in">up</span>(size);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>求最小值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>];<span class="comment">//是小根堆，则就最上面的就是最小的</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除最小值(也就是最顶部的根节点的删除)</li>
</ol>
<p><strong>思路</strong>：用堆底部的最后一个元素覆盖掉第一个元素，然后进行down（1)</p>
<p>原理：<strong>存储结构是一个一维数组</strong>，删除尾部节点很容易（直接size–就行），但删除头部却很麻烦</p>
<p>覆盖掉之后再使用向下函数down会让顶部元素下沉到正确位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>]=heap[size];</span><br><span class="line">size--;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除任意一个元素,和删除头部不太一样在于不确定改变值之后是大还是小</li>
</ol>
<p><strong>简单粗暴好使的办法：管他呢，down一次，up一次，因为up和down实际上只会执行一次</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heap[k]=heap[size];</span><br><span class="line">size--;<span class="comment">//</span></span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>修改任意一个元素的值：同删除一个元素的操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k]=x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure>

<h6 id="构建小细节："><a href="#构建小细节：" class="headerlink" title="构建小细节："></a><strong>构建小细节：</strong></h6><p>不同于其它的一般采用下标从0开始，对于树形结构，因为树的性质有左儿子&#x3D;根&#x2F;2，如果从0开始左儿子也是0，不方便，因此堆排序实际上是从1开始</p>
<h5 id="开始构建："><a href="#开始构建：" class="headerlink" title="开始构建："></a>开始构建：</h5><h6 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h6><p>可以用插入的方式操作，但每一次插入都是logn，实际上不好</p>
<p>有时间复杂度为on的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=size/<span class="number">2</span>,i&gt;<span class="number">0</span>;i--)<span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>

<h6 id="构建up"><a href="#构建up" class="headerlink" title="构建up"></a>构建up</h6><p>妙啊（发出抱大佬大腿的声音）😍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])<span class="comment">//不管u是左右儿子，都不重要，直接/2指向的双亲都是同一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;<span class="comment">//u变成原先的二分之一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="构建down"><a href="#构建down" class="headerlink" title="构建down"></a>构建down</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>]&lt;h[t])t=u*<span class="number">2</span>;<span class="comment">//先判断有没有左儿子，然后判断左儿子小</span></span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;=h[t])t=u*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//判断右儿子和大小</span></span><br><span class="line">    <span class="comment">//最后t存的就是根，左右儿子三者之中最小的值下标</span></span><br><span class="line">    <span class="keyword">if</span>(u!=t)<span class="comment">//不等，说明有可能还要继续递归进行对比</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//递归向下继续弄</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h5><p><strong>难点：支持随机的修改和删除</strong>,题中要求是第i个，但是i对应的下标会随着操作变化下标跟着变化，需要实时更新。因此<strong>映射也要交换好</strong></p>
<p><strong>解法：使用映射,老牛逼了</strong></p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-10%20234320.png"
                      alt="屏幕截图 2022-11-10 234320" style="zoom:33%;" 
                >

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="comment">//ph从左到右，hp从右到左、</span></span><br><span class="line"><span class="comment">//交换数的时候，指针也要交换</span></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//针对这一道题开发的映射关系转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<span class="comment">//指针交换</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);<span class="comment">//逆指针交换</span></span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);<span class="comment">//数值交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>

<h6 id="解题技巧："><a href="#解题技巧：" class="headerlink" title="解题技巧："></a>解题技巧：</h6><p>当题中有明确给出第i个操作数，要考虑如何通过更新操作数的下标</p>
<img  
                     lazyload
                     alt="image"
                     data-src="../../../../../me/%E9%85%8D%E5%9B%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-11-10%20234320.png"
                      alt="屏幕截图 2022-11-10 234320" style="zoom:50%;" 
                >

<h5 id="堆排序：onlogn"><a href="#堆排序：onlogn" class="headerlink" title="堆排序：onlogn"></a>堆排序：onlogn</h5><p><strong>一般升序使用大顶堆，降序采用小顶堆</strong></p>
<p>举例：对数组进行从小到大排序，输出前m小的数</p>
<p>思路：<strong>本题可以使用堆排序，构造小顶堆，然后输出堆顶，输出后把堆顶和堆尾交换。尾部边界缩小，重复执行m次即可。</strong></p>
<p>注意点：</p>
<ul>
<li>和完全二叉树一样下标从1开始</li>
</ul>
<h5 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h5><p>易错点：</p>
<h6 id="模拟堆（直接造小根堆）"><a href="#模拟堆（直接造小根堆）" class="headerlink" title="模拟堆（直接造小根堆）"></a>模拟堆（直接造小根堆）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">100100</span>;</span><br><span class="line"><span class="type">int</span> h[M];</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">big_down</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//最后大的会向下走</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>]&lt;h[t])t=u*<span class="number">2</span>;<span class="comment">//先判断有没有左儿子，然后判断左儿子小</span></span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;=h[t])t=u*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//判断右儿子和大小</span></span><br><span class="line">    <span class="comment">//最后t存的就是根，左右儿子三者之中最小的值下标</span></span><br><span class="line">    <span class="keyword">if</span>(u!=t)<span class="comment">//不等，说明有可能还要继续递归进行对比</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">big_down</span>(t);<span class="comment">//递归向下继续弄</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">small_down</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//最后小的会向下走</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>]&gt;h[t])t=u*<span class="number">2</span>;<span class="comment">//先判断有没有左儿子，然后判断左儿子小</span></span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size&amp;&amp;h[u*<span class="number">2</span>+<span class="number">1</span>]&gt;=h[t])t=u*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//判断右儿子和大小</span></span><br><span class="line">    <span class="comment">//最后t存的就是根，左右儿子三者之中最小的值下标</span></span><br><span class="line">    <span class="keyword">if</span>(u!=t)<span class="comment">//不等，说明有可能还要继续递归进行对比</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">small_down</span>(t);<span class="comment">//递归向下继续弄</span></span><br><span class="line">        注意这里向下的还是t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)<span class="comment">//二叉树的读入范围</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span>; i; i -- ) <span class="built_in">small_down</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span>; i; i -- ) <span class="built_in">big_down</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)cout&lt;&lt;h[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="堆排序（整体）"><a href="#堆排序（整体）" class="headerlink" title="堆排序（整体）"></a>堆排序（整体）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];<span class="comment">//保存数组</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//n个点，求前m小</span></span><br><span class="line"><span class="type">int</span> r ;<span class="comment">//堆的右边界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//调整函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//t记录最小点的编号</span></span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line"></span><br><span class="line">易错部分：这里前面都是u最后对比是t，修改大小也是修改<span class="function">u</span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(<span class="number">2</span> * u &lt;= r &amp;&amp; a[<span class="number">2</span> * u] &lt; a[t])</span> t </span>= <span class="number">2</span> * u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= r &amp;&amp; a[<span class="number">2</span> * u + <span class="number">1</span>] &lt; a[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果待调整点不是最小的</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//和最小的交换</span></span><br><span class="line">        <span class="built_in">swap</span>(a[u], a[t]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归处理</span></span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为堆是一棵二叉树构建起来的，因此是从<span class="number">1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    r = n;<span class="comment">//开始时，右边界是数组边界</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从第一个非叶节点开始，从右到左，从下到上处理每个节点</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = n /<span class="number">2</span> ; i ; i--)<span class="comment">//创建小根堆</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//注意问题在于它小得没有规律</span></span><br><span class="line">       <span class="built_in">down</span>(i);<span class="comment">//因为叶子节点没办法继续向下了，因此从叶子向上一层开始操作</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出m个最小值</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//堆顶保存的最小值，输出堆顶</span></span><br><span class="line">        cout &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将堆顶和右边界交换</span></span><br><span class="line">        <span class="built_in">swap</span>(a[<span class="number">1</span>], a[r]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右边界左移</span></span><br><span class="line">        r--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从新处理堆顶</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p><strong>下面这个关于编码的，很重要</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46518461/article/details/109404969?ops_request_misc=%7B%22request_id%22:%22166919312616782395398061%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166919312616782395398061&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-109404969-null-null.142%5Ev66%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev2%5Et3_control1&utm_term=%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91C++%E7%BC%96%E7%A0%81&spm=1018.2226.3001.4187" >(108条消息) 【数据结构——哈夫曼树及其应用】_FEI..的博客-CSDN博客_哈夫曼树的parent怎么求<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="哈夫曼编码-字母"><a href="#哈夫曼编码-字母" class="headerlink" title="哈夫曼编码:字母"></a>哈夫曼编码:字母</h5><p><strong>核心：无前缀编码</strong>，从根节点到叶子节点的路径代表编码，只要字母在叶子节点，对应编码就是无前缀</p>
<h6 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h6><ul>
<li>从底向上建立一棵无前缀编码树</li>
<li>频次低的树在最下面</li>
</ul>
<h6 id="自己写的代码-输入字符串进行编码并输出-："><a href="#自己写的代码-输入字符串进行编码并输出-：" class="headerlink" title="自己写的代码(输入字符串进行编码并输出)："></a>自己写的代码(输入字符串进行编码并输出)：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//结点的权值</span></span><br><span class="line">    <span class="type">int</span> parent, lchild, rchild;<span class="comment">//双亲、左孩子、右孩子的下标</span></span><br><span class="line">&#125;HTnode,*HuffmanTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree&amp; HT,<span class="type">int</span> &amp;s1,<span class="type">int</span> &amp;s2,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s2=<span class="number">1</span>,s1=<span class="number">2</span>;<span class="comment">//两个过大的数进行比对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++s1)<span class="comment">//在1到n之间的点进行寻找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HT[s1].parent==<span class="number">0</span>&amp;&amp;HT[s2].parent==<span class="number">0</span>)<span class="comment">//当</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(HT[s1].parent==<span class="number">0</span>)<span class="comment">//当</span></span><br><span class="line">        &#123;</span><br><span class="line">            s2=s1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2==s1)++s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)<span class="comment">//在1到n之间的点进行寻找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HT[i].weight&lt;=HT[s1].weight&amp;&amp;HT[i].parent==<span class="number">0</span>)<span class="comment">//当</span></span><br><span class="line">        &#123;</span><br><span class="line">            s1=i;<span class="comment">//连着更新两次，s1是最小的，s2是次小的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)<span class="comment">//在1到n之间的点进行寻找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HT[i].weight&lt;=HT[s2].weight&amp;&amp;HT[i].parent==<span class="number">0</span>&amp;&amp;i!=s1)<span class="comment">//当</span></span><br><span class="line">        &#123;</span><br><span class="line">            s2=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(HuffmanTree&amp; HT, <span class="type">int</span> n,<span class="type">int</span> word[])</span><span class="comment">//构造哈夫曼树，n为带权值的叶子结点个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用了以获取的word数组存取已有的数量</span></span><br><span class="line">    <span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="type">int</span> s1,s2;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;<span class="comment">//m为哈夫曼树中总结点的个数</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTnode[m + <span class="number">1</span>];<span class="comment">//0号单元未用，所以需要开辟m+1个单元，HT[m]表示根结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;++i)<span class="comment">//将1-m号单元的双亲，左右孩子的下标都初始化为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lchild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rchild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> word_select=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(;word[word_select]==<span class="number">0</span>;word_select++);</span><br><span class="line"><span class="comment">//        cout&lt;&lt;(char)word_select &lt;&lt;&quot; word=&quot;&lt;&lt;word[word_select]&lt;&lt;endl;</span></span><br><span class="line">        HT[i].weight=word[word_select];<span class="comment">//输入前n个单元中叶子结点的权值</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;i&lt;&lt;&quot;个单元叶子节点的权值： &quot;&lt;&lt;HT[i].weight&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//这一句是输入测试，ok了</span></span><br><span class="line">        word_select++;<span class="comment">//到下一个防止连续搞</span></span><br><span class="line">    &#125;<span class="comment">//到这一步都没问题，叶子节点权值都录入了</span></span><br><span class="line">    <span class="comment">/*初始化工作结束，下面开始创建哈夫曼树*/</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;n=:&quot;&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>;i &lt;= m;++i)</span><br><span class="line">    &#123;<span class="comment">//通过n-1次的选择、删除、合并来创建哈夫曼树</span></span><br><span class="line">        <span class="built_in">Select</span>(HT,  s1, s2,n);<span class="comment">//选择两个其双亲域为0且权值最小的结点</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;i-15&lt;&lt;&quot;次操作之后 &quot; &lt;&lt;&quot;s1 now=&quot;&lt;&lt;s1&lt;&lt;&quot; HT[s1].weight=&quot;&lt;&lt;HT[s1].weight;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;&quot;  s2 now =&quot;&lt;&lt;s2&lt;&lt;&quot; HT[s2].weight=&quot;&lt;&lt;HT[s2].weight&lt;&lt;endl;</span></span><br><span class="line">        HT[s1].parent = i;HT[s2].parent = i;<span class="comment">//得到新结点i,将s1\s2的双亲域由0改为i</span></span><br><span class="line">        HT[i].lchild = s1;HT[i].rchild = s2;<span class="comment">//s1、s2分别作为i的左右孩子</span></span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;<span class="comment">//i的权值为左右孩子的权值之和</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;&quot;  HT now =&quot;&lt;&lt;i&lt;&lt;&quot; HT[i].weight=&quot;&lt;&lt;HT[i].weight&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;</span><br><span class="line"><span class="comment">////动态分配数组存储哈夫曼编码表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode&amp; HC, <span class="type">int</span> n)</span><span class="comment">//完全没有开始写的</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从叶子到根逆向求每个字符的哈夫曼编码，储存在编码表HC中</span></span><br><span class="line">    HC = <span class="keyword">new</span> <span class="type">char</span>* [n + <span class="number">1</span>];<span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line">     <span class="type">char</span> *cd = <span class="keyword">new</span> <span class="type">char</span>[n];<span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line">     <span class="type">int</span> start;</span><br><span class="line">     <span class="type">int</span> c;</span><br><span class="line">     <span class="type">int</span> f;</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//编码结束符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)<span class="comment">//逐个字符求哈夫曼编码</span></span><br><span class="line">    &#123;</span><br><span class="line">        start = n - <span class="number">1</span>;<span class="comment">//start开始时指向最后，即编码结束符的位置</span></span><br><span class="line">        c = i;f = HT[i].parent;<span class="comment">//f指向结点c的双亲结点</span></span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">0</span>)<span class="comment">//从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            --start;<span class="comment">//回溯一次，start向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//结点c是f的左孩子，则生成代码0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//结点c是f的右孩子，则生成代码1</span></span><br><span class="line">            c = f;f = HT[f].parent;<span class="comment">//继续向上回溯</span></span><br><span class="line">        &#125;<span class="comment">//求出第i个字符的编码</span></span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="type">char</span>[n - start];<span class="comment">//为敌i个字符编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);<span class="comment">//将求得的编码从临时空间cd复制到HC当前行中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> cd;<span class="comment">//释放临时空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> out[<span class="number">128</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> word[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//作为字母</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, temp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;<span class="comment">//读入阶段</span></span><br><span class="line">    <span class="type">int</span> length=ans.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx=(<span class="type">int</span>)(ans[i]);</span><br><span class="line">        word[idx]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> node_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">128</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(word[i]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++node_num;</span><br><span class="line">            out[node_num]=(<span class="type">char</span>)i;</span><br><span class="line"><span class="comment">//            cout &lt;&lt;(char)i &lt;&lt; &quot;: &quot;&lt;&lt; word[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//这里获得了对应的编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HuffmanTree HT;</span><br><span class="line">    <span class="built_in">CreateHuffmanTree</span>(HT,node_num,word);</span><br><span class="line">    HuffmanCode HC;</span><br><span class="line">    <span class="built_in">CreatHuffmanCode</span>(HT,HC,node_num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=node_num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;out[i]&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;HC[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program for Huffman Coding</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This constant can be avoided by explicitly</span></span><br><span class="line"><span class="comment">// calculating height of Huffman Tree</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_HT 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Huffman tree node</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeapNode</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// One of the input characters</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Frequency of the character</span></span><br><span class="line">	<span class="type">unsigned</span> freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Left and right child of this node</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeapNode</span> *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Min Heap: Collection of</span></span><br><span class="line"><span class="comment">// min-heap (or Huffman tree) nodes</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Current size of min heap</span></span><br><span class="line">	<span class="type">unsigned</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// capacity of min heap</span></span><br><span class="line">	<span class="type">unsigned</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Array of minheap node pointers</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>** array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function allocate a new</span></span><br><span class="line"><span class="comment">// min heap node with given character</span></span><br><span class="line"><span class="comment">// and frequency of the character</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>* <span class="built_in">newNode</span>(<span class="type">char</span> data, <span class="type">unsigned</span> freq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>* temp</span><br><span class="line">		= (<span class="keyword">struct</span> MinHeapNode*)<span class="built_in">malloc</span></span><br><span class="line">(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> MinHeapNode));</span><br><span class="line"></span><br><span class="line">	temp-&gt;left = temp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	temp-&gt;data = data;</span><br><span class="line">	temp-&gt;freq = freq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to create</span></span><br><span class="line"><span class="comment">// a min heap of given capacity</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">createMinHeap</span>(<span class="type">unsigned</span> capacity)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap</span><br><span class="line">		= (<span class="keyword">struct</span> MinHeap*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> MinHeap));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// current size is 0</span></span><br><span class="line">	minHeap-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	minHeap-&gt;capacity = capacity;</span><br><span class="line"></span><br><span class="line">	minHeap-&gt;array</span><br><span class="line">		= (<span class="keyword">struct</span> MinHeapNode**)<span class="built_in">malloc</span>(minHeap-&gt;</span><br><span class="line">capacity * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> MinHeapNode*));</span><br><span class="line">	<span class="keyword">return</span> minHeap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to</span></span><br><span class="line"><span class="comment">// swap two min heap nodes</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapMinHeapNode</span><span class="params">(<span class="keyword">struct</span> MinHeapNode** a,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">struct</span> MinHeapNode** b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>* t = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The standard minHeapify function.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap, <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> smallest = idx;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">2</span> * idx + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> right = <span class="number">2</span> * idx + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[left]-&gt;</span><br><span class="line">freq &lt; minHeap-&gt;array[smallest]-&gt;freq)</span><br><span class="line">		smallest = left;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (right &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[right]-&gt;</span><br><span class="line">freq &lt; minHeap-&gt;array[smallest]-&gt;freq)</span><br><span class="line">		smallest = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (smallest != idx) &#123;</span><br><span class="line">		<span class="built_in">swapMinHeapNode</span>(&amp;minHeap-&gt;array[smallest],</span><br><span class="line">						&amp;minHeap-&gt;array[idx]);</span><br><span class="line">		<span class="built_in">minHeapify</span>(minHeap, smallest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to check</span></span><br><span class="line"><span class="comment">// if size of heap is 1 or not</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isSizeOne</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (minHeap-&gt;size == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A standard function to extract</span></span><br><span class="line"><span class="comment">// minimum value node from heap</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>* <span class="built_in">extractMin</span>(<span class="keyword">struct</span> MinHeap* minHeap)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>* temp = minHeap-&gt;array[<span class="number">0</span>];</span><br><span class="line">	minHeap-&gt;array[<span class="number">0</span>]</span><br><span class="line">		= minHeap-&gt;array[minHeap-&gt;size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	--minHeap-&gt;size;</span><br><span class="line">	<span class="built_in">minHeapify</span>(minHeap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to insert</span></span><br><span class="line"><span class="comment">// a new node to Min Heap</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertMinHeap</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">struct</span> MinHeapNode* minHeapNode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	++minHeap-&gt;size;</span><br><span class="line">	<span class="type">int</span> i = minHeap-&gt;size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &amp;&amp; minHeapNode-&gt;freq &lt; minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>]-&gt;freq) &#123;</span><br><span class="line"></span><br><span class="line">		minHeap-&gt;array[i] = minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">		i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	minHeap-&gt;array[i] = minHeapNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A standard function to build min heap</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildMinHeap</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n = minHeap-&gt;size - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="built_in">minHeapify</span>(minHeap, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to print an array of size n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		cout&lt;&lt; arr[i];</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility function to check if this node is leaf</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">struct</span> MinHeapNode* root)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !(root-&gt;left) &amp;&amp; !(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a min heap of capacity</span></span><br><span class="line"><span class="comment">// equal to size and inserts all character of</span></span><br><span class="line"><span class="comment">// data[] in min heap. Initially size of</span></span><br><span class="line"><span class="comment">// min heap is equal to capacity</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">createAndBuildMinHeap</span>(<span class="type">char</span> data[], <span class="type">int</span> freq[], <span class="type">int</span> size)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">createMinHeap</span>(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		minHeap-&gt;array[i] = <span class="built_in">newNode</span>(data[i], freq[i]);</span><br><span class="line"></span><br><span class="line">	minHeap-&gt;size = size;</span><br><span class="line">	<span class="built_in">buildMinHeap</span>(minHeap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> minHeap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main function that builds Huffman tree</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>* <span class="built_in">buildHuffmanTree</span>(<span class="type">char</span> data[], <span class="type">int</span> freq[], <span class="type">int</span> size)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeapNode</span> *left, *right, *top;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Create a min heap of capacity</span></span><br><span class="line">	<span class="comment">// equal to size. Initially, there are</span></span><br><span class="line">	<span class="comment">// modes equal to size.</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">createAndBuildMinHeap</span>(data, freq, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate while size of heap doesn&#x27;t become 1</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isSizeOne</span>(minHeap)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Step 2: Extract the two minimum</span></span><br><span class="line">		<span class="comment">// freq items from min heap</span></span><br><span class="line">		left = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">		right = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Step 3: Create a new internal</span></span><br><span class="line">		<span class="comment">// node with frequency equal to the</span></span><br><span class="line">		<span class="comment">// sum of the two nodes frequencies.</span></span><br><span class="line">		<span class="comment">// Make the two extracted node as</span></span><br><span class="line">		<span class="comment">// left and right children of this new node.</span></span><br><span class="line">		<span class="comment">// Add this node to the min heap</span></span><br><span class="line">		<span class="comment">// &#x27;$&#x27; is a special value for internal nodes, not used</span></span><br><span class="line">		top = <span class="built_in">newNode</span>(<span class="string">&#x27;$&#x27;</span>, left-&gt;freq + right-&gt;freq);</span><br><span class="line"></span><br><span class="line">		top-&gt;left = left;</span><br><span class="line">		top-&gt;right = right;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">insertMinHeap</span>(minHeap, top);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: The remaining node is the</span></span><br><span class="line">	<span class="comment">// root node and the tree is complete.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints huffman codes from the root of Huffman Tree.</span></span><br><span class="line"><span class="comment">// It uses arr[] to store codes</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCodes</span><span class="params">(<span class="keyword">struct</span> MinHeapNode* root, <span class="type">int</span> arr[], <span class="type">int</span> top)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assign 0 to left edge and recur</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line"></span><br><span class="line">		arr[top] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printCodes</span>(root-&gt;left, arr, top + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assign 1 to right edge and recur</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line"></span><br><span class="line">		arr[top] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printCodes</span>(root-&gt;right, arr, top + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is a leaf node, then</span></span><br><span class="line">	<span class="comment">// it contains one of the input</span></span><br><span class="line">	<span class="comment">// characters, print the character</span></span><br><span class="line">	<span class="comment">// and its code from arr[]</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isLeaf</span>(root)) &#123;</span><br><span class="line"></span><br><span class="line">		cout&lt;&lt; root-&gt;data &lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">		<span class="built_in">printArr</span>(arr, top);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main function that builds a</span></span><br><span class="line"><span class="comment">// Huffman Tree and print codes by traversing</span></span><br><span class="line"><span class="comment">// the built Huffman Tree</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanCodes</span><span class="params">(<span class="type">char</span> data[], <span class="type">int</span> freq[], <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Construct Huffman Tree</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeapNode</span>* root</span><br><span class="line">		= <span class="built_in">buildHuffmanTree</span>(data, freq, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Print Huffman codes using</span></span><br><span class="line">	<span class="comment">// the Huffman tree built above</span></span><br><span class="line">	<span class="type">int</span> arr[MAX_TREE_HT], top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printCodes</span>(root, arr, top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> arr[] = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line">	<span class="type">int</span> freq[] = &#123; <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">45</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> size = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HuffmanCodes</span>(arr, freq, size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果输出：</span></span><br><span class="line"><span class="comment">f: 0</span></span><br><span class="line"><span class="comment">c: 100</span></span><br><span class="line"><span class="comment">d: 101</span></span><br><span class="line"><span class="comment">a: 1100</span></span><br><span class="line"><span class="comment">b: 1101</span></span><br><span class="line"><span class="comment">e: 111</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>平衡二叉树：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/code_peak/article/details/120610047?ops_request_misc=%7B%22request_id%22:%22166979063716782390568989%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166979063716782390568989&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120610047-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev2%5Et3_control1&utm_term=avl%E6%A0%91c++&spm=1018.2226.3001.4187" >(110条消息) AVL树的详细实现(C++)_code_peak的博客-CSDN博客_c++实现avl树<i class="fas fa-external-link-alt"></i></a></p>
<p>avl树的各种延申应用：伸展树，B树，字典树</p>

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="../../../../tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">#学习笔记</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95PART2/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">数据结构与算法 PART 2</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="../../08/web%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Web项目会议记录</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9APART1"><span class="nav-number">1.</span> <span class="nav-text">数据结构与算法：PART1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">1.0.1.</span> <span class="nav-text">算法时间分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3idx"><span class="nav-number">1.0.2.</span> <span class="nav-text">理解idx:</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A7%91%E7%8F%AD%E5%AD%A6%E4%B9%A0%E9%A1%BA%E5%BA%8F%EF%BC%9A%EF%BC%88%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E6%8F%90%E9%AB%98%E5%86%99%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%89"><span class="nav-number">1.0.2.0.0.1.</span> <span class="nav-text">科班学习顺序：（如何逐步提高写程序的性能）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E5%8A%9E%E6%B3%95%EF%BC%9A"><span class="nav-number">1.0.2.0.0.2.</span> <span class="nav-text">提高程序性能办法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.0.2.0.0.3.</span> <span class="nav-text">程序运行时间因素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9E%B6%E6%9E%84"><span class="nav-number">1.0.2.0.0.4.</span> <span class="nav-text">冯诺依曼架构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="nav-number">1.0.2.0.0.5.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.3.</span> <span class="nav-text">基础算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.0.3.0.1.</span> <span class="nav-text">位运算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E2%80%94%E2%80%94%E3%80%8B%E9%87%8D%E8%A6%81%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%9E%8B%F0%9F%98%8D"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">快排——》重要，面试常用型😍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="nav-number">1.0.3.1.0.1.</span> <span class="nav-text">模板：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E5%90%88%E7%90%86%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%9AAcWing-785-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E%E4%B8%8E%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90-AcWing"><span class="nav-number">1.0.3.1.0.2.</span> <span class="nav-text">快排合理性分析：AcWing 785. 快速排序算法的证明与边界分析 - AcWing</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E7%A7%BB%E5%8A%A8%E7%89%88%E6%9C%AC%E5%BF%AB%E6%8E%92%EF%BC%88%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">1.0.3.1.1.</span> <span class="nav-text">单向移动版本快排（实际使用快慢指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.0.3.1.1.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#plus-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E6%8F%92%E5%85%A5-%E4%BA%8C%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E3%80%8B%E7%A8%B3%E5%AE%9A%E5%8F%88%E5%A5%BD%E4%BD%BF"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">plus:折半插入排序（插入+二分）——》稳定又好使</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.0.3.3.0.1.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.3.4.0.1.</span> <span class="nav-text">模板</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%B9%9F%E8%83%8C%E4%B8%8B%E6%9D%A5%EF%BC%89%F0%9F%98%83"><span class="nav-number">1.0.3.5.</span> <span class="nav-text">归并排序（另一个重要排序，也背下来）😃</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A-1"><span class="nav-number">1.0.3.5.0.1.</span> <span class="nav-text">模板：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E8%B6%A3%E5%BA%94%E7%94%A8%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">1.0.3.5.0.2.</span> <span class="nav-text">有趣应用：逆序对</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timsort%EF%BC%88%E4%BC%98%E5%8C%96%E5%90%8E%E5%BD%92%E5%B9%B6%EF%BC%89"><span class="nav-number">1.0.3.6.</span> <span class="nav-text">timsort（优化后归并）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%8F%90%E5%8F%96%E9%99%8D%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8D%87%E7%BA%A7%E4%B8%BA%E5%8D%87%E5%BA%8F"><span class="nav-number">1.0.3.6.0.1.</span> <span class="nav-text">核心：提取降序数组升级为升序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%A0%88%E5%A4%84%E7%90%86%E5%BD%92%E5%B9%B6"><span class="nav-number">1.0.3.6.0.2.</span> <span class="nav-text">核心：栈处理归并</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%88%86%E5%8C%BA%E9%95%BF%E5%BA%A6%E5%9C%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%89%8D%E9%A2%84%E5%85%88%E8%AE%A1%E7%AE%97"><span class="nav-number">1.0.3.6.0.3.</span> <span class="nav-text">核心：最小分区长度在排序之前预先计算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#timsort%E6%A8%A1%E6%9D%BF%EF%BC%88%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%EF%BC%81%EF%BC%89"><span class="nav-number">1.0.3.6.0.4.</span> <span class="nav-text">timsort模板（自己写的！）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">1.0.3.7.</span> <span class="nav-text">二分</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%88%E4%B8%A4%E7%A7%8D%EF%BC%89"><span class="nav-number">1.0.3.7.0.1.</span> <span class="nav-text">整数模板（两种）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A789-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4-AcWing%E9%A2%98%E5%BA%93"><span class="nav-number">1.0.3.7.0.2.</span> <span class="nav-text">整数经典例题：789. 数的范围 - AcWing题库</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#519-%E8%B7%B3%E7%9F%B3%E5%A4%B4-AcWing%E9%A2%98%E5%BA%93"><span class="nav-number">1.0.3.7.0.3.</span> <span class="nav-text">519. 跳石头 - AcWing题库</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.3.7.0.4.</span> <span class="nav-text">浮点模板</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%94%B9%E8%BF%9B%EF%BC%9A"><span class="nav-number">1.0.3.7.1.</span> <span class="nav-text">二分改进：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-number">1.0.3.7.1.1.</span> <span class="nav-text">插值查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="nav-number">1.0.3.7.1.2.</span> <span class="nav-text">关键不同：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="nav-number">1.0.3.7.1.3.</span> <span class="nav-text">斐波那契查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88%E5%BA%94%E7%94%A8%E5%B9%BF%E6%B3%9B%EF%BC%89"><span class="nav-number">1.0.3.8.</span> <span class="nav-text">前缀和（应用广泛）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8-x3D-LZW%E5%8E%8B%E7%BC%A9-gt-%E6%96%87%E6%9C%AC%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.0.3.8.1.</span> <span class="nav-text">前缀和+哈希表&#x3D;LZW压缩-&gt;文本压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E9%83%A8%E5%88%86%EF%BC%9A"><span class="nav-number">1.0.3.8.1.1.</span> <span class="nav-text">压缩部分：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E9%83%A8%E5%88%86%EF%BC%9A"><span class="nav-number">1.0.3.8.1.2.</span> <span class="nav-text">解压缩部分：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%9A%E6%95%B4%E6%95%B0%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">1.0.3.9.</span> <span class="nav-text">离散化：整数离散化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96%E6%A8%A1%E6%9D%BF%EF%BC%9A-c-%E7%89%88%E6%9C%AC"><span class="nav-number">1.0.3.9.0.1.</span> <span class="nav-text">离散化模板：(c++版本)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%EF%BC%9A%E4%B8%8D%E5%90%8C%E4%BA%8E%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">1.0.3.10.</span> <span class="nav-text">区间合并：不同于离散化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.0.3.10.0.1.</span> <span class="nav-text">步骤：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.3.10.0.2.</span> <span class="nav-text">代码模板</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.0.4.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="nav-number">1.0.4.1.0.1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%88%B6%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.0.4.1.0.2.</span> <span class="nav-text">链表制造方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%B6%E4%BD%9C"><span class="nav-number">1.0.4.1.0.3.</span> <span class="nav-text">单链表制作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%B6%E4%BD%9C"><span class="nav-number">1.0.4.1.0.4.</span> <span class="nav-text">双链表制作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">1.0.4.1.0.5.</span> <span class="nav-text">链表递归与双指针</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%A0%B7%E5%88%A9%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%EF%BC%9A%EF%BC%88%E6%9C%89%E9%82%A3%E4%B9%88%E4%B8%80%E7%82%B9%E7%82%B9%E8%B4%B9%E8%84%91%E5%AD%90%EF%BC%89"><span class="nav-number">1.0.4.1.0.6.</span> <span class="nav-text">同样利用递归实现链表逆序：（有那么一点点费脑子）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-1"><span class="nav-number">1.0.4.1.0.7.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%80%86%E5%BA%8F"><span class="nav-number">1.0.4.1.0.8.</span> <span class="nav-text">双指针实现逆序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8B%BC%E6%8E%A5%EF%BC%88%E5%8F%88%E6%98%AF%E9%80%92%E5%BD%92-x2F-bushi%EF%BC%89"><span class="nav-number">1.0.4.1.0.9.</span> <span class="nav-text">有序链表的拼接（又是递归&#x2F;bushi）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%EF%BC%9A%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E7%BF%BB%E8%BD%AC%EF%BC%89"><span class="nav-number">1.0.4.1.0.10.</span> <span class="nav-text">回文链表判断：（映射，递归，翻转）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zhan%EF%BC%88%E6%A0%88%EF%BC%89%E4%B8%8D%E6%98%AFB%E7%AB%99%E9%82%A3%E4%B8%AA"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">zhan（栈）不是B站那个</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A-1"><span class="nav-number">1.0.4.2.0.1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E5%88%B6%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.0.4.2.0.2.</span> <span class="nav-text">栈制造方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E5%81%9A%E9%9D%9E%E9%99%8D%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.4.2.0.3.</span> <span class="nav-text">栈做非降路径问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.0.4.2.0.4.</span> <span class="nav-text">中缀表达式转换后缀表达式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E6%9E%90"><span class="nav-number">1.0.4.2.0.5.</span> <span class="nav-text">正则表达式分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="nav-number">1.0.4.2.0.6.</span> <span class="nav-text">正则表达式代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%88%E7%9E%B3%E5%AD%94%E5%9C%B0%E9%9C%87%E5%9E%8B%E9%A2%98%E8%A7%A3%EF%BC%89%F0%9F%98%A2"><span class="nav-number">1.0.4.2.0.7.</span> <span class="nav-text">单调栈（瞳孔地震型题解）😢</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.0.4.3.0.1.</span> <span class="nav-text">队列构造方式：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">1.0.4.3.0.2.</span> <span class="nav-text">循环队列：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%EF%BD%9E%EF%BF%A3%E2%96%BD%EF%BF%A3-%EF%BD%9E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%BB%8F%E5%85%B8%EF%BC%88%E9%85%8D%E5%90%88%E5%8D%95%E8%B0%83%E6%A0%88%E9%A3%9F%E7%94%A8%EF%BC%89"><span class="nav-number">1.0.4.3.0.3.</span> <span class="nav-text">单调队列~~~~~~~(～￣▽￣)～滑动窗口经典（配合单调栈食用）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">1.0.4.4.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#KMP"><span class="nav-number">1.0.4.4.1.</span> <span class="nav-text">KMP</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BFy%E6%80%BB"><span class="nav-number">1.0.4.4.1.1.</span> <span class="nav-text">模板y总</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF"><span class="nav-number">1.0.4.4.1.2.</span> <span class="nav-text">前缀表：字符串的最长</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%96%B9%E6%B3%95%EF%BC%9A%E5%89%8D%E7%BC%80%E4%B8%8D%E5%87%8F%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.0.4.4.1.3.</span> <span class="nav-text">代码随想录方法：前缀不减形式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%E5%87%BA%E9%94%99%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.0.4.4.1.4.</span> <span class="nav-text">数据结构作业出错原因</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#automata-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">1.0.4.4.2.</span> <span class="nav-text">automata~有限状态自动机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%88%E6%9E%84%E5%BB%BA%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%8A%B6%E6%80%81%E8%A1%A8%EF%BC%89"><span class="nav-number">1.0.4.4.2.1.</span> <span class="nav-text">代码（构建自动机状态表）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E7%89%88%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">1.0.4.4.2.2.</span> <span class="nav-text">聪明版本自动机</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TRIE%E6%A0%91%EF%BC%88%E6%9C%89%E4%BA%9B%E7%B1%BB%E4%BC%BC%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%EF%BC%89"><span class="nav-number">1.0.4.4.3.</span> <span class="nav-text">TRIE树（有些类似哈夫曼树编码）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%B2%E6%A0%91"><span class="nav-number">1.0.4.4.3.1.</span> <span class="nav-text">如何存储：构建串树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE"><span class="nav-number">1.0.4.4.3.2.</span> <span class="nav-text">如何查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BATRIE%E6%A0%91"><span class="nav-number">1.0.4.4.3.3.</span> <span class="nav-text">构建TRIE树</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TRIE%E6%A0%91%E7%9A%84%E5%85%B6%E5%AE%83%E5%BA%94%E7%94%A8"><span class="nav-number">1.0.4.4.4.</span> <span class="nav-text">TRIE树的其它应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.0.4.4.4.1.</span> <span class="nav-text">思路：利用二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="nav-number">1.0.4.4.4.2.</span> <span class="nav-text">算法复杂度：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="nav-number">1.0.4.4.4.3.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E2%80%94%E2%80%94%E5%90%8C%E6%A0%B7%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E4%BD%86%E6%98%AF%E4%B8%8D%E7%94%A8%E6%89%8B%E6%90%93"><span class="nav-number">1.0.4.5.</span> <span class="nav-text">跳表——同样面试——但是不用手搓</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%8F%82%E8%80%83%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%9A"><span class="nav-number">1.0.4.5.0.1.</span> <span class="nav-text">一些参考的博客：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">1.0.4.5.0.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="nav-number">1.0.4.5.0.3.</span> <span class="nav-text">核心思想：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.0.4.5.1.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.0.4.5.1.1.</span> <span class="nav-text">构建过程：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TRIE%E6%A0%91%E7%9A%84%E5%85%B6%E5%AE%83"><span class="nav-number">1.0.4.5.1.2.</span> <span class="nav-text">TRIE树的其它</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8-%E9%9D%A2%E8%AF%95%E5%BE%88%E9%87%8D%E8%A6%81"><span class="nav-number">1.0.4.6.</span> <span class="nav-text">散列表——哈希表-面试很重要</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">1.0.4.6.0.1.</span> <span class="nav-text">线性表总结：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%BA%94%E7%94%A8"><span class="nav-number">1.0.4.6.0.2.</span> <span class="nav-text">哈希定义，应用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E6%A8%A1%E6%9D%BF%EF%BC%88%E6%AD%A3%E5%B8%B8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-number">1.0.4.6.0.3.</span> <span class="nav-text">哈希模板（正常+字符串版本）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%B4%A2%E5%BC%95%E5%80%BC"><span class="nav-number">1.0.4.6.0.4.</span> <span class="nav-text">分配索引值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E7%B4%A2%E5%BC%95%E5%80%BC%EF%BC%9A"><span class="nav-number">1.0.4.6.0.5.</span> <span class="nav-text">减少索引值：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E2%80%94%E2%80%94-gt-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-number">1.0.4.6.1.</span> <span class="nav-text">字符串哈希——&gt;字符串前缀哈希法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%EF%BC%89%F0%9F%98%8D%F0%9F%98%8D%F0%9F%98%8D%F0%9F%98%8D%F0%9F%98%8D"><span class="nav-number">1.0.4.7.</span> <span class="nav-text">哈希碰撞处理（面试高频）😍😍😍😍😍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%88Open-Hashing%EF%BC%89"><span class="nav-number">1.0.4.7.0.1.</span> <span class="nav-text">拉链法（Open Hashing）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95-Open-Addressing"><span class="nav-number">1.0.4.7.0.2.</span> <span class="nav-text">开放地址法 Open Addressing</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%9C%E9%B9%83%E5%93%88%E5%B8%8C%F0%9F%98%8E"><span class="nav-number">1.0.4.8.</span> <span class="nav-text">杜鹃哈希😎</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5%E6%97%B6%EF%BC%9A"><span class="nav-number">1.0.4.8.0.1.</span> <span class="nav-text">失败时：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.0.4.9.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%EF%BC%880%E4%BD%9C%E4%B8%BA%E7%A9%BA%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BC%9A%E6%9C%89%E7%A9%BA%E9%97%B4%E6%B5%AA%E8%B4%B9%EF%BC%89"><span class="nav-number">1.0.4.9.0.1.</span> <span class="nav-text">完全二叉树的构建（0作为空节点，会有空间浪费）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">1.0.4.10.</span> <span class="nav-text">树的恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.0.4.10.1.</span> <span class="nav-text">由先序和中序恢复二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%83%8C%E4%B9%9F%E8%A6%81%E8%83%8C%E4%BC%9A%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.0.4.10.1.1.</span> <span class="nav-text">背也要背会的模板:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E6%B6%89%E5%8F%8A%E2%80%94%E2%80%94%E7%AB%9E%E8%B5%9B%E9%A2%91%E7%8E%87%E4%B9%9F%E9%AB%98%F0%9F%98%8D"><span class="nav-number">1.0.4.11.</span> <span class="nav-text">并查集——面试涉及——竞赛频率也高😍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="nav-number">1.0.4.11.0.1.</span> <span class="nav-text">并查集应用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">1.0.4.11.0.2.</span> <span class="nav-text">基本原理：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%99%E6%B3%95%EF%BC%9A"><span class="nav-number">1.0.4.11.0.3.</span> <span class="nav-text">写法：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96%EF%BC%9A%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.0.4.11.1.</span> <span class="nav-text">并查集优化：路径压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E5%8A%A0%E6%9D%83%E5%90%88%E5%B9%B6"><span class="nav-number">1.0.4.11.1.1.</span> <span class="nav-text">优化：加权合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%EF%BC%9A%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.0.4.12.</span> <span class="nav-text">堆：完全二叉树的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">1.0.4.12.0.1.</span> <span class="nav-text">堆的基本结构：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.0.4.12.0.2.</span> <span class="nav-text">基本函数：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%B0%8F%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="nav-number">1.0.4.12.0.3.</span> <span class="nav-text">构建小细节：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%EF%BC%9A"><span class="nav-number">1.0.4.12.1.</span> <span class="nav-text">开始构建：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%A0%86"><span class="nav-number">1.0.4.12.1.1.</span> <span class="nav-text">构建堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAup"><span class="nav-number">1.0.4.12.1.2.</span> <span class="nav-text">构建up</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAdown"><span class="nav-number">1.0.4.12.1.3.</span> <span class="nav-text">构建down</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%A0%86"><span class="nav-number">1.0.4.12.2.</span> <span class="nav-text">模拟堆</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7%EF%BC%9A"><span class="nav-number">1.0.4.12.2.1.</span> <span class="nav-text">解题技巧：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9Aonlogn"><span class="nav-number">1.0.4.12.3.</span> <span class="nav-text">堆排序：onlogn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="nav-number">1.0.4.12.4.</span> <span class="nav-text">代码：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%A0%86%EF%BC%88%E7%9B%B4%E6%8E%A5%E9%80%A0%E5%B0%8F%E6%A0%B9%E5%A0%86%EF%BC%89"><span class="nav-number">1.0.4.12.4.1.</span> <span class="nav-text">模拟堆（直接造小根堆）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E6%95%B4%E4%BD%93%EF%BC%89"><span class="nav-number">1.0.4.12.4.2.</span> <span class="nav-text">堆排序（整体）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.0.4.13.</span> <span class="nav-text">哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81-%E5%AD%97%E6%AF%8D"><span class="nav-number">1.0.4.13.1.</span> <span class="nav-text">哈夫曼编码:字母</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.4.13.1.1.</span> <span class="nav-text">贪心算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E4%BB%A3%E7%A0%81-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E5%B9%B6%E8%BE%93%E5%87%BA-%EF%BC%9A"><span class="nav-number">1.0.4.13.1.2.</span> <span class="nav-text">自己写的代码(输入字符串进行编码并输出)：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AVL%E6%A0%91"><span class="nav-number">1.0.4.14.</span> <span class="nav-text">AVL树</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2023</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">breayhing / SIRI</a>
            
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
            <div class="deploy-info info-item">
                
                    本站由 <span class="tooltip" data-content="GitHub Pages"><img src="/images/deploy-provider/github.png"></span> 提供部署服务
                
            </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
